commit 6fee0dcdbe5db3c344f5c50542ef35e02b17c779
Author: Mitsuha <gamer.mitsuha.dev@gmail.com>
Date:   Sat Oct 11 19:54:38 2025 +0900

    refactor(queue): implement Phase 3 - streaming coordination with SessionManager
    
    Replace scattered state variables in index.ts with SessionManager and Barrier-based
    coordination for cleaner, more maintainable streaming logic.
    
    Changes:
    - Update QueueProcessor to accept and use Barrier
      - Add barrier parameter to start() method
      - Signal barrier.arrive('genDone') BEFORE waiting for active generations
      - This prevents barrier timeout while waiting for completions
      - Add type check for barrier.arrive to support test mocks
    
    - Update SessionManager to pass barrier to processor
    
    - Refactor index.ts streaming coordination
      - Replace 6 scattered state variables with SessionManager
      - Update handleFirstStreamToken() to use sessionManager.startSession()
      - Update handleMessageReceivedForStreaming() to signal barrier
      - Update handleGenerationEnded() to use barrier coordination
      - Fix session lifecycle: end session after image insertion completes
      - Avoid nested scheduleDomOperation to prevent deadlock
      - Update isStreamingActive() and isMessageBeingStreamed() with null checks
      - Initialize sessionManager in initialize()
    
    - Clean up deprecated code
      - Remove ConcurrencyLimiter (replaced by Bottleneck)
      - Remove concurrency_limiter.test.ts
      - Update imports throughout codebase
    
    Benefits:
    - Single source of truth for session state (SessionManager)
    - Explicit barrier coordination (no manual flag checks)
    - Cleaner event handlers (~60 lines removed)
    - Better encapsulation and testability
    - Easier to add features (all state in one place)
    - Prevents race conditions with proper synchronization
    
    Testing:
    - All 348 tests passing
    - Build successful
    - Bundle size: ~169KB
    - Linter clean
    - Manual testing: streaming generation works correctly with image insertion
    
    Fixes #41

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 95ce0c0..1bdda1f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,6 +9,14 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ### Added
 
+- Phase 3: Complete streaming coordination refactor with SessionManager (#41)
+  - Replaced 6 scattered module-level state variables with single SessionManager
+  - Replaced manual flag-based coordination with explicit Barrier pattern
+  - Simplified streaming event handlers (handleFirstStreamToken, handleMessageReceivedForStreaming, handleGenerationEnded)
+  - Removed ~60 lines of complex state management code
+  - Better encapsulation: all session state now in one place
+  - Easier to maintain and extend
+
 - Image loading progress indicators (#19)
   - Real-time progress widget showing "Generating images: X of N"
   - Animated spinner with visual feedback
diff --git a/dist/index.js b/dist/index.js
index b58da33..416d3eb 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1 +1 @@
-(()=>{var __webpack_modules__={741:(e,t,n)=>{"use strict";var r,i,s;s=n(735),i=n(813),r=function(){class e{constructor(e={}){this.options=e,s.load(this.options,this.defaults,this),this.Events=new i(this),this._arr=[],this._resetPromise(),this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise(((e,t)=>this._resolve=e))}_flush(){return clearTimeout(this._timeout),this._lastFlush=Date.now(),this._resolve(),this.Events.trigger("batch",this._arr),this._arr=[],this._resetPromise()}add(e){var t;return this._arr.push(e),t=this._promise,this._arr.length===this.maxSize?this._flush():null!=this.maxTime&&1===this._arr.length&&(this._timeout=setTimeout((()=>this._flush()),this.maxTime)),t}}return e.prototype.defaults={maxTime:null,maxSize:null,Promise},e}.call(void 0),e.exports=r},403:(e,t,n)=>{"use strict";function r(e,t){return o(e)||function(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}(e,t)||s()}function i(e){return o(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||s()}function s(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e){if(Array.isArray(e))return e}function a(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function l(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function o(e){a(s,r,i,o,l,"next",e)}function l(e){a(s,r,i,o,l,"throw",e)}o(void 0)}))}}var c,u,d,p,m,g,h,_,f,v=[].splice;f=n(735),m=n(324),d=n(985),p=n(44),g=n(960),u=n(813),h=n(274),_=n(663),c=function(){class e{constructor(t={},...n){var r,i;this._addToQueue=this._addToQueue.bind(this),this._validateOptions(t,n),f.load(t,this.instanceDefaults,this),this._queues=new m(10),this._scheduled={},this._states=new h(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[])),this._limiter=null,this.Events=new u(this),this._submitLock=new _("submit",this.Promise),this._registerLock=new _("register",this.Promise),i=f.load(t,this.storeDefaults,{}),this._store=function(){if("redis"===this.datastore||"ioredis"===this.datastore||null!=this.connection)return r=f.load(t,this.redisStoreDefaults,{}),new g(this,i,r);if("local"===this.datastore)return r=f.load(t,this.localStoreDefaults,{}),new p(this,i,r);throw new e.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}.call(this),this._queues.on("leftzero",(()=>{var e;return null!=(e=this._store.heartbeat)&&"function"==typeof e.ref?e.ref():void 0})),this._queues.on("zero",(()=>{var e;return null!=(e=this._store.heartbeat)&&"function"==typeof e.unref?e.unref():void 0}))}_validateOptions(t,n){if(null==t||"object"!=typeof t||0!==n.length)throw new e.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(e){return this._store.__publish__(e)}disconnect(e=!0){return this._store.__disconnect__(e)}chain(e){return this._limiter=e,this}queued(e){return this._queues.queued(e)}clusterQueued(){return this._store.__queued__()}empty(){return 0===this.queued()&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(e){return this._states.jobStatus(e)}jobs(e){return this._states.statusJobs(e)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(e=1){return this._store.__check__(e)}_clearGlobalState(e){return null!=this._scheduled[e]&&(clearTimeout(this._scheduled[e].expiration),delete this._scheduled[e],!0)}_free(e,t,n,r){var i=this;return l((function*(){var t,s;try{if(s=(yield i._store.__free__(e,n.weight)).running,i.Events.trigger("debug",`Freed ${n.id}`,r),0===s&&i.empty())return i.Events.trigger("idle")}catch(e){return t=e,i.Events.trigger("error",t)}}))()}_run(e,t,n){var r,i,s;return t.doRun(),r=this._clearGlobalState.bind(this,e),s=this._run.bind(this,e,t),i=this._free.bind(this,e,t),this._scheduled[e]={timeout:setTimeout((()=>t.doExecute(this._limiter,r,s,i)),n),expiration:null!=t.options.expiration?setTimeout((function(){return t.doExpire(r,s,i)}),n+t.options.expiration):void 0,job:t}}_drainOne(e){return this._registerLock.schedule((()=>{var t,n,r,i,s;if(0===this.queued())return this.Promise.resolve(null);s=this._queues.getFirst();var o=r=s.first();return i=o.options,t=o.args,null!=e&&i.weight>e?this.Promise.resolve(null):(this.Events.trigger("debug",`Draining ${i.id}`,{args:t,options:i}),n=this._randomIndex(),this._store.__register__(n,i.weight,i.expiration).then((({success:e,wait:o,reservoir:a})=>{var l;return this.Events.trigger("debug",`Drained ${i.id}`,{success:e,args:t,options:i}),e?(s.shift(),(l=this.empty())&&this.Events.trigger("empty"),0===a&&this.Events.trigger("depleted",l),this._run(n,r,o),this.Promise.resolve(i.weight)):this.Promise.resolve(null)})))}))}_drainAll(e,t=0){return this._drainOne(e).then((n=>{var r;return null!=n?(r=null!=e?e-n:e,this._drainAll(r,t+n)):this.Promise.resolve(t)})).catch((e=>this.Events.trigger("error",e)))}_dropAllQueued(e){return this._queues.shiftAll((function(t){return t.doDrop({message:e})}))}stop(t={}){var n,r;return t=f.load(t,this.stopDefaults),r=e=>{var t;return t=()=>{var t;return(t=this._states.counts)[0]+t[1]+t[2]+t[3]===e},new this.Promise(((e,n)=>t()?e():this.on("done",(()=>{if(t())return this.removeAllListeners("done"),e()}))))},n=t.dropWaitingJobs?(this._run=function(e,n){return n.doDrop({message:t.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule((()=>this._submitLock.schedule((()=>{var e,n,i;for(e in n=this._scheduled)i=n[e],"RUNNING"===this.jobStatus(i.job.options.id)&&(clearTimeout(i.timeout),clearTimeout(i.expiration),i.job.doDrop({message:t.dropErrorMessage}));return this._dropAllQueued(t.dropErrorMessage),r(0)}))))):this.schedule({priority:9,weight:0},(()=>r(1))),this._receive=function(n){return n._reject(new e.prototype.BottleneckError(t.enqueueErrorMessage))},this.stop=()=>this.Promise.reject(new e.prototype.BottleneckError("stop() has already been called")),n}_addToQueue(t){var n=this;return l((function*(){var r,i,s,o,a,l,c;r=t.args,o=t.options;try{var u=yield n._store.__submit__(n.queued(),o.weight);a=u.reachedHWM,i=u.blocked,c=u.strategy}catch(e){return s=e,n.Events.trigger("debug",`Could not queue ${o.id}`,{args:r,options:o,error:s}),t.doDrop({error:s}),!1}return i?(t.doDrop(),!0):a&&(null!=(l=c===e.prototype.strategy.LEAK?n._queues.shiftLastFrom(o.priority):c===e.prototype.strategy.OVERFLOW_PRIORITY?n._queues.shiftLastFrom(o.priority+1):c===e.prototype.strategy.OVERFLOW?t:void 0)&&l.doDrop(),null==l||c===e.prototype.strategy.OVERFLOW)?(null==l&&t.doDrop(),a):(t.doQueue(a,i),n._queues.push(t),yield n._drainAll(),a)}))()}_receive(t){return null!=this._states.jobStatus(t.options.id)?(t._reject(new e.prototype.BottleneckError(`A job with the same id already exists (id=${t.options.id})`)),!1):(t.doReceive(),this._submitLock.schedule(this._addToQueue,t))}submit(...e){var t,n,s,o,a,l,c,u,p;"function"==typeof e[0]?(l=i(e),n=l[0],e=l.slice(1),c=r(v.call(e,-1),1),t=c[0],o=f.load({},this.jobDefaults)):(o=(u=i(e))[0],n=u[1],e=u.slice(2),p=r(v.call(e,-1),1),t=p[0],o=f.load(o,this.jobDefaults));return a=(...e)=>new this.Promise((function(t,r){return n(...e,(function(...e){return(null!=e[0]?r:t)(e)}))})),(s=new d(a,e,o,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise)).promise.then((function(e){return"function"==typeof t?t(...e):void 0})).catch((function(e){return Array.isArray(e)?"function"==typeof t?t(...e):void 0:"function"==typeof t?t(e):void 0})),this._receive(s)}schedule(...e){var t,n,r;if("function"==typeof e[0]){var s=i(e);r=s[0],e=s.slice(1),n={}}else{var o=i(e);n=o[0],r=o[1],e=o.slice(2)}return t=new d(r,e,n,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),this._receive(t),t.promise}wrap(e){var t,n;return t=this.schedule.bind(this),(n=function(...n){return t(e.bind(this),...n)}).withOptions=function(n,...r){return t(n,e,...r)},n}updateSettings(e={}){var t=this;return l((function*(){return yield t._store.__updateSettings__(f.overwrite(e,t.storeDefaults)),f.overwrite(e,t.instanceDefaults,t),t}))()}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(e=0){return this._store.__incrementReservoir__(e)}}return e.default=e,e.Events=u,e.version=e.prototype.version=n(349).r,e.strategy=e.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3},e.BottleneckError=e.prototype.BottleneckError=n(477),e.Group=e.prototype.Group=n(945),e.RedisConnection=e.prototype.RedisConnection=n(97),e.IORedisConnection=e.prototype.IORedisConnection=n(657),e.Batcher=e.prototype.Batcher=n(741),e.prototype.jobDefaults={priority:5,weight:1,expiration:null,id:"<no-id>"},e.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:e.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null},e.prototype.localStoreDefaults={Promise,timeout:null,heartbeatInterval:250},e.prototype.redisStoreDefaults={Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,Redis:null,clientOptions:{},clusterNodes:null,clearDatastore:!1,connection:null},e.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:!0,trackDoneStatus:!1,Promise},e.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:!0,dropErrorMessage:"This limiter has been stopped."},e}.call(void 0),e.exports=c},477:e=>{"use strict";var t;t=class extends Error{},e.exports=t},708:e=>{"use strict";var t;t=class{constructor(e,t){this.incr=e,this.decr=t,this._first=null,this._last=null,this.length=0}push(e){var t;this.length++,"function"==typeof this.incr&&this.incr(),t={value:e,prev:this._last,next:null},null!=this._last?(this._last.next=t,this._last=t):this._first=this._last=t}shift(){var e;if(null!=this._first)return this.length--,"function"==typeof this.decr&&this.decr(),e=this._first.value,null!=(this._first=this._first.next)?this._first.prev=null:this._last=null,e}first(){if(null!=this._first)return this._first.value}getArray(){var e,t,n;for(e=this._first,n=[];null!=e;)n.push((t=e,e=e.next,t.value));return n}forEachShift(e){var t;for(t=this.shift();null!=t;)e(t),t=this.shift()}debug(){var e,t,n,r,i;for(e=this._first,i=[];null!=e;)i.push((t=e,e=e.next,{value:t.value,prev:null!=(n=t.prev)?n.value:void 0,next:null!=(r=t.next)?r.value:void 0}));return i}},e.exports=t},813:e=>{"use strict";function t(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function n(e){return function(){var n=this,r=arguments;return new Promise((function(i,s){var o=e.apply(n,r);function a(e){t(o,i,s,a,l,"next",e)}function l(e){t(o,i,s,a,l,"throw",e)}a(void 0)}))}}var r;r=class{constructor(e){if(this.instance=e,this._events={},null!=this.instance.on||null!=this.instance.once||null!=this.instance.removeAllListeners)throw new Error("An Emitter already exists for this object");this.instance.on=(e,t)=>this._addListener(e,"many",t),this.instance.once=(e,t)=>this._addListener(e,"once",t),this.instance.removeAllListeners=(e=null)=>null!=e?delete this._events[e]:this._events={}}_addListener(e,t,n){var r;return null==(r=this._events)[e]&&(r[e]=[]),this._events[e].push({cb:n,status:t}),this.instance}listenerCount(e){return null!=this._events[e]?this._events[e].length:0}trigger(e,...t){var r=this;return n((function*(){var i,s;try{if("debug"!==e&&r.trigger("debug",`Event triggered: ${e}`,t),null==r._events[e])return;return r._events[e]=r._events[e].filter((function(e){return"none"!==e.status})),s=r._events[e].map(function(){var e=n((function*(e){var n,i;if("none"!==e.status){"once"===e.status&&(e.status="none");try{return"function"==typeof(null!=(i="function"==typeof e.cb?e.cb(...t):void 0)?i.then:void 0)?yield i:i}catch(e){return n=e,r.trigger("error",n),null}}}));return function(t){return e.apply(this,arguments)}}()),(yield Promise.all(s)).find((function(e){return null!=e}))}catch(e){return i=e,r.trigger("error",i),null}}))()}},e.exports=r},945:(e,t,n)=>{"use strict";function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function i(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function s(e){return function(){var t=this,n=arguments;return new Promise((function(r,s){var o=e.apply(t,n);function a(e){i(o,r,s,a,l,"next",e)}function l(e){i(o,r,s,a,l,"throw",e)}a(void 0)}))}}var o,a,l,c,u,d;d=n(735),o=n(813),c=n(97),l=n(657),u=n(618),a=function(){class e{constructor(e={}){this.deleteKey=this.deleteKey.bind(this),this.limiterOptions=e,d.load(this.limiterOptions,this.defaults,this),this.Events=new o(this),this.instances={},this.Bottleneck=n(403),this._startAutoCleanup(),this.sharedConnection=null!=this.connection,null==this.connection&&("redis"===this.limiterOptions.datastore?this.connection=new c(Object.assign({},this.limiterOptions,{Events:this.Events})):"ioredis"===this.limiterOptions.datastore&&(this.connection=new l(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(e=""){var t;return null!=(t=this.instances[e])?t:(()=>{var t;return t=this.instances[e]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${e}`,timeout:this.timeout,connection:this.connection})),this.Events.trigger("created",t,e),t})()}deleteKey(e=""){var t=this;return s((function*(){var n,r;return r=t.instances[e],t.connection&&(n=yield t.connection.__runCommand__(["del",...u.allKeys(`${t.id}-${e}`)])),null!=r&&(delete t.instances[e],yield r.disconnect()),null!=r||n>0}))()}limiters(){var e,t,n,r;for(e in n=[],t=this.instances)r=t[e],n.push({key:e,limiter:r});return n}keys(){return Object.keys(this.instances)}clusterKeys(){var e=this;return s((function*(){var t,n,i,s,o,a,l;if(null==e.connection)return e.Promise.resolve(e.keys());for(o=[],t=null,l=`b_${e.id}-`.length,9;0!==t;){var c=r(yield e.connection.__runCommand__(["scan",null!=t?t:0,"match",`b_${e.id}-*_settings`,"count",1e4]),2);for(t=~~c[0],i=0,a=(n=c[1]).length;i<a;i++)s=n[i],o.push(s.slice(l,-9))}return o}))()}_startAutoCleanup(){var e,t=this;return clearInterval(this.interval),"function"==typeof(e=this.interval=setInterval(s((function*(){var e,n,r,i,s,o;for(n in s=Date.now(),i=[],r=t.instances){o=r[n];try{(yield o._store.__groupCheck__(s))?i.push(t.deleteKey(n)):i.push(void 0)}catch(t){e=t,i.push(o.Events.trigger("error",e))}}return i})),this.timeout/2)).unref?e.unref():void 0}updateSettings(e={}){if(d.overwrite(e,this.defaults,this),d.overwrite(e,e,this.limiterOptions),null!=e.timeout)return this._startAutoCleanup()}disconnect(e=!0){var t;if(!this.sharedConnection)return null!=(t=this.connection)?t.disconnect(e):void 0}}return e.prototype.defaults={timeout:3e5,connection:null,Promise,id:"group-key"},e}.call(void 0),e.exports=a},657:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function o(e){asyncGeneratorStep(s,r,i,o,a,"next",e)}function a(e){asyncGeneratorStep(s,r,i,o,a,"throw",e)}o(void 0)}))}}var Events,IORedisConnection,Scripts,parser;parser=__webpack_require__(735),Events=__webpack_require__(813),Scripts=__webpack_require__(618),IORedisConnection=function(){class IORedisConnection{constructor(options={}){parser.load(options,this.defaults,this),null==this.Redis&&(this.Redis=eval("require")("ioredis")),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null!=this.clusterNodes?(this.client=new this.Redis.Cluster(this.clusterNodes,this.clientOptions),this.subscriber=new this.Redis.Cluster(this.clusterNodes,this.clientOptions)):null!=this.client&&null==this.client.duplicate?this.subscriber=new this.Redis.Cluster(this.client.startupNodes,this.client.options):(null==this.client&&(this.client=new this.Redis(this.clientOptions)),this.subscriber=this.client.duplicate()),this.limiters={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then((()=>(this._loadScripts(),{client:this.client,subscriber:this.subscriber})))}_setup(e,t){return e.setMaxListeners(0),new this.Promise(((n,r)=>(e.on("error",(e=>this.Events.trigger("error",e))),t&&e.on("message",((e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0})),"ready"===e.status?n():e.once("ready",n))))}_loadScripts(){return Scripts.names.forEach((e=>this.client.defineCommand(e,{lua:Scripts.payload(e)})))}__runCommand__(e){var t=this;return _asyncToGenerator((function*(){yield t.ready;var n=_slicedToArray(yield t.client.pipeline([e]).exec(),1),r=_slicedToArray(n[0],2);return r[0],r[1]}))()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map((t=>new this.Promise(((n,r)=>this.subscriber.subscribe(t,(()=>(this.limiters[t]=e,n()))))))))}__removeLimiter__(e){var t=this;return[e.channel(),e.channel_client()].forEach(function(){var e=_asyncToGenerator((function*(e){return t.terminated||(yield t.subscriber.unsubscribe(e)),delete t.limiters[e]}));return function(t){return e.apply(this,arguments)}}())}__scriptArgs__(e,t,n,r){var i;return[(i=Scripts.keys(e,t)).length].concat(i,n,r)}__scriptFn__(e){return this.client[e].bind(this.client)}disconnect(e=!0){var t,n,r,i;for(t=0,r=(i=Object.keys(this.limiters)).length;t<r;t++)n=i[t],clearInterval(this.limiters[n]._store.heartbeat);return this.limiters={},this.terminated=!0,e?this.Promise.all([this.client.quit(),this.subscriber.quit()]):(this.client.disconnect(),this.subscriber.disconnect(),this.Promise.resolve())}}return IORedisConnection.prototype.datastore="ioredis",IORedisConnection.prototype.defaults={Redis:null,clientOptions:{},clusterNodes:null,client:null,Promise,Events:null},IORedisConnection}.call(void 0),module.exports=IORedisConnection},985:(e,t,n)=>{"use strict";function r(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function i(e){return function(){var t=this,n=arguments;return new Promise((function(i,s){var o=e.apply(t,n);function a(e){r(o,i,s,a,l,"next",e)}function l(e){r(o,i,s,a,l,"throw",e)}a(void 0)}))}}var s,o,a;a=n(735),s=n(477),o=class{constructor(e,t,n,r,i,s,o,l){this.task=e,this.args=t,this.rejectOnDrop=i,this.Events=s,this._states=o,this.Promise=l,this.options=a.load(n,r),this.options.priority=this._sanitizePriority(this.options.priority),this.options.id===r.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`),this.promise=new this.Promise(((e,t)=>{this._resolve=e,this._reject=t})),this.retryCount=0}_sanitizePriority(e){var t;return(t=~~e!==e?5:e)<0?0:t>9?9:t}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error:e,message:t="This job has been dropped by Bottleneck"}={}){return!!this._states.remove(this.options.id)&&(this.rejectOnDrop&&this._reject(null!=e?e:new s(t)),this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise}),!0)}_assertStatus(e){var t;if((t=this._states.jobStatus(this.options.id))!==e&&("DONE"!==e||null!==t))throw new s(`Invalid job status ${t}, expected ${e}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){return this._states.start(this.options.id),this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(e,t){return this._assertStatus("RECEIVED"),this._states.next(this.options.id),this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM:e,blocked:t})}doRun(){return 0===this.retryCount?(this._assertStatus("QUEUED"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),this.Events.trigger("scheduled",{args:this.args,options:this.options})}doExecute(e,t,n,r){var s=this;return i((function*(){var i,o,a;0===s.retryCount?(s._assertStatus("RUNNING"),s._states.next(s.options.id)):s._assertStatus("EXECUTING"),o={args:s.args,options:s.options,retryCount:s.retryCount},s.Events.trigger("executing",o);try{if(a=yield null!=e?e.schedule(s.options,s.task,...s.args):s.task(...s.args),t())return s.doDone(o),yield r(s.options,o),s._assertStatus("DONE"),s._resolve(a)}catch(e){return i=e,s._onFailure(i,o,t,n,r)}}))()}doExpire(e,t,n){var r,i;return this._states.jobStatus("RUNNING"===this.options.id)&&this._states.next(this.options.id),this._assertStatus("EXECUTING"),i={args:this.args,options:this.options,retryCount:this.retryCount},r=new s(`This job timed out after ${this.options.expiration} ms.`),this._onFailure(r,i,e,t,n)}_onFailure(e,t,n,r,s){var o=this;return i((function*(){var i,a;if(n())return null!=(i=yield o.Events.trigger("failed",e,t))?(a=~~i,o.Events.trigger("retry",`Retrying ${o.options.id} after ${a} ms`,t),o.retryCount++,r(a)):(o.doDone(t),yield s(o.options,t),o._assertStatus("DONE"),o._reject(e))}))()}doDone(e){return this._assertStatus("EXECUTING"),this._states.next(this.options.id),this.Events.trigger("done",e)}},e.exports=o},44:(e,t,n)=>{"use strict";function r(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function i(e){return function(){var t=this,n=arguments;return new Promise((function(i,s){var o=e.apply(t,n);function a(e){r(o,i,s,a,l,"next",e)}function l(e){r(o,i,s,a,l,"throw",e)}a(void 0)}))}}var s,o,a;a=n(735),s=n(477),o=class{constructor(e,t,n){this.instance=e,this.storeOptions=t,this.clientId=this.instance._randomIndex(),a.load(n,n,this),this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now(),this._running=0,this._done=0,this._unblockTime=0,this.ready=this.Promise.resolve(),this.clients={},this._startHeartbeat()}_startHeartbeat(){var e;return null==this.heartbeat&&(null!=this.storeOptions.reservoirRefreshInterval&&null!=this.storeOptions.reservoirRefreshAmount||null!=this.storeOptions.reservoirIncreaseInterval&&null!=this.storeOptions.reservoirIncreaseAmount)?"function"==typeof(e=this.heartbeat=setInterval((()=>{var e,t,n,r,i;if(r=Date.now(),null!=this.storeOptions.reservoirRefreshInterval&&r>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval&&(this._lastReservoirRefresh=r,this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount,this.instance._drainAll(this.computeCapacity())),null!=this.storeOptions.reservoirIncreaseInterval&&r>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval){var s=this.storeOptions;if(e=s.reservoirIncreaseAmount,n=s.reservoirIncreaseMaximum,i=s.reservoir,this._lastReservoirIncrease=r,(t=null!=n?Math.min(e,n-i):e)>0)return this.storeOptions.reservoir+=t,this.instance._drainAll(this.computeCapacity())}}),this.heartbeatInterval)).unref?e.unref():void 0:clearInterval(this.heartbeat)}__publish__(e){var t=this;return i((function*(){return yield t.yieldLoop(),t.instance.Events.trigger("message",e.toString())}))()}__disconnect__(e){var t=this;return i((function*(){return yield t.yieldLoop(),clearInterval(t.heartbeat),t.Promise.resolve()}))()}yieldLoop(e=0){return new this.Promise((function(t,n){return setTimeout(t,e)}))}computePenalty(){var e;return null!=(e=this.storeOptions.penalty)?e:15*this.storeOptions.minTime||5e3}__updateSettings__(e){var t=this;return i((function*(){return yield t.yieldLoop(),a.overwrite(e,e,t.storeOptions),t._startHeartbeat(),t.instance._drainAll(t.computeCapacity()),!0}))()}__running__(){var e=this;return i((function*(){return yield e.yieldLoop(),e._running}))()}__queued__(){var e=this;return i((function*(){return yield e.yieldLoop(),e.instance.queued()}))()}__done__(){var e=this;return i((function*(){return yield e.yieldLoop(),e._done}))()}__groupCheck__(e){var t=this;return i((function*(){return yield t.yieldLoop(),t._nextRequest+t.timeout<e}))()}computeCapacity(){var e,t,n=this.storeOptions;return e=n.maxConcurrent,t=n.reservoir,null!=e&&null!=t?Math.min(e-this._running,t):null!=e?e-this._running:null!=t?t:null}conditionsCheck(e){var t;return null==(t=this.computeCapacity())||e<=t}__incrementReservoir__(e){var t=this;return i((function*(){var n;return yield t.yieldLoop(),n=t.storeOptions.reservoir+=e,t.instance._drainAll(t.computeCapacity()),n}))()}__currentReservoir__(){var e=this;return i((function*(){return yield e.yieldLoop(),e.storeOptions.reservoir}))()}isBlocked(e){return this._unblockTime>=e}check(e,t){return this.conditionsCheck(e)&&this._nextRequest-t<=0}__check__(e){var t=this;return i((function*(){var n;return yield t.yieldLoop(),n=Date.now(),t.check(e,n)}))()}__register__(e,t,n){var r=this;return i((function*(){var e,n;return yield r.yieldLoop(),e=Date.now(),r.conditionsCheck(t)?(r._running+=t,null!=r.storeOptions.reservoir&&(r.storeOptions.reservoir-=t),n=Math.max(r._nextRequest-e,0),r._nextRequest=e+n+r.storeOptions.minTime,{success:!0,wait:n,reservoir:r.storeOptions.reservoir}):{success:!1}}))()}strategyIsBlock(){return 3===this.storeOptions.strategy}__submit__(e,t){var n=this;return i((function*(){var r,i,o;if(yield n.yieldLoop(),null!=n.storeOptions.maxConcurrent&&t>n.storeOptions.maxConcurrent)throw new s(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${n.storeOptions.maxConcurrent}`);return i=Date.now(),o=null!=n.storeOptions.highWater&&e===n.storeOptions.highWater&&!n.check(t,i),(r=n.strategyIsBlock()&&(o||n.isBlocked(i)))&&(n._unblockTime=i+n.computePenalty(),n._nextRequest=n._unblockTime+n.storeOptions.minTime,n.instance._dropAllQueued()),{reachedHWM:o,blocked:r,strategy:n.storeOptions.strategy}}))()}__free__(e,t){var n=this;return i((function*(){return yield n.yieldLoop(),n._running-=t,n._done+=t,n.instance._drainAll(n.computeCapacity()),{running:n._running}}))()}},e.exports=o},324:(e,t,n)=>{"use strict";var r,i,s;r=n(708),i=n(813),s=class{constructor(e){this.Events=new i(this),this._length=0,this._lists=function(){var t,n,i;for(i=[],t=1,n=e;1<=n?t<=n:t>=n;1<=n?++t:--t)i.push(new r((()=>this.incr()),(()=>this.decr())));return i}.call(this)}incr(){if(0==this._length++)return this.Events.trigger("leftzero")}decr(){if(0==--this._length)return this.Events.trigger("zero")}push(e){return this._lists[e.options.priority].push(e)}queued(e){return null!=e?this._lists[e].length:this._length}shiftAll(e){return this._lists.forEach((function(t){return t.forEachShift(e)}))}getFirst(e=this._lists){var t,n,r;for(t=0,n=e.length;t<n;t++)if((r=e[t]).length>0)return r;return[]}shiftLastFrom(e){return this.getFirst(this._lists.slice(e).reverse()).shift()}},e.exports=s},97:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function o(e){asyncGeneratorStep(s,r,i,o,a,"next",e)}function a(e){asyncGeneratorStep(s,r,i,o,a,"throw",e)}o(void 0)}))}}var Events,RedisConnection,Scripts,parser;parser=__webpack_require__(735),Events=__webpack_require__(813),Scripts=__webpack_require__(618),RedisConnection=function(){class RedisConnection{constructor(options={}){parser.load(options,this.defaults,this),null==this.Redis&&(this.Redis=eval("require")("redis")),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null==this.client&&(this.client=this.Redis.createClient(this.clientOptions)),this.subscriber=this.client.duplicate(),this.limiters={},this.shas={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then((()=>this._loadScripts())).then((()=>({client:this.client,subscriber:this.subscriber})))}_setup(e,t){return e.setMaxListeners(0),new this.Promise(((n,r)=>(e.on("error",(e=>this.Events.trigger("error",e))),t&&e.on("message",((e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0})),e.ready?n():e.once("ready",n))))}_loadScript(e){return new this.Promise(((t,n)=>{var r;return r=Scripts.payload(e),this.client.multi([["script","load",r]]).exec(((r,i)=>null!=r?n(r):(this.shas[e]=i[0],t(i[0]))))}))}_loadScripts(){return this.Promise.all(Scripts.names.map((e=>this._loadScript(e))))}__runCommand__(e){var t=this;return _asyncToGenerator((function*(){return yield t.ready,new t.Promise(((n,r)=>t.client.multi([e]).exec_atomic((function(e,t){return null!=e?r(e):n(t[0])}))))}))()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map((t=>new this.Promise(((n,r)=>{var i;return i=r=>{if(r===t)return this.subscriber.removeListener("subscribe",i),this.limiters[t]=e,n()},this.subscriber.on("subscribe",i),this.subscriber.subscribe(t)})))))}__removeLimiter__(e){var t=this;return this.Promise.all([e.channel(),e.channel_client()].map(function(){var e=_asyncToGenerator((function*(e){return t.terminated||(yield new t.Promise(((n,r)=>t.subscriber.unsubscribe(e,(function(t,i){return null!=t?r(t):i===e?n():void 0}))))),delete t.limiters[e]}));return function(t){return e.apply(this,arguments)}}()))}__scriptArgs__(e,t,n,r){var i;return i=Scripts.keys(e,t),[this.shas[e],i.length].concat(i,n,r)}__scriptFn__(e){return this.client.evalsha.bind(this.client)}disconnect(e=!0){var t,n,r,i;for(t=0,r=(i=Object.keys(this.limiters)).length;t<r;t++)n=i[t],clearInterval(this.limiters[n]._store.heartbeat);return this.limiters={},this.terminated=!0,this.client.end(e),this.subscriber.end(e),this.Promise.resolve()}}return RedisConnection.prototype.datastore="redis",RedisConnection.prototype.defaults={Redis:null,clientOptions:{},client:null,Promise,Events:null},RedisConnection}.call(void 0),module.exports=RedisConnection},960:(e,t,n)=>{"use strict";function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function i(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function s(e){return function(){var t=this,n=arguments;return new Promise((function(r,s){var o=e.apply(t,n);function a(e){i(o,r,s,a,l,"next",e)}function l(e){i(o,r,s,a,l,"throw",e)}a(void 0)}))}}var o,a,l,c,u;u=n(735),o=n(477),l=n(97),a=n(657),c=class{constructor(e,t,n){this.instance=e,this.storeOptions=t,this.originalId=this.instance.id,this.clientId=this.instance._randomIndex(),u.load(n,n,this),this.clients={},this.capacityPriorityCounters={},this.sharedConnection=null!=this.connection,null==this.connection&&(this.connection="redis"===this.instance.datastore?new l({Redis:this.Redis,clientOptions:this.clientOptions,Promise:this.Promise,Events:this.instance.Events}):"ioredis"===this.instance.datastore?new a({Redis:this.Redis,clientOptions:this.clientOptions,clusterNodes:this.clusterNodes,Promise:this.Promise,Events:this.instance.Events}):void 0),this.instance.connection=this.connection,this.instance.datastore=this.connection.datastore,this.ready=this.connection.ready.then((e=>(this.clients=e,this.runScript("init",this.prepareInitSettings(this.clearDatastore))))).then((()=>this.connection.__addLimiter__(this.instance))).then((()=>this.runScript("register_client",[this.instance.queued()]))).then((()=>{var e;return"function"==typeof(e=this.heartbeat=setInterval((()=>this.runScript("heartbeat",[]).catch((e=>this.instance.Events.trigger("error",e)))),this.heartbeatInterval)).unref&&e.unref(),this.clients}))}__publish__(e){var t=this;return s((function*(){return(yield t.ready).client.publish(t.instance.channel(),`message:${e.toString()}`)}))()}onMessage(e,t){var n=this;return s((function*(){var e,i,o,a,l,c,u,d,p,m;try{u=t.indexOf(":");var g=[t.slice(0,u),t.slice(u+1)];if(o=g[1],"capacity"===(m=g[0]))return yield n.instance._drainAll(o.length>0?~~o:void 0);if("capacity-priority"===m){var h=r(o.split(":"),3);return p=h[0],d=h[1],i=h[2],e=p.length>0?~~p:void 0,d===n.clientId?(a=yield n.instance._drainAll(e),c=null!=e?e-(a||0):"",yield n.clients.client.publish(n.instance.channel(),`capacity-priority:${c}::${i}`)):""===d?(clearTimeout(n.capacityPriorityCounters[i]),delete n.capacityPriorityCounters[i],n.instance._drainAll(e)):n.capacityPriorityCounters[i]=setTimeout(s((function*(){var t;try{return delete n.capacityPriorityCounters[i],yield n.runScript("blacklist_client",[d]),yield n.instance._drainAll(e)}catch(e){return t=e,n.instance.Events.trigger("error",t)}})),1e3)}if("message"===m)return n.instance.Events.trigger("message",o);if("blocked"===m)return yield n.instance._dropAllQueued()}catch(e){return l=e,n.instance.Events.trigger("error",l)}}))()}__disconnect__(e){return clearInterval(this.heartbeat),this.sharedConnection?this.connection.__removeLimiter__(this.instance):this.connection.disconnect(e)}runScript(e,t){var n=this;return s((function*(){return"init"!==e&&"register_client"!==e&&(yield n.ready),new n.Promise(((r,i)=>{var s,o;return s=[Date.now(),n.clientId].concat(t),n.instance.Events.trigger("debug",`Calling Redis script: ${e}.lua`,s),o=n.connection.__scriptArgs__(e,n.originalId,s,(function(e,t){return null!=e?i(e):r(t)})),n.connection.__scriptFn__(e)(...o)})).catch((r=>"SETTINGS_KEY_NOT_FOUND"===r.message?"heartbeat"===e?n.Promise.resolve():n.runScript("init",n.prepareInitSettings(!1)).then((()=>n.runScript(e,t))):"UNKNOWN_CLIENT"===r.message?n.runScript("register_client",[n.instance.queued()]).then((()=>n.runScript(e,t))):n.Promise.reject(r)))}))()}prepareArray(e){var t,n,r,i;for(r=[],t=0,n=e.length;t<n;t++)i=e[t],r.push(null!=i?i.toString():"");return r}prepareObject(e){var t,n,r;for(n in t=[],e)r=e[n],t.push(n,null!=r?r.toString():"");return t}prepareInitSettings(e){var t;return(t=this.prepareObject(Object.assign({},this.storeOptions,{id:this.originalId,version:this.instance.version,groupTimeout:this.timeout,clientTimeout:this.clientTimeout}))).unshift(e?1:0,this.instance.version),t}convertBool(e){return!!e}__updateSettings__(e){var t=this;return s((function*(){return yield t.runScript("update_settings",t.prepareObject(e)),u.overwrite(e,e,t.storeOptions)}))()}__running__(){return this.runScript("running",[])}__queued__(){return this.runScript("queued",[])}__done__(){return this.runScript("done",[])}__groupCheck__(){var e=this;return s((function*(){return e.convertBool(yield e.runScript("group_check",[]))}))()}__incrementReservoir__(e){return this.runScript("increment_reservoir",[e])}__currentReservoir__(){return this.runScript("current_reservoir",[])}__check__(e){var t=this;return s((function*(){return t.convertBool(yield t.runScript("check",t.prepareArray([e])))}))()}__register__(e,t,n){var i=this;return s((function*(){var s,o,a,l=r(yield i.runScript("register",i.prepareArray([e,t,n])),3);return o=l[0],a=l[1],s=l[2],{success:i.convertBool(o),wait:a,reservoir:s}}))()}__submit__(e,t){var n=this;return s((function*(){var i,s,a,l,c;try{var u=r(yield n.runScript("submit",n.prepareArray([e,t])),3);return l=u[0],i=u[1],c=u[2],{reachedHWM:n.convertBool(l),blocked:n.convertBool(i),strategy:c}}catch(e){if(0===(s=e).message.indexOf("OVERWEIGHT")){var d=r(s.message.split(":"),3);throw d[0],t=d[1],a=d[2],new o(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${a}`)}throw s}}))()}__free__(e,t){var n=this;return s((function*(){return{running:yield n.runScript("free",n.prepareArray([e]))}}))()}},e.exports=c},618:(e,t,n)=>{"use strict";var r,i,s;i=n(495),r={refs:i["refs.lua"],validate_keys:i["validate_keys.lua"],validate_client:i["validate_client.lua"],refresh_expiration:i["refresh_expiration.lua"],process_tick:i["process_tick.lua"],conditions_check:i["conditions_check.lua"],get_time:i["get_time.lua"]},t.allKeys=function(e){return[`b_${e}_settings`,`b_${e}_job_weights`,`b_${e}_job_expirations`,`b_${e}_job_clients`,`b_${e}_client_running`,`b_${e}_client_num_queued`,`b_${e}_client_last_registered`,`b_${e}_client_last_seen`]},s={init:{keys:t.allKeys,headers:["process_tick"],refresh_expiration:!0,code:i["init.lua"]},group_check:{keys:t.allKeys,headers:[],refresh_expiration:!1,code:i["group_check.lua"]},register_client:{keys:t.allKeys,headers:["validate_keys"],refresh_expiration:!1,code:i["register_client.lua"]},blacklist_client:{keys:t.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:i["blacklist_client.lua"]},heartbeat:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["heartbeat.lua"]},update_settings:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:i["update_settings.lua"]},running:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["running.lua"]},queued:{keys:t.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:i["queued.lua"]},done:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["done.lua"]},check:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!1,code:i["check.lua"]},submit:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:i["submit.lua"]},register:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:i["register.lua"]},free:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:i["free.lua"]},current_reservoir:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["current_reservoir.lua"]},increment_reservoir:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:i["increment_reservoir.lua"]}},t.names=Object.keys(s),t.keys=function(e,t){return s[e].keys(t)},t.payload=function(e){var t;return t=s[e],Array.prototype.concat(r.refs,t.headers.map((function(e){return r[e]})),t.refresh_expiration?r.refresh_expiration:"",t.code).join("\n")}},274:(e,t,n)=>{"use strict";var r,i;r=n(477),i=class{constructor(e){this.status=e,this._jobs={},this.counts=this.status.map((function(){return 0}))}next(e){var t,n;return n=(t=this._jobs[e])+1,null!=t&&n<this.status.length?(this.counts[t]--,this.counts[n]++,this._jobs[e]++):null!=t?(this.counts[t]--,delete this._jobs[e]):void 0}start(e){return 0,this._jobs[e]=0,this.counts[0]++}remove(e){var t;return null!=(t=this._jobs[e])&&(this.counts[t]--,delete this._jobs[e]),null!=t}jobStatus(e){var t;return null!=(t=this.status[this._jobs[e]])?t:null}statusJobs(e){var t,n,i,s;if(null!=e){if((n=this.status.indexOf(e))<0)throw new r(`status must be one of ${this.status.join(", ")}`);for(t in s=[],i=this._jobs)i[t]===n&&s.push(t);return s}return Object.keys(this._jobs)}statusCounts(){return this.counts.reduce(((e,t,n)=>(e[this.status[n]]=t,e)),{})}},e.exports=i},663:(e,t,n)=>{"use strict";function r(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function i(e){return function(){var t=this,n=arguments;return new Promise((function(i,s){var o=e.apply(t,n);function a(e){r(o,i,s,a,l,"next",e)}function l(e){r(o,i,s,a,l,"throw",e)}a(void 0)}))}}var s,o;s=n(708),o=class{constructor(e,t){this.schedule=this.schedule.bind(this),this.name=e,this.Promise=t,this._running=0,this._queue=new s}isEmpty(){return 0===this._queue.length}_tryToRun(){var e=this;return i((function*(){var t,n,r,s,o,a,l;if(e._running<1&&e._queue.length>0){e._running++;var c=e._queue.shift();return l=c.task,t=c.args,o=c.resolve,s=c.reject,n=yield i((function*(){try{return a=yield l(...t),function(){return o(a)}}catch(e){return r=e,function(){return s(r)}}}))(),e._running--,e._tryToRun(),n()}}))()}schedule(e,...t){var n,r,i;return i=r=null,n=new this.Promise((function(e,t){return i=e,r=t})),this._queue.push({task:e,args:t,resolve:i,reject:r}),this._tryToRun(),n}},e.exports=o},390:(e,t,n)=>{"use strict";e.exports=n(403)},735:(e,t)=>{"use strict";t.load=function(e,t,n={}){var r,i,s;for(r in t)s=t[r],n[r]=null!=(i=e[r])?i:s;return n},t.overwrite=function(e,t,n={}){var r,i;for(r in e)i=e[r],void 0!==t[r]&&(n[r]=i);return n}},208:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(601),i=n.n(r),s=n(314),o=n.n(s)()(i());o.push([e.id,"/* Clickable AI-generated images */\n.mes_text img[title^='AI generated image'] {\n  cursor: pointer;\n  transition:\n    opacity 0.2s,\n    transform 0.2s,\n    box-shadow 0.2s;\n}\n\n.mes_text img[title^='AI generated image']:hover {\n  opacity: 0.85;\n  transform: scale(1.02);\n  box-shadow: 0 0 15px rgba(155, 89, 182, 0.6);\n}\n\n/* Image generation progress widget */\n/* Legacy per-message widget (deprecated) */\n.ai-img-progress-widget {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(155, 89, 182, 0.3);\n  border-radius: 4px;\n  margin-top: 0.5rem;\n  font-size: 0.9rem;\n  color: #ffffff;\n  animation: fadeIn 0.3s ease-in;\n  backdrop-filter: blur(4px);\n}\n\n/* Global progress widget above user input */\n.ai-img-progress-widget-global {\n  /* Use sticky positioning within #sheld for reliable visibility */\n  position: sticky;\n  bottom: 0;\n  /* Use margin auto for centering instead of left+transform with sticky */\n  margin-left: auto;\n  margin-right: auto;\n  margin-bottom: 0.5rem;\n  z-index: 100;\n  pointer-events: auto;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  gap: 0.75rem;\n  padding: 0.75rem 1.5rem;\n  min-width: 200px;\n  min-height: 40px;\n  background: rgba(0, 0, 0, 0.85);\n  border: 1px solid rgba(155, 89, 182, 0.5);\n  border-radius: 6px;\n  font-size: 0.9rem;\n  color: #ffffff;\n  animation: fadeIn 0.3s ease-in;\n  backdrop-filter: blur(8px);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  max-width: 90%;\n}\n\n.ai-img-progress-text-container {\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n  flex: 1;\n  min-width: 150px;\n}\n\n.ai-img-progress-spinner {\n  width: 16px;\n  height: 16px;\n  min-width: 16px;\n  min-height: 16px;\n  border: 2px solid rgba(255, 255, 255, 0.3);\n  border-top-color: #9b59b6;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n  flex-shrink: 0;\n}\n\n.ai-img-progress-text {\n  flex: 1;\n  white-space: nowrap;\n  line-height: 1.4;\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    transform: translateY(-5px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n/* Mobile optimizations for progress widget */\n@media (max-width: 768px) {\n  .ai-img-progress-widget {\n    font-size: 0.85rem;\n    padding: 0.4rem 0.8rem;\n  }\n\n  .ai-img-progress-widget-global {\n    font-size: 0.85rem;\n    padding: 0.6rem 1.2rem;\n    bottom: 100px;\n  }\n\n  .ai-img-progress-spinner {\n    width: 14px;\n    height: 14px;\n  }\n}\n\n/* Preset Management Styles */\n.preset-management {\n  margin: 1rem 0;\n}\n\n.preset-toolbar {\n  display: flex;\n  gap: 0.5rem;\n  align-items: center;\n  margin-bottom: 0.5rem;\n}\n\n.preset-toolbar .flex_fill {\n  flex: 1;\n}\n\n.preset-toolbar button {\n  flex-shrink: 0;\n}\n\n.preset-toolbar button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.preset-content-preview {\n  margin-top: 0.5rem;\n  padding: 0.75rem;\n  background-color: rgba(0, 0, 0, 0.1);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  border-radius: 4px;\n}\n\n.preset-content-preview label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: bold;\n  font-size: 0.9rem;\n}\n\n.preset-preview-text {\n  font-family: 'Courier New', Courier, monospace;\n  font-size: 0.85rem;\n  white-space: pre-wrap;\n  word-break: break-word;\n  max-height: 200px;\n  overflow-y: auto;\n  margin: 0;\n  padding: 0.5rem;\n  background-color: rgba(0, 0, 0, 0.2);\n  border-radius: 3px;\n}\n\n.preset-edit-actions {\n  display: flex;\n  gap: 0.5rem;\n  margin-top: 0.5rem;\n}\n\n.preset-edit-actions button {\n  flex: 1;\n}\n\n.preset-edit-actions button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Pattern Validation Status */\n.pattern-validation-status {\n  margin-top: 0.75rem;\n  padding: 0.75rem;\n  border-radius: 4px;\n  font-size: 0.9rem;\n  line-height: 1.5;\n}\n\n.pattern-validation-status.validation-success {\n  background-color: rgba(76, 175, 80, 0.1);\n  border: 1px solid rgba(76, 175, 80, 0.3);\n  color: #81c784;\n}\n\n.pattern-validation-status.validation-warning {\n  background-color: rgba(255, 152, 0, 0.1);\n  border: 1px solid rgba(255, 152, 0, 0.3);\n  color: #ffb74d;\n}\n\n.pattern-validation-status .validation-icon {\n  margin-right: 0.5rem;\n  font-weight: bold;\n}\n\n.pattern-validation-status .validation-message {\n  display: block;\n}\n\n.pattern-validation-status .validation-hint {\n  display: block;\n  margin-top: 0.5rem;\n  font-size: 0.85rem;\n  opacity: 0.8;\n}\n\n/* Manual Generation Button */\n.auto_illustrator_manual_gen {\n  color: #9b59b6 !important;\n  cursor: pointer;\n}\n\n.auto_illustrator_manual_gen:hover {\n  color: #bb79d6 !important;\n}\n\n.auto_illustrator_manual_gen:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Manual Generation Dialog Backdrop */\n.auto-illustrator-dialog-backdrop {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.7);\n  z-index: 9999;\n}\n\n/* All dialogs (manual generation, regeneration, prompt update, confirmation) */\n.auto-illustrator-dialog {\n  position: fixed;\n  top: 10vh;\n  left: 50%;\n  transform: translateX(-50%);\n  background: var(--SmartThemeBlurTintColor, #2a2a2a);\n  border: 2px solid var(--SmartThemeBorderColor, #666);\n  border-radius: 8px;\n  padding: 1.5rem;\n  max-width: 500px;\n  max-height: 85vh;\n  width: 90%;\n  z-index: 10000;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);\n  color: #ffffff;\n  overflow-y: auto;\n  box-sizing: border-box;\n}\n\n/* Regeneration confirmation dialog - position lower for easier tapping */\n#auto_illustrator_regen_confirm_dialog {\n  top: 35vh;\n}\n\n/* Mobile optimizations */\n@media (max-width: 768px) {\n  .auto-illustrator-dialog {\n    width: 95%;\n    padding: 1rem;\n    top: 5vh;\n    max-height: 90vh;\n  }\n\n  #auto_illustrator_regen_confirm_dialog {\n    top: 30vh;\n  }\n\n  .auto-illustrator-dialog h3 {\n    font-size: 1rem;\n  }\n\n  .auto-illustrator-dialog p {\n    font-size: 0.9rem;\n  }\n}\n\n.auto-illustrator-dialog p {\n  margin: 0 0 1rem 0;\n  line-height: 1.6;\n  white-space: pre-line;\n  color: #ffffff;\n  font-size: 1rem;\n}\n\n.auto-illustrator-dialog h3 {\n  margin: 0 0 1rem 0;\n  color: #ffffff;\n  font-size: 1.2rem;\n}\n\n.auto-illustrator-dialog label {\n  display: block;\n  margin: 0.5rem 0 0.25rem 0;\n  color: #ffffff;\n  font-size: 0.9rem;\n}\n\n.auto-illustrator-dialog textarea {\n  width: 100%;\n  min-height: 80px;\n  padding: 0.5rem;\n  background: rgba(0, 0, 0, 0.3);\n  border: 1px solid var(--SmartThemeBorderColor, #666);\n  border-radius: 4px;\n  color: #ffffff;\n  font-family: inherit;\n  font-size: 0.9rem;\n  resize: vertical;\n  box-sizing: border-box;\n}\n\n.auto-illustrator-dialog textarea:focus {\n  outline: none;\n  border-color: #9b59b6;\n  background: rgba(0, 0, 0, 0.4);\n}\n\n.auto-illustrator-dialog textarea::placeholder {\n  color: rgba(255, 255, 255, 0.4);\n}\n\n.auto-illustrator-feedback-textarea {\n  margin-bottom: 0.5rem;\n}\n\n.auto-illustrator-mode-group {\n  margin: 1rem 0;\n  display: flex;\n  flex-direction: column;\n  gap: 0.75rem;\n}\n\n.auto-illustrator-mode-option {\n  display: flex;\n  align-items: flex-start;\n  gap: 0.75rem;\n  padding: 0.75rem;\n  border: 1px solid var(--SmartThemeBorderColor, #666);\n  border-radius: 4px;\n  cursor: pointer;\n  transition: background-color 0.2s;\n  color: #ffffff;\n  background: rgba(0, 0, 0, 0.2);\n}\n\n.auto-illustrator-mode-option span {\n  color: #ffffff;\n  line-height: 1.5;\n}\n\n.auto-illustrator-mode-option:hover {\n  background-color: rgba(255, 255, 255, 0.05);\n}\n\n.auto-illustrator-mode-option input[type=\"radio\"] {\n  margin-top: 0.2rem;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.auto-illustrator-mode-option span {\n  flex: 1;\n  line-height: 1.4;\n}\n\n.auto-illustrator-mode-option strong {\n  display: block;\n  margin-bottom: 0.25rem;\n}\n\n.auto-illustrator-dialog-buttons {\n  display: flex;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  margin-top: 1.5rem;\n  flex-wrap: wrap;\n}\n\n.auto-illustrator-dialog-buttons button {\n  min-width: 100px;\n  flex: 1 1 auto;\n  white-space: nowrap;\n}\n\n/* Mobile button optimizations */\n@media (max-width: 768px) {\n  .auto-illustrator-dialog-buttons {\n    gap: 0.4rem;\n    margin-top: 1rem;\n  }\n\n  .auto-illustrator-dialog-buttons button {\n    min-width: 80px;\n    font-size: 0.9rem;\n    padding: 0.5rem 0.75rem;\n  }\n}",""]);const a=o},314:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var o={};if(r)for(var a=0;a<this.length;a++){var l=this[a][0];null!=l&&(o[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&o[u[0]]||(void 0!==s&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=s),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),i&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=i):u[4]="".concat(i)),t.push(u))}},t}},601:e=>{"use strict";e.exports=function(e){return e[1]}},65:function(e,t,n){var r,i;!function(s,o){"use strict";r=function(){var e=function(){},t="undefined",n=typeof window!==t&&typeof window.navigator!==t&&/Trident\/|MSIE /.test(window.navigator.userAgent),r=["trace","debug","info","warn","error"],i={},s=null;function o(e,t){var n=e[t];if("function"==typeof n.bind)return n.bind(e);try{return Function.prototype.bind.call(n,e)}catch(t){return function(){return Function.prototype.apply.apply(n,[e,arguments])}}}function a(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function l(r){return"debug"===r&&(r="log"),typeof console!==t&&("trace"===r&&n?a:void 0!==console[r]?o(console,r):void 0!==console.log?o(console,"log"):e)}function c(){for(var n=this.getLevel(),i=0;i<r.length;i++){var s=r[i];this[s]=i<n?e:this.methodFactory(s,n,this.name)}if(this.log=this.debug,typeof console===t&&n<this.levels.SILENT)return"No console available for logging"}function u(e){return function(){typeof console!==t&&(c.call(this),this[e].apply(this,arguments))}}function d(e,t,n){return l(e)||u.apply(this,arguments)}function p(e,n){var o,a,l,u=this,p="loglevel";function m(e){var n=(r[e]||"silent").toUpperCase();if(typeof window!==t&&p){try{return void(window.localStorage[p]=n)}catch(e){}try{window.document.cookie=encodeURIComponent(p)+"="+n+";"}catch(e){}}}function g(){var e;if(typeof window!==t&&p){try{e=window.localStorage[p]}catch(e){}if(typeof e===t)try{var n=window.document.cookie,r=encodeURIComponent(p),i=n.indexOf(r+"=");-1!==i&&(e=/^([^;]+)/.exec(n.slice(i+r.length+1))[1])}catch(e){}return void 0===u.levels[e]&&(e=void 0),e}}function h(){if(typeof window!==t&&p){try{window.localStorage.removeItem(p)}catch(e){}try{window.document.cookie=encodeURIComponent(p)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch(e){}}}function _(e){var t=e;if("string"==typeof t&&void 0!==u.levels[t.toUpperCase()]&&(t=u.levels[t.toUpperCase()]),"number"==typeof t&&t>=0&&t<=u.levels.SILENT)return t;throw new TypeError("log.setLevel() called with invalid level: "+e)}"string"==typeof e?p+=":"+e:"symbol"==typeof e&&(p=void 0),u.name=e,u.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},u.methodFactory=n||d,u.getLevel=function(){return null!=l?l:null!=a?a:o},u.setLevel=function(e,t){return l=_(e),!1!==t&&m(l),c.call(u)},u.setDefaultLevel=function(e){a=_(e),g()||u.setLevel(e,!1)},u.resetLevel=function(){l=null,h(),c.call(u)},u.enableAll=function(e){u.setLevel(u.levels.TRACE,e)},u.disableAll=function(e){u.setLevel(u.levels.SILENT,e)},u.rebuild=function(){if(s!==u&&(o=_(s.getLevel())),c.call(u),s===u)for(var e in i)i[e].rebuild()},o=_(s?s.getLevel():"WARN");var f=g();null!=f&&(l=_(f)),c.call(u)}(s=new p).getLogger=function(e){if("symbol"!=typeof e&&"string"!=typeof e||""===e)throw new TypeError("You must supply a name when creating a logger.");var t=i[e];return t||(t=i[e]=new p(e,s.methodFactory)),t};var m=typeof window!==t?window.log:void 0;return s.noConflict=function(){return typeof window!==t&&window.log===s&&(window.log=m),s},s.getLoggers=function(){return i},s.default=s,s},void 0===(i="function"==typeof r?r.call(t,n,t,e):r)||(e.exports=i)}()},72:e=>{"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var s={},o=[],a=0;a<e.length;a++){var l=e[a],c=r.base?l[0]+r.base:l[0],u=s[c]||0,d="".concat(c," ").concat(u);s[c]=u+1;var p=n(d),m={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(m);else{var g=i(m,r);r.byIndex=a,t.splice(a,0,{identifier:d,updater:g,references:1})}o.push(d)}return o}function i(e,t){var n=t.domAPI(t);n.update(e);return function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,i){var s=r(e=e||[],i=i||{});return function(e){e=e||[];for(var o=0;o<s.length;o++){var a=n(s[o]);t[a].references--}for(var l=r(e,i),c=0;c<s.length;c++){var u=n(s[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}s=l}}},659:e=>{"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},540:e=>{"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},56:(e,t,n)=>{"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},825:e=>{"use strict";e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var i=void 0!==n.layer;i&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,i&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var s=n.sourceMap;s&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},113:e=>{"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},28:(e,t,n)=>{"use strict";n.d(t,{BB:()=>i,DV:()=>a,a$:()=>l,a2:()=>r,he:()=>c,uF:()=>o,zY:()=>s});const r="auto_illustrator",i={DEFAULT:300,MIN:100,MAX:1e3,STEP:50},s={DEFAULT:1,MIN:1,MAX:5,STEP:1},o={DEFAULT:0,MIN:0,MAX:1e4,STEP:100},a=['\x3c!--img-prompt="([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"\\s*--\x3e','<img-prompt="([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"\\s*>','<img_prompt="([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"\\s*>'],l={enabled:!0,streamingEnabled:!0,streamingPollInterval:i.DEFAULT,maxConcurrentGenerations:s.DEFAULT,minGenerationInterval:o.DEFAULT,logLevel:"info",currentPresetId:"default",customPresets:[],manualGenerationMode:"append",promptDetectionPatterns:a,commonStyleTags:"",commonStyleTagsPosition:"prefix"},c={ENABLED:"auto_illustrator_enabled",META_PROMPT:"auto_illustrator_meta_prompt",META_PROMPT_PRESET_SELECT:"auto_illustrator_preset_select",META_PROMPT_PRESET_EDIT:"auto_illustrator_preset_edit",META_PROMPT_PRESET_SAVE:"auto_illustrator_preset_save",META_PROMPT_PRESET_SAVE_AS:"auto_illustrator_preset_save_as",META_PROMPT_PRESET_DELETE:"auto_illustrator_preset_delete",META_PROMPT_PRESET_CANCEL:"auto_illustrator_preset_cancel",PRESET_EDITOR:"auto_illustrator_preset_editor",PRESET_VIEWER:"auto_illustrator_preset_viewer",PRESET_PREVIEW:"auto_illustrator_preset_preview",STREAMING_ENABLED:"auto_illustrator_streaming_enabled",STREAMING_POLL_INTERVAL:"auto_illustrator_streaming_poll_interval",MAX_CONCURRENT:"auto_illustrator_max_concurrent",MIN_GENERATION_INTERVAL:"auto_illustrator_min_generation_interval",LOG_LEVEL:"auto_illustrator_log_level",MANUAL_GEN_MODE:"auto_illustrator_manual_gen_mode",PROMPT_PATTERNS:"auto_illustrator_prompt_patterns",PROMPT_PATTERNS_RESET:"auto_illustrator_prompt_patterns_reset",PATTERN_VALIDATION_STATUS:"auto_illustrator_pattern_validation_status",COMMON_STYLE_TAGS:"auto_illustrator_common_style_tags",COMMON_STYLE_TAGS_POSITION:"auto_illustrator_common_style_tags_position",RESET_BUTTON:"auto_illustrator_reset"}},629:(e,t,n)=>{"use strict";n.d(t,{Tj:()=>a});var r=n(390),i=n.n(r);const s=(0,n(122).h)("DomQueue"),o=new(i().Group)({maxConcurrent:1,trackDoneStatus:!0});async function a(e,t,n){const r=o.key(e.toString()),i=n||"DOM operation";return s.debug(`Scheduling ${i} for message ${e}`),r.schedule((async()=>{s.debug(`Executing ${i} for message ${e}`);try{const n=await t();return s.debug(`Completed ${i} for message ${e}`),n}catch(t){throw s.error(`Failed ${i} for message ${e}:`,t),t}}))}},293:(e,t,n)=>{"use strict";n.d(t,{J:()=>i,m:()=>o,t:()=>s});let r=null;function i(e){r=e.translate}function s(e,t){const n=r?r(e,e):e;if(!t)return n;let i=n;for(const[e,n]of Object.entries(t))i=i.replace(new RegExp(`\\{${e}\\}`,"g"),String(n));return i}function o(e,t,n){return s(t,{...n,count:e})}},75:(e,t,n)=>{"use strict";n.d(t,{R:()=>s,g:()=>o});var r=n(974),i=n(28);function s(e,t=i.DV){if(0===t.length)return!1;if(t.length>1){return(0,r.B7)(t).test(e)}return(0,r.RJ)().test(e)}function o(e,t=i.DV){if(0===t.length)return[];if(t.length>1)return(0,r.lJ)(e,t);const n=[],s=(0,r.RJ)();let o;for(;null!==(o=s.exec(e));){const e=(0,r.Ov)(o[1]).trim();0!==e.length&&n.push({fullMatch:o[0],prompt:e,startIndex:o.index,endIndex:o.index+o[0].length})}return n}},722:(e,t,n)=>{"use strict";n.d(t,{Fz:()=>f,Hl:()=>h,ML:()=>y,SV:()=>m,insertDeferredImages:()=>b,xn:()=>g});var r=n(390),i=n.n(r),s=n(75),o=n(122),a=n(293),l=n(591),c=n(697),u=n(629);const d=(0,o.h)("Generator");let p=null;function m(e,t=0){d.info(`Initializing Bottleneck limiter (maxConcurrent: ${e}, minTime: ${t}ms)`),p=new(i())({maxConcurrent:e,minTime:t,trackDoneStatus:!0}),p.on("depleted",(()=>{d.debug("Image generation queue depleted (all jobs complete)")})),p.on("idle",(()=>{d.debug("Image generation queue idle (no pending jobs)")})),p.on("error",(e=>{d.error("Bottleneck error:",e)}))}function g(e){if(!p)return d.warn("Image limiter not initialized, initializing now"),void m(e);d.info(`Updating maxConcurrent: ${e}`),p.updateSettings({maxConcurrent:e})}function h(e){if(!p)return d.warn("Image limiter not initialized, initializing now"),void m(1,e);d.info(`Updating minTime: ${e}ms`),p.updateSettings({minTime:e})}function _(e,t,n,r){const i=e.indexOf(t);if(-1===i)return d.warn("Could not find prompt tag in text:",t),{text:e,success:!1};const s=i+t.length;if(e.substring(s,s+200).includes(`src="${n}"`))return d.info("Image already inserted, skipping:",n),{text:e,success:!1};const o=function(e,t){const n=`AI generated image #${t+1}`;return`<img src="${e}" title="${n}" alt="${n}">`}(n,r);return{text:e.substring(0,s)+"\n"+o+e.substring(s),success:!0}}async function f(e,t,n,r,s){if(p||(d.warn("Image limiter not initialized, using defaults (1, 0ms)"),p=new(i())({maxConcurrent:1,minTime:0,trackDoneStatus:!0})),s?.aborted)return d.info("Generation aborted before scheduling:",e),null;const o=`${e}_${Date.now()}_${Math.random().toString(36).substring(7)}`;return p.schedule({id:o},(async()=>{if(s?.aborted)return d.info("Generation aborted after scheduling:",e),null;const i=n&&r?function(e,t,n){if(!t||""===t.trim())return e;const r=v(e),i=v(t),s="prefix"===n?[...i,...r]:[...r,...i];return function(e){const t=new Map;for(const n of e){const e=n.toLowerCase();t.has(e)||t.set(e,n)}return Array.from(t.values())}(s).join(", ")}(e,n,r):e;d.info("Generating image for prompt:",i),n&&i!==e&&(d.debug(`Original prompt: "${e}"`),d.debug(`Enhanced with common tags: "${i}"`));const o=performance.now();try{const e=t.SlashCommandParser?.commands?.sd;if(!e||!e.callback)return d.error("SD command not available"),d.info("Available commands:",Object.keys(t.SlashCommandParser?.commands||{})),null;d.info("Calling SD command...");const n=await e.callback({quiet:"true"},i),r=performance.now()-o;return d.info(`Generated image URL: ${n} (took ${r.toFixed(0)}ms)`),n}catch(e){const t=performance.now()-o;return d.error(`Error generating image (after ${t.toFixed(0)}ms):`,e),null}}))}function v(e){return e&&""!==e.trim()?e.split(",").map((e=>e.trim())).filter((e=>e.length>0)):[]}async function y(e,t,n,r,i,o){const u=(0,s.g)(e,n);if(d.info("Found",u.length,"image prompts to process"),0===u.length)return e;if(d.info("Extracted prompts:",u.map((e=>e.prompt))),void 0!==o)for(let e=0;e<u.length;e++){const n=u[e],r=(0,l.yj)(n.prompt,t),i={messageId:o,promptIndex:e};(0,l.K5)(i,r,t),d.debug(`Initialized metadata for prompt at position ${o}_${e}`)}const p=u.length;toastr.info((0,a.m)(p,"toast.generatingImages"),(0,a.t)("extensionName")),void 0!==o&&(0,c.uP)(o,p);const m=performance.now(),g=[];for(let e=0;e<u.length;e++){const n=u[e],s=await f(n.prompt,t,r,i);g.push(s),void 0!==o&&(0,c.B$)(o,e+1,p)}const h=performance.now()-m,v=g.filter((e=>e)).length;d.info(`Generated ${v} images successfully (total time: ${h.toFixed(0)}ms, avg: ${(h/p).toFixed(0)}ms per image)`),v===p?toastr.success((0,a.m)(v,"toast.successGenerated"),(0,a.t)("extensionName")):v>0?toastr.warning((0,a.t)("toast.partialGenerated",{success:v,total:p}),(0,a.t)("extensionName")):toastr.error((0,a.t)("toast.failedToGenerate"),(0,a.t)("extensionName"));let y=e;for(let e=u.length-1;e>=0;e--){const n=u[e],r=g[e];if(r){const i=_(y,n.fullMatch,r,e);if(i.success&&(y=i.text,d.info("Added image after prompt at index",e),void 0!==o)){const n={messageId:o,promptIndex:e},i=(0,l.PW)(n,t);i?((0,l.pr)(r,i,t),d.debug(`Recorded image-prompt association: ${r} -> ${i}`)):d.warn(`No promptId found for position ${o}_${e}`)}}else d.info("Image generation failed for prompt at index",e,"- keeping tag")}return void 0!==o&&(0,c.UK)(o),y}async function b(e,t,n){return 0===e.length?0:(0,u.Tj)(t,(async()=>{d.info(`Batch inserting ${e.length} deferred images into message ${t}`);const r=n.chat?.[t];if(!r)return d.warn("Message not found for batch insertion:",t),0;let i=r.mes||"";const o=i.length,a=[...e].sort(((e,t)=>e.prompt.startIndex-t.prompt.startIndex));let u=0;for(let e=a.length-1;e>=0;e--){const{prompt:r,imageUrl:o}=a[e],c=_(i,r.fullMatch,o,e);if(c.success){i=c.text,u++;const e=(0,s.g)(i).findIndex((e=>e.startIndex===r.startIndex&&e.endIndex===r.endIndex&&e.prompt===r.prompt));if(e>=0){const r={messageId:t,promptIndex:e},i=(0,l.PW)(r,n);i?((0,l.pr)(o,i,n),d.debug(`Recorded image-prompt association: ${o} -> ${i}`)):d.warn(`No promptId found for position ${t}_${e}`)}else d.warn("Could not find prompt index after insertion")}}r.mes=i,d.info(`Batch insertion complete: ${u}/${e.length} images inserted (${o} -> ${i.length} chars)`);const p=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(p,t),n.updateMessageBlock(t,r);const m=n.eventTypes.MESSAGE_UPDATED;return await n.eventSource.emit(m,t),await n.saveChat(),d.debug("Chat saved after inserting deferred images"),(0,c.UK)(t),u}),"batch deferred image insertion")}},122:(e,t,n)=>{"use strict";n.d(t,{He:()=>a,h:()=>c});var r=n(65),i=n.n(r);const s="[Auto Illustrator]",o=i().getLogger("auto-illustrator");function a(e){o.setLevel(e)}function l(e,t){return e?`${s} [${e}] ${t}`:`${s} ${t}`}function c(e){return{trace:(t,...n)=>o.trace(l(e,t),...n),debug:(t,...n)=>o.debug(l(e,t),...n),info:(t,...n)=>o.info(l(e,t),...n),warn:(t,...n)=>o.warn(l(e,t),...n),error:(t,...n)=>o.error(l(e,t),...n)}}o.setLevel(i().levels.INFO)},697:(e,t,n)=>{"use strict";n.d(t,{B$:()=>c,Lk:()=>l,UK:()=>u,uP:()=>d});var r=n(293);const i=(0,n(122).h)("ProgressWidget"),s=new Map;function o(){const e=document.getElementById("ai-img-progress-global");if(!e)return void i.warn("Global widget not found during update");if(i.info(`Updating global widget display: ${s.size} message(s), display will be: ${0===s.size?"none":"flex"}`),e.innerHTML="",0===s.size)return e.style.display="none",void i.debug("No active messages, hiding widget");e.style.display="flex";const t=document.createElement("div");t.className="ai-img-progress-spinner",e.appendChild(t);const n=document.createElement("div");n.className="ai-img-progress-text-container";for(const[e,t]of s.entries()){const i=document.createElement("div");i.className="ai-img-progress-text",i.textContent=(0,r.t)("toast.generatingImagesProgressWithMessage",{messageId:String(e),current:String(t.current),total:String(t.total)}),n.appendChild(i)}e.appendChild(n);const o=window.getComputedStyle(e),a=e.getBoundingClientRect();i.info(`Widget rendered - display: ${o.display}, visibility: ${o.visibility}, position: ${o.position}, zIndex: ${o.zIndex}, bottom: ${o.bottom}`),i.info(`Widget position - top: ${a.top}px, left: ${a.left}px, bottom: ${a.bottom}px, right: ${a.right}px, width: ${a.width}px, height: ${a.height}px`),i.info(`Widget content: ${e.children.length} children, innerHTML length: ${e.innerHTML.length}`),i.debug(`Updated global widget: ${s.size} message(s) in progress`)}function a(e,t,n){!function(){const e=document.getElementById("ai-img-progress-global");if(e)return e;const t=document.createElement("div");t.id="ai-img-progress-global",t.className="ai-img-progress-widget-global",t.style.display="none";const n=document.getElementById("sheld"),r=document.getElementById("form_sheld");n&&r?(n.insertBefore(t,r),i.info("Created global progress widget and inserted into #sheld before #form_sheld")):(i.error("Could not find #sheld or #form_sheld, falling back to body append"),document.body.appendChild(t),i.warn("Widget appended to body as fallback (may have positioning issues)"))}(),s.set(e,{current:t,total:n,startTime:s.get(e)?.startTime||Date.now()}),o(),i.info(`Added/updated progress for message ${e}: ${t}/${n}`)}function l(e,t){return a(e,0,t),!0}function c(e,t,n){!function(e,t,n){const r=s.get(e);r?(s.set(e,{current:t,total:n,startTime:r.startTime}),o(),i.debug(`Updated progress for message ${e}: ${t}/${n}`)):i.warn(`Cannot update progress for message ${e}: not being tracked`)}(e,t,n)}function u(e){!function(e){s.delete(e)&&(o(),i.info(`Removed progress for message ${e}`))}(e)}function d(e,t,n,r){l(e,t)}},591:(e,t,n)=>{"use strict";n.d(t,{K5:()=>l,PW:()=>u,WJ:()=>d,pr:()=>a,s8:()=>c,yj:()=>o});const r=(0,n(122).h)("PromptMetadata");function i(e){return`${e.messageId}_${e.promptIndex}`}function s(e){return e.chat_metadata||(e.chat_metadata={}),e.chat_metadata.auto_illustrator||(e.chat_metadata.auto_illustrator={imageUrlToPromptId:{},promptIdToText:{},promptPositionHistory:{}}),e.chat_metadata.auto_illustrator}function o(e,t){const n=s(t),i=function(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t|=0;return`prompt_${Math.abs(t).toString(36)}_${Date.now().toString(36)}`}(e);return n.promptIdToText[i]||(n.promptIdToText[i]=e,r.debug(`Recorded new prompt: ${i}`)),i}function a(e,t,n){s(n).imageUrlToPromptId[e]=t,r.debug(`Linked image to prompt: ${t}`)}function l(e,t,n){const o=s(n),a=i(e);o.promptPositionHistory[a]||(o.promptPositionHistory[a]={versions:[{promptId:t,feedback:"",timestamp:Date.now()}]},r.debug(`Initialized position history: ${a}`))}async function c(e,t,n,o){const a=s(o),l=i(e),c=a.promptPositionHistory[l];if(!c)throw new Error(`No history found for position: ${l}`);c.versions.push({promptId:t,feedback:n,timestamp:Date.now()}),r.info(`Added prompt version to ${l}: ${t} (${c.versions.length} versions)`);const u=a.promptIdToText[t];if(!u)throw new Error(`Prompt text not found for ID: ${t}`);const d=o.chat[e.messageId];if(!d)throw new Error(`Message not found: ${e.messageId}`);d.mes=function(e,t,n){let r=0;return e.replace(/<!--img-prompt="([^"]*)"-->/g,(e=>{const i=r;return r++,i===t?`\x3c!--img-prompt="${n}"--\x3e`:e}))}(d.mes,e.promptIndex,u),await o.saveChat()}function u(e,t){const n=s(t),r=i(e),o=n.promptPositionHistory[r];return o&&0!==o.versions.length?o.versions[o.versions.length-1].promptId:null}function d(e,t){return s(t).promptIdToText[e]||null}},974:(e,t,n)=>{"use strict";n.d(t,{B7:()=>o,Ov:()=>s,RJ:()=>i,lJ:()=>a});const r=/<img-prompt="([^"\\]*(?:\\.[^"\\]*)*)"\s*>/g;function i(){return new RegExp(r.source,r.flags)}function s(e){return e.replace(/\\"/g,'"')}function o(e){const t=e.map((e=>`(?:${e})`)).join("|");return new RegExp(t,"g")}function a(e,t){const n=o(t),r=[];let i;for(;null!==(i=n.exec(e));){const e=i.slice(1).find((e=>void 0!==e));e&&e.trim().length>0&&r.push({prompt:s(e.trim()),fullMatch:i[0],startIndex:i.index,endIndex:i.index+i[0].length})}return r}},495:e=>{"use strict";e.exports=JSON.parse("{\"blacklist_client.lua\":\"local blacklist = ARGV[num_static_argv + 1]\\n\\nif redis.call('zscore', client_last_seen_key, blacklist) then\\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\\nend\\n\\n\\nreturn {}\\n\",\"check.lua\":\"local weight = tonumber(ARGV[num_static_argv + 1])\\n\\nlocal capacity = process_tick(now, false)['capacity']\\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\\n\\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\\n\",\"conditions_check.lua\":\"local conditions_check = function (capacity, weight)\\n  return capacity == nil or weight <= capacity\\nend\\n\",\"current_reservoir.lua\":\"return process_tick(now, false)['reservoir']\\n\",\"done.lua\":\"process_tick(now, false)\\n\\nreturn tonumber(redis.call('hget', settings_key, 'done'))\\n\",\"free.lua\":\"local index = ARGV[num_static_argv + 1]\\n\\nredis.call('zadd', job_expirations_key, 0, index)\\n\\nreturn process_tick(now, false)['running']\\n\",\"get_time.lua\":\"redis.replicate_commands()\\n\\nlocal get_time = function ()\\n  local time = redis.call('time')\\n\\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\\nend\\n\",\"group_check.lua\":\"return not (redis.call('exists', settings_key) == 1)\\n\",\"heartbeat.lua\":\"process_tick(now, true)\\n\",\"increment_reservoir.lua\":\"local incr = tonumber(ARGV[num_static_argv + 1])\\n\\nredis.call('hincrby', settings_key, 'reservoir', incr)\\n\\nlocal reservoir = process_tick(now, true)['reservoir']\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn reservoir\\n\",\"init.lua\":\"local clear = tonumber(ARGV[num_static_argv + 1])\\nlocal limiter_version = ARGV[num_static_argv + 2]\\nlocal num_local_argv = num_static_argv + 2\\n\\nif clear == 1 then\\n  redis.call('del', unpack(KEYS))\\nend\\n\\nif redis.call('exists', settings_key) == 0 then\\n  -- Create\\n  local args = {'hmset', settings_key}\\n\\n  for i = num_local_argv + 1, #ARGV do\\n    table.insert(args, ARGV[i])\\n  end\\n\\n  redis.call(unpack(args))\\n  redis.call('hmset', settings_key,\\n    'nextRequest', now,\\n    'lastReservoirRefresh', now,\\n    'lastReservoirIncrease', now,\\n    'running', 0,\\n    'done', 0,\\n    'unblockTime', 0,\\n    'capacityPriorityCounter', 0\\n  )\\n\\nelse\\n  -- Apply migrations\\n  local settings = redis.call('hmget', settings_key,\\n    'id',\\n    'version'\\n  )\\n  local id = settings[1]\\n  local current_version = settings[2]\\n\\n  if current_version ~= limiter_version then\\n    local version_digits = {}\\n    for k, v in string.gmatch(current_version, \\\"([^.]+)\\\") do\\n      table.insert(version_digits, tonumber(k))\\n    end\\n\\n    -- 2.10.0\\n    if version_digits[2] < 10 then\\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\\n      redis.call('hsetnx', settings_key, 'done', 0)\\n      redis.call('hset', settings_key, 'version', '2.10.0')\\n    end\\n\\n    -- 2.11.1\\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\\n        redis.call('hmset', settings_key,\\n          'lastReservoirRefresh', now,\\n          'version', '2.11.1'\\n        )\\n      end\\n    end\\n\\n    -- 2.14.0\\n    if version_digits[2] < 14 then\\n      local old_running_key = 'b_'..id..'_running'\\n      local old_executing_key = 'b_'..id..'_executing'\\n\\n      if redis.call('exists', old_running_key) == 1 then\\n        redis.call('rename', old_running_key, job_weights_key)\\n      end\\n      if redis.call('exists', old_executing_key) == 1 then\\n        redis.call('rename', old_executing_key, job_expirations_key)\\n      end\\n      redis.call('hset', settings_key, 'version', '2.14.0')\\n    end\\n\\n    -- 2.15.2\\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\\n      redis.call('hset', settings_key, 'version', '2.15.2')\\n    end\\n\\n    -- 2.17.0\\n    if version_digits[2] < 17 then\\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\\n      redis.call('hset', settings_key, 'version', '2.17.0')\\n    end\\n\\n    -- 2.18.0\\n    if version_digits[2] < 18 then\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\\n      redis.call('hset', settings_key, 'version', '2.18.0')\\n    end\\n\\n  end\\n\\n  process_tick(now, false)\\nend\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn {}\\n\",\"process_tick.lua\":\"local process_tick = function (now, always_publish)\\n\\n  local compute_capacity = function (maxConcurrent, running, reservoir)\\n    if maxConcurrent ~= nil and reservoir ~= nil then\\n      return math.min((maxConcurrent - running), reservoir)\\n    elseif maxConcurrent ~= nil then\\n      return maxConcurrent - running\\n    elseif reservoir ~= nil then\\n      return reservoir\\n    else\\n      return nil\\n    end\\n  end\\n\\n  local settings = redis.call('hmget', settings_key,\\n    'id',\\n    'maxConcurrent',\\n    'running',\\n    'reservoir',\\n    'reservoirRefreshInterval',\\n    'reservoirRefreshAmount',\\n    'lastReservoirRefresh',\\n    'reservoirIncreaseInterval',\\n    'reservoirIncreaseAmount',\\n    'reservoirIncreaseMaximum',\\n    'lastReservoirIncrease',\\n    'capacityPriorityCounter',\\n    'clientTimeout'\\n  )\\n  local id = settings[1]\\n  local maxConcurrent = tonumber(settings[2])\\n  local running = tonumber(settings[3])\\n  local reservoir = tonumber(settings[4])\\n  local reservoirRefreshInterval = tonumber(settings[5])\\n  local reservoirRefreshAmount = tonumber(settings[6])\\n  local lastReservoirRefresh = tonumber(settings[7])\\n  local reservoirIncreaseInterval = tonumber(settings[8])\\n  local reservoirIncreaseAmount = tonumber(settings[9])\\n  local reservoirIncreaseMaximum = tonumber(settings[10])\\n  local lastReservoirIncrease = tonumber(settings[11])\\n  local capacityPriorityCounter = tonumber(settings[12])\\n  local clientTimeout = tonumber(settings[13])\\n\\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\\n\\n  --\\n  -- Process 'running' changes\\n  --\\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\\n\\n  if #expired > 0 then\\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\\n\\n    local flush_batch = function (batch, acc)\\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\\n                      redis.call('hdel',  job_weights_key, unpack(batch))\\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\\n                      redis.call('hdel',  job_clients_key, unpack(batch))\\n\\n      -- Calculate sum of removed weights\\n      for i = 1, #weights do\\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\\n      end\\n\\n      -- Calculate sum of removed weights by client\\n      local client_weights = {}\\n      for i = 1, #clients do\\n        local removed = tonumber(weights[i]) or 0\\n        if removed > 0 then\\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\\n        end\\n      end\\n    end\\n\\n    local acc = {\\n      ['total'] = 0,\\n      ['client_weights'] = {}\\n    }\\n    local batch_size = 1000\\n\\n    -- Compute changes to Zsets and apply changes to Hashes\\n    for i = 1, #expired, batch_size do\\n      local batch = {}\\n      for j = i, math.min(i + batch_size - 1, #expired) do\\n        table.insert(batch, expired[j])\\n      end\\n\\n      flush_batch(batch, acc)\\n    end\\n\\n    -- Apply changes to Zsets\\n    if acc['total'] > 0 then\\n      redis.call('hincrby', settings_key, 'done', acc['total'])\\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\\n    end\\n\\n    for client, weight in pairs(acc['client_weights']) do\\n      redis.call('zincrby', client_running_key, -weight, client)\\n    end\\n  end\\n\\n  --\\n  -- Process 'reservoir' changes\\n  --\\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\\n    reservoir = reservoirRefreshAmount\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'lastReservoirRefresh', now\\n    )\\n  end\\n\\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\\n    local incr = reservoirIncreaseAmount * num_intervals\\n    if reservoirIncreaseMaximum ~= nil then\\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\\n    end\\n    if incr > 0 then\\n      reservoir = (reservoir or 0) + incr\\n    end\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\\n    )\\n  end\\n\\n  --\\n  -- Clear unresponsive clients\\n  --\\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\\n  local unresponsive_lookup = {}\\n  local terminated_clients = {}\\n  for i = 1, #unresponsive do\\n    unresponsive_lookup[unresponsive[i]] = true\\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\\n      table.insert(terminated_clients, unresponsive[i])\\n    end\\n  end\\n  if #terminated_clients > 0 then\\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\\n  end\\n\\n  --\\n  -- Broadcast capacity changes\\n  --\\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\\n\\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\\n    -- always_publish or was not unlimited, now unlimited\\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\\n\\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\\n    -- capacity was increased\\n    -- send the capacity message to the limiter having the lowest number of running jobs\\n    -- the tiebreaker is the limiter having not registered a job in the longest time\\n\\n    local lowest_concurrency_value = nil\\n    local lowest_concurrency_clients = {}\\n    local lowest_concurrency_last_registered = {}\\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\\n\\n    for i = 1, #client_concurrencies, 2 do\\n      local client = client_concurrencies[i]\\n      local concurrency = tonumber(client_concurrencies[i+1])\\n\\n      if (\\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\\n      ) and (\\n        not unresponsive_lookup[client]\\n      ) and (\\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\\n      ) then\\n        lowest_concurrency_value = concurrency\\n        table.insert(lowest_concurrency_clients, client)\\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\\n        table.insert(lowest_concurrency_last_registered, last_registered)\\n      end\\n    end\\n\\n    if #lowest_concurrency_clients > 0 then\\n      local position = 1\\n      local earliest = lowest_concurrency_last_registered[1]\\n\\n      for i,v in ipairs(lowest_concurrency_last_registered) do\\n        if v < earliest then\\n          position = i\\n          earliest = v\\n        end\\n      end\\n\\n      local next_client = lowest_concurrency_clients[position]\\n      redis.call('publish', 'b_'..id,\\n        'capacity-priority:'..(final_capacity or '')..\\n        ':'..next_client..\\n        ':'..capacityPriorityCounter\\n      )\\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\\n    else\\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\\n    end\\n  end\\n\\n  return {\\n    ['capacity'] = final_capacity,\\n    ['running'] = running,\\n    ['reservoir'] = reservoir\\n  }\\nend\\n\",\"queued.lua\":\"local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\\n\\nlocal sum = 0\\nfor i = 1, #client_queued do\\n  sum = sum + tonumber(client_queued[i])\\nend\\n\\nreturn sum\\n\",\"refresh_expiration.lua\":\"local refresh_expiration = function (now, nextRequest, groupTimeout)\\n\\n  if groupTimeout ~= nil then\\n    local ttl = (nextRequest + groupTimeout) - now\\n\\n    for i = 1, #KEYS do\\n      redis.call('pexpire', KEYS[i], ttl)\\n    end\\n  end\\n\\nend\\n\",\"refs.lua\":\"local settings_key = KEYS[1]\\nlocal job_weights_key = KEYS[2]\\nlocal job_expirations_key = KEYS[3]\\nlocal job_clients_key = KEYS[4]\\nlocal client_running_key = KEYS[5]\\nlocal client_num_queued_key = KEYS[6]\\nlocal client_last_registered_key = KEYS[7]\\nlocal client_last_seen_key = KEYS[8]\\n\\nlocal now = tonumber(ARGV[1])\\nlocal client = ARGV[2]\\n\\nlocal num_static_argv = 2\\n\",\"register.lua\":\"local index = ARGV[num_static_argv + 1]\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\\n\\nlocal state = process_tick(now, false)\\nlocal capacity = state['capacity']\\nlocal reservoir = state['reservoir']\\n\\nlocal settings = redis.call('hmget', settings_key,\\n  'nextRequest',\\n  'minTime',\\n  'groupTimeout'\\n)\\nlocal nextRequest = tonumber(settings[1])\\nlocal minTime = tonumber(settings[2])\\nlocal groupTimeout = tonumber(settings[3])\\n\\nif conditions_check(capacity, weight) then\\n\\n  redis.call('hincrby', settings_key, 'running', weight)\\n  redis.call('hset', job_weights_key, index, weight)\\n  if expiration ~= nil then\\n    redis.call('zadd', job_expirations_key, now + expiration, index)\\n  end\\n  redis.call('hset', job_clients_key, index, client)\\n  redis.call('zincrby', client_running_key, weight, client)\\n  redis.call('hincrby', client_num_queued_key, client, -1)\\n  redis.call('zadd', client_last_registered_key, now, client)\\n\\n  local wait = math.max(nextRequest - now, 0)\\n  local newNextRequest = now + wait + minTime\\n\\n  if reservoir == nil then\\n    redis.call('hset', settings_key,\\n      'nextRequest', newNextRequest\\n    )\\n  else\\n    reservoir = reservoir - weight\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'nextRequest', newNextRequest\\n    )\\n  end\\n\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\n\\n  return {true, wait, reservoir}\\n\\nelse\\n  return {false}\\nend\\n\",\"register_client.lua\":\"local queued = tonumber(ARGV[num_static_argv + 1])\\n\\n-- Could have been re-registered concurrently\\nif not redis.call('zscore', client_last_seen_key, client) then\\n  redis.call('zadd', client_running_key, 0, client)\\n  redis.call('hset', client_num_queued_key, client, queued)\\n  redis.call('zadd', client_last_registered_key, 0, client)\\nend\\n\\nredis.call('zadd', client_last_seen_key, now, client)\\n\\nreturn {}\\n\",\"running.lua\":\"return process_tick(now, false)['running']\\n\",\"submit.lua\":\"local queueLength = tonumber(ARGV[num_static_argv + 1])\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\n\\nlocal capacity = process_tick(now, false)['capacity']\\n\\nlocal settings = redis.call('hmget', settings_key,\\n  'id',\\n  'maxConcurrent',\\n  'highWater',\\n  'nextRequest',\\n  'strategy',\\n  'unblockTime',\\n  'penalty',\\n  'minTime',\\n  'groupTimeout'\\n)\\nlocal id = settings[1]\\nlocal maxConcurrent = tonumber(settings[2])\\nlocal highWater = tonumber(settings[3])\\nlocal nextRequest = tonumber(settings[4])\\nlocal strategy = tonumber(settings[5])\\nlocal unblockTime = tonumber(settings[6])\\nlocal penalty = tonumber(settings[7])\\nlocal minTime = tonumber(settings[8])\\nlocal groupTimeout = tonumber(settings[9])\\n\\nif maxConcurrent ~= nil and weight > maxConcurrent then\\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\\nend\\n\\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\\n  and not (\\n    conditions_check(capacity, weight)\\n    and nextRequest - now <= 0\\n  )\\n)\\n\\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\\n\\nif blocked then\\n  local computedPenalty = penalty\\n  if computedPenalty == nil then\\n    if minTime == 0 then\\n      computedPenalty = 5000\\n    else\\n      computedPenalty = 15 * minTime\\n    end\\n  end\\n\\n  local newNextRequest = now + computedPenalty + minTime\\n\\n  redis.call('hmset', settings_key,\\n    'unblockTime', now + computedPenalty,\\n    'nextRequest', newNextRequest\\n  )\\n\\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\\n  local queued_reset = {}\\n  for i = 1, #clients_queued_reset do\\n    table.insert(queued_reset, clients_queued_reset[i])\\n    table.insert(queued_reset, 0)\\n  end\\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\\n\\n  redis.call('publish', 'b_'..id, 'blocked:')\\n\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\nend\\n\\nif not blocked and not reachedHWM then\\n  redis.call('hincrby', client_num_queued_key, client, 1)\\nend\\n\\nreturn {reachedHWM, blocked, strategy}\\n\",\"update_settings.lua\":\"local args = {'hmset', settings_key}\\n\\nfor i = num_static_argv + 1, #ARGV do\\n  table.insert(args, ARGV[i])\\nend\\n\\nredis.call(unpack(args))\\n\\nprocess_tick(now, true)\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn {}\\n\",\"validate_client.lua\":\"if not redis.call('zscore', client_last_seen_key, client) then\\n  return redis.error_reply('UNKNOWN_CLIENT')\\nend\\n\\nredis.call('zadd', client_last_seen_key, now, client)\\n\",\"validate_keys.lua\":\"if not (redis.call('exists', settings_key) == 1) then\\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\\nend\\n\"}")},349:e=>{"use strict";e.exports={r:"2.19.5"}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.nc=void 0;var __webpack_exports__={};(()=>{"use strict";__webpack_require__.d(__webpack_exports__,{QF:()=>Ie,C$:()=>pe,zH:()=>ue});var e=__webpack_require__(72),t=__webpack_require__.n(e),n=__webpack_require__(825),r=__webpack_require__.n(n),i=__webpack_require__(659),s=__webpack_require__.n(i),o=__webpack_require__(56),a=__webpack_require__.n(o),l=__webpack_require__(540),c=__webpack_require__.n(l),u=__webpack_require__(113),d=__webpack_require__.n(u),p=__webpack_require__(208),m={};m.styleTagTransform=d(),m.setAttributes=a(),m.insert=s().bind(null,"head"),m.domAPI=r(),m.insertStyleElement=c();t()(p.A,m);p.A&&p.A.locals&&p.A.locals;var g=__webpack_require__(75),h=__webpack_require__(722),_=__webpack_require__(122);const f=(0,_.h)("MessageHandler");function v(e,t){return async n=>{if(f.info("MESSAGE_RECEIVED event, messageId:",n),pe(n))return f.info("Message being streamed, signaling MESSAGE_RECEIVED"),void Ie();f.info("No streaming active, processing immediately");const r=e.chat?.[n];if(!r)return void f.info("No message found at index:",n);if(f.info("Message details:",{is_user:r.is_user,is_system:r.is_system,name:r.name,mes_length:r.mes?.length}),r.is_user)return void f.info("Skipping user message");if(f.info("Message text preview:",r.mes.substring(0,200)),!(0,g.R)(r.mes,t.promptDetectionPatterns))return void f.info("No image prompts found in message");f.info("Image prompts detected, processing..."),await async function(e,t,n,r,i,s){if((0,g.R)(e,r)){f.info("Processing message for images:",t);try{const o=await(0,h.ML)(e,n,r,i,s,t);n.chat&&n.chat[t]&&(n.chat[t].mes=o)}catch(e){f.error("Error processing message:",e)}}}(r.mes,n,e,t.promptDetectionPatterns,t.commonStyleTags,t.commonStyleTagsPosition),f.info("Emitting MESSAGE_EDITED event");const i=e.eventTypes.MESSAGE_EDITED;await e.eventSource.emit(i,n),e.updateMessageBlock(n,r);const s=e.eventTypes.MESSAGE_UPDATED;await e.eventSource.emit(s,n),await e.saveChat(),f.debug("Chat saved after processing message images")}}var y=__webpack_require__(28);const b=(0,_.h)("Pruner");const E=(0,_.h)("Queue");function w(e,t){const n=`${e}:${t}`;let r=0;for(let e=0;e<n.length;e++){r=(r<<5)-r+n.charCodeAt(e),r|=0}return`prompt_${Math.abs(r).toString(36)}`}class x{constructor(){this.prompts=new Map}addPrompt(e,t,n,r){const i=w(e,n);if(this.prompts.has(i))return E.info("Prompt already queued:",i),null;const s={id:i,prompt:e,fullMatch:t,startIndex:n,endIndex:r,state:"QUEUED",attempts:0,detectedAt:Date.now()};return this.prompts.set(i,s),E.info("Added prompt:",i,e),s}hasPrompt(e,t){const n=w(e,t);return this.prompts.has(n)}hasPromptByText(e){for(const t of this.prompts.values())if(t.prompt===e)return!0;return!1}getNextPending(){for(const e of this.prompts.values())if("QUEUED"===e.state)return e;return null}updateState(e,t,n){const r=this.prompts.get(e);r?(r.state=t,"GENERATING"===t&&(r.generationStartedAt=Date.now(),r.attempts++),"COMPLETED"!==t&&"FAILED"!==t||(r.completedAt=Date.now()),n?.imageUrl&&(r.imageUrl=n.imageUrl),n?.error&&(r.error=n.error),E.info("Updated state:",e,t)):E.warn("Prompt not found:",e)}getPrompt(e){return this.prompts.get(e)}getAllPrompts(){return Array.from(this.prompts.values())}getPromptsByState(e){return this.getAllPrompts().filter((t=>t.state===e))}getStats(){const e={DETECTED:0,QUEUED:0,GENERATING:0,COMPLETED:0,FAILED:0};for(const t of this.prompts.values())e[t.state]++;return e}clear(){E.info("Clearing queue"),this.prompts.clear()}size(){return this.prompts.size}adjustPositionsAfterInsertion(e,t,n=Date.now()){for(const r of this.prompts.values())r.detectedAt<n&&r.startIndex>e&&("QUEUED"===r.state||"GENERATING"===r.state)&&(r.startIndex+=t,r.endIndex+=t)}}var k=__webpack_require__(591);const T=(0,_.h)("Monitor");class I{constructor(e,t,n,r=300,i){this.messageId=-1,this.lastSeenText="",this.pollInterval=null,this.isRunning=!1,this.queue=e,this.context=t,this.settings=n,this.intervalMs=r,this.onNewPromptsCallback=i}start(e){this.isRunning&&(T.warn("Already running, stopping previous monitor"),this.stop()),this.messageId=e,this.lastSeenText="",this.isRunning=!0,T.info(`Starting monitor for message ${e} (interval: ${this.intervalMs}ms)`),this.pollInterval=setInterval((()=>{this.checkForNewPrompts()}),this.intervalMs),this.checkForNewPrompts()}stop(){this.isRunning&&(T.info("Stopping monitor"),this.isRunning=!1,this.pollInterval&&(clearInterval(this.pollInterval),this.pollInterval=null),this.messageId=-1,this.lastSeenText="")}finalScan(){T.info("Performing final scan for remaining prompts"),this.checkForNewPrompts()}checkForNewPrompts(){if(!this.isRunning||this.messageId<0)return;const e=this.context.chat?.[this.messageId];if(!e)return void T.warn("Message not found:",this.messageId);const t=e.mes||"";if(t===this.lastSeenText)return;T.trace(`Text changed (${this.lastSeenText.length} -> ${t.length} chars)`);const n=this.extractNewPrompts(t);if(n.length>0){T.info(`Found ${n.length} new prompts`);const e=(0,g.g)(t,this.settings.promptDetectionPatterns);for(const t of n){const n=e.findIndex((e=>e.startIndex===t.startIndex&&e.endIndex===t.endIndex&&e.prompt===t.prompt));if(n>=0){const e=(0,k.yj)(t.prompt,this.context),r={messageId:this.messageId,promptIndex:n};(0,k.K5)(r,e,this.context),T.debug(`Initialized metadata for prompt at position ${this.messageId}_${n}`)}this.queue.addPrompt(t.prompt,t.fullMatch,t.startIndex,t.endIndex)}this.onNewPromptsCallback&&this.onNewPromptsCallback()}this.lastSeenText=t}extractNewPrompts(e){const t=(0,g.g)(e,this.settings.promptDetectionPatterns),n=[];for(const e of t)this.queue.hasPromptByText(e.prompt)||n.push(e);return n}getStatus(){return{isRunning:this.isRunning,messageId:this.messageId,lastTextLength:this.lastSeenText.length,intervalMs:this.intervalMs}}isActive(){return this.isRunning}}var P=__webpack_require__(697);const S=(0,_.h)("Processor");class R{constructor(e,t,n,r=1){this.messageId=-1,this.isRunning=!1,this.isProcessing=!1,this.activeGenerations=0,this.processPromise=null,this.deferredImages=[],this.queue=e,this.context=t,this.settings=n,this.maxConcurrent=r}start(e){this.isRunning&&(S.warn("Already running, stopping previous processor"),this.stop()),this.messageId=e,this.isRunning=!0,this.activeGenerations=0,this.deferredImages=[],S.info(`Starting processor for message ${e} (max concurrent: ${this.maxConcurrent})`),(0,P.Lk)(e,0),this.processNext()}stop(){this.isRunning&&(S.info("Stopping processor"),this.isRunning=!1,this.messageId=-1)}async processNext(){if(!(!this.isRunning||this.activeGenerations>=this.maxConcurrent||this.isProcessing)){this.isProcessing=!0;try{const e=this.queue.getNextPending();if(!e)return this.isProcessing=!1,void S.info("No pending prompts, waiting...");S.info(`Processing prompt: ${e.id}`);const t=this.queue.size();t>0&&(0,P.uP)(this.messageId,t),this.queue.updateState(e.id,"GENERATING"),this.activeGenerations++,this.generateImageForPrompt(e).then((()=>{this.activeGenerations--,this.processNext()})).catch((e=>{S.error("Unexpected error:",e),this.activeGenerations--,this.processNext()})),this.activeGenerations<this.maxConcurrent?(this.isProcessing=!1,setImmediate((()=>this.processNext()))):this.isProcessing=!1}catch(e){S.error("Error in processNext:",e),this.isProcessing=!1}}}async generateImageForPrompt(e){try{S.info(`Generating image for: ${e.prompt}`);const t=await(0,h.Fz)(e.prompt,this.context,this.settings.commonStyleTags,this.settings.commonStyleTagsPosition);if(t){this.queue.updateState(e.id,"COMPLETED",{imageUrl:t}),S.info(`Generated image: ${t}`),this.deferredImages.push({prompt:e,imageUrl:t}),S.info(`Deferred image insertion (${this.deferredImages.length} total)`);const n=this.queue.getStats(),r=n.COMPLETED+n.FAILED;(0,P.B$)(this.messageId,r,this.queue.size())}else{this.queue.updateState(e.id,"FAILED",{error:"Image generation returned null"}),S.warn(`Failed to generate image for: ${e.prompt}`);const t=this.queue.getStats(),n=t.COMPLETED+t.FAILED;(0,P.B$)(this.messageId,n,this.queue.size())}}catch(t){this.queue.updateState(e.id,"FAILED",{error:t instanceof Error?t.message:String(t)}),S.error("Error generating image:",t);const n=this.queue.getStats(),r=n.COMPLETED+n.FAILED;(0,P.B$)(this.messageId,r,this.queue.size())}}async processRemaining(){if(S.info("Processing remaining prompts..."),this.activeGenerations>0){for(S.debug(`Waiting for ${this.activeGenerations} active generations to complete...`);this.activeGenerations>0;)await new Promise((e=>setTimeout(e,100)));S.debug("All active generations completed")}const e=this.queue.getPromptsByState("QUEUED");if(S.info(`${e.length} prompts remaining`),0!==e.length){for(const t of e)await this.generateImageForPrompt(t);S.info("Finished processing remaining prompts")}}trigger(){this.isRunning&&!this.isProcessing&&this.processNext()}getDeferredImages(){return this.deferredImages}clearDeferredImages(){this.deferredImages=[]}getStatus(){return{isRunning:this.isRunning,messageId:this.messageId,activeGenerations:this.activeGenerations,maxConcurrent:this.maxConcurrent,queueStats:this.queue.getStats()}}}const A='# Universal Image Prompt Generation Guide (Tag-Based)\n\nGenerate tag-based image prompts for AI image generation models. Insert prompts approximately every 250 words or at major scene changes.\n\n**Format:** `\x3c!--img-prompt="your description here"--\x3e`\n\n**Tag-based prompts work universally across Stable Diffusion, NovelAI, FLUX, and most diffusion models.**\n\n---\n\n## Tag-Based Format\n\n**Structure:** Comma-separated tags in priority order (earlier tags = stronger influence)\n\n```\n[subject count], [character details], [action/pose], [environment], [lighting], [style], [quality tags]\n```\n\n**Example:**\n```\n1girl, long silver hair, blue eyes, white dress, standing in garden, surrounded by flowers, afternoon sunlight, soft focus, highly detailed, best quality\n```\n\n---\n\n## Core Components\n\n### 1. Subject Count (Required - Always First)\n\n**Single character:**\n- `1girl` / `1boy` / `1other`\n\n**Multiple characters:**\n- `2girls` / `2boys` / `1boy, 1girl`\n- `3girls` / `2girls, 1boy` / `3boys`\n- Up to 6 characters max\n\n**No humans:**\n- `no humans` (for landscapes, objects, animals only)\n\n### 2. Character Details\n\n**Hair:**\n- Length: `long hair`, `short hair`, `medium hair`, `very long hair`\n- Style: `straight hair`, `wavy hair`, `curly hair`, `ponytail`, `braided hair`, `twin tails`\n- Color: `black hair`, `blonde hair`, `brown hair`, `red hair`, `white hair`, `silver hair`, `blue hair`, `pink hair`\n\n**Eyes:**\n- Color: `blue eyes`, `brown eyes`, `green eyes`, `red eyes`, `purple eyes`, `golden eyes`\n- Features: `heterochromia`, `glowing eyes`, `closed eyes`\n\n**Body:**\n- Build: `slender`, `athletic`, `muscular`, `petite`, `curvy`, `tall`, `short`\n- Features: `pale skin`, `dark skin`, `tan skin`, `freckles`\n\n**Clothing:**\n- Casual: `t-shirt`, `jeans`, `hoodie`, `sweater`, `casual dress`, `shorts`\n- Formal: `suit`, `dress shirt`, `tie`, `formal dress`, `evening gown`, `tuxedo`\n- Fantasy: `armor`, `robe`, `cloak`, `leather outfit`, `mage outfit`, `knight armor`\n- Modern: `school uniform`, `business suit`, `sportswear`, `kimono`, `yukata`\n- State: `partially clothed`, `torn clothes`, `wet clothes`\n\n### 3. Expression & Pose\n\n**Expressions:**\n- `smiling`, `grinning`, `laughing`, `serious`, `sad`, `angry`, `surprised`, `shocked`\n- `gentle smile`, `smirk`, `frown`, `crying`, `blushing`, `embarrassed`\n- `eyes closed`, `looking at viewer`, `looking away`, `looking down`, `looking up`\n\n**Body poses:**\n- Standing: `standing`, `contrapposto`, `casual stance`\n- Sitting: `sitting`, `sitting on chair`, `sitting on ground`, `seiza`, `crossed legs`\n- Action: `running`, `walking`, `jumping`, `fighting`, `dancing`, `flying`, `falling`\n- Resting: `lying down`, `lying on back`, `lying on side`, `reclining`, `sleeping`\n- Other: `kneeling`, `crouching`, `leaning`, `stretching`\n\n**Arms & hands:**\n- `arms at sides`, `arms crossed`, `arms raised`, `arms behind back`, `arms up`\n- `hand on hip`, `hands on hips`, `hands together`, `hand on own chest`\n- `waving`, `pointing`, `reaching`, `grabbing`, `holding object`\n\n**Legs:**\n- `legs crossed`, `legs apart`, `one knee up`, `legs together`\n\n### 4. Environment & Setting\n\n**Indoor locations:**\n- `bedroom`, `living room`, `kitchen`, `bathroom`, `office`, `classroom`\n- `library`, `cafe`, `restaurant`, `shop`, `museum`, `hallway`, `corridor`\n\n**Outdoor locations:**\n- `forest`, `beach`, `mountain`, `field`, `meadow`, `garden`, `park`\n- `city`, `street`, `alley`, `rooftop`, `bridge`, `river`, `lake`\n\n**Fantasy/Sci-fi:**\n- `castle`, `dungeon`, `tower`, `ruins`, `temple`, `shrine`\n- `spaceship`, `space station`, `laboratory`, `futuristic city`, `cyberpunk city`\n\n**Background:**\n- `detailed background`, `simple background`, `blurred background`, `bokeh`\n- `white background`, `black background`, `gradient background`, `abstract background`\n\n**Time & weather:**\n- Time: `morning`, `noon`, `afternoon`, `evening`, `sunset`, `night`, `midnight`, `dawn`, `dusk`\n- Weather: `sunny`, `cloudy`, `overcast`, `rainy`, `snowy`, `foggy`, `misty`, `stormy`\n- Season: `spring`, `summer`, `autumn`, `winter`\n\n### 5. Lighting\n\n**Natural lighting:**\n- `sunlight`, `natural light`, `daylight`, `moonlight`, `starlight`\n- `sunrise`, `sunset`, `golden hour`, `blue hour`, `twilight`\n\n**Quality:**\n- `bright lighting`, `dim lighting`, `dramatic lighting`, `soft lighting`, `harsh lighting`\n- `warm lighting`, `cool lighting`, `volumetric lighting`, `god rays`, `light rays`\n\n**Direction:**\n- `front lighting`, `backlighting`, `side lighting`, `rim lighting`, `top lighting`\n\n**Effects:**\n- `lens flare`, `light particles`, `glowing`, `bloom`, `shadows`, `dappled sunlight`\n\n### 6. Composition & Camera\n\n**Shot types:**\n- `portrait`, `close-up`, `upper body`, `cowboy shot`, `full body`, `wide shot`\n\n**Angles:**\n- `from above`, `from below`, `from side`, `from behind`, `eye level`\n- `bird\'s eye view`, `worm\'s eye view`, `dutch angle`\n\n**Focus:**\n- `centered`, `off-center`, `depth of field`, `shallow depth of field`, `bokeh`\n- `sharp focus`, `blurred foreground`, `blurred background`\n\n### 7. Art Style\n\n**Photography:**\n- `photo`, `photograph`, `photorealistic`, `realistic`, `professional photography`\n- `portrait photography`, `landscape photography`, `candid photo`\n- `film grain`, `35mm`, `50mm`, `85mm`\n\n**Art styles:**\n- `anime`, `anime style`, `manga style`, `cel shaded`, `flat colors`\n- `digital art`, `concept art`, `illustration`, `painting`, `drawing`\n- `oil painting`, `watercolor`, `ink`, `pencil drawing`, `sketch`\n\n**Art movements:**\n- `impressionism`, `art nouveau`, `art deco`, `baroque`, `renaissance`\n- `minimalist`, `abstract`, `surreal`, `pop art`\n\n**Rendering:**\n- `3d render`, `unreal engine`, `octane render`, `ray tracing`\n- `low poly`, `voxel art`, `pixel art`\n\n**Effects:**\n- `cinematic`, `dramatic`, `epic`, `atmospheric`, `moody`\n- `vibrant colors`, `muted colors`, `pastel colors`, `monochrome`, `black and white`\n- `high contrast`, `low contrast`, `saturated`, `desaturated`\n\n### 8. Quality Tags (Always Include)\n\n**Essential:**\n- `masterpiece`, `best quality`, `high quality`\n- `highly detailed`, `extremely detailed`, `intricate details`\n- `absurdres`, `highres`, `8k`, `4k`\n\n**Optional enhancement:**\n- `sharp focus`, `professional`, `award-winning`\n- `beautiful`, `aesthetic`, `stunning`\n\n---\n\n## Tag Weight & Emphasis\n\n**Increase weight:**\n- `(tag:1.5)` - Multiply weight by 1.5\n- `(tag:1.2)` - Multiply weight by 1.2\n\n**Decrease weight:**\n- `(tag:0.8)` - Multiply weight by 0.8\n- `(tag:0.5)` - Multiply weight by 0.5\n\n**Example:**\n```\n1girl, (beautiful face:1.2), (detailed eyes:1.3), highly detailed, best quality\n```\n\n---\n\n## Negative Prompts\n\n**Always include negative prompt to prevent common issues:**\n\n**Quality issues:**\n```\nlowres, low quality, worst quality, normal quality, jpeg artifacts, blurry, out of focus, ugly, bad quality, poor quality\n```\n\n**Anatomy issues:**\n```\nbad anatomy, bad proportions, deformed, disfigured, malformed, mutated, extra limbs, missing limbs, extra arms, extra legs, missing arms, missing legs, extra fingers, missing fingers, fused fingers, too many fingers, bad hands, bad feet, long neck, long body\n```\n\n**Artifacts:**\n```\nwatermark, signature, text, username, artist name, logo, error, cropped, out of frame, border\n```\n\n**Unwanted elements:**\n```\nduplicate, multiple views, copy, split screen\n```\n\n**Style-specific negatives:**\n- For realistic photos: `cartoon, anime, drawing, painting, illustration, 3d, render`\n- For illustrations: `photograph, photo, photorealistic, realistic`\n\n---\n\n## Character Consistency\n\n**For known characters (from anime/game/novel):**\n- Use format: `character_name (series_name)`\n- Examples: `hatsune miku (vocaloid)`, `frieren (sousou no frieren)`, `link (zelda)`\n- Check Danbooru tags for exact format\n- Don\'t override canonical features (hair color, eye color) unless making AU\n\n**For original characters:**\n- Keep identical tags across all prompts\n- Document: hair color, eye color, clothing, distinctive features\n- Use exact same descriptors every time\n\n---\n\n## Example Prompts\n\n**Portrait:**\n```\n\x3c!--img-prompt="1girl, long auburn hair, green eyes, freckles, cream sweater, gentle smile, sitting by window, natural lighting, soft focus, portrait, highly detailed, best quality, masterpiece"--\x3e\n```\n\n**Fantasy scene:**\n```\n\x3c!--img-prompt="1girl, long silver hair, blue eyes, white and gold robes, casting spell, magical energy, glowing hands, ancient library, floating books, glowing runes, ethereal lighting, fantasy, highly detailed, best quality, masterpiece"--\x3e\n```\n\n**Anime style:**\n```\n\x3c!--img-prompt="1girl, long pink hair, blue eyes, school uniform, cheerful smile, waving, cherry blossom trees, petals falling, spring day, anime style, vibrant colors, highly detailed, best quality"--\x3e\n```\n\n**Action scene:**\n```\n\x3c!--img-prompt="1girl, long red hair, armor, wielding sword, dynamic pose, mid-air, jumping, battlefield, explosions, smoke, dramatic lighting, action scene, highly detailed, best quality, masterpiece"--\x3e\n```\n\n**Landscape:**\n```\n\x3c!--img-prompt="no humans, mountain lake, sunset, orange and pink sky, crystal clear water, reflections, pine trees, snow-capped peaks, golden hour, misty, scenic vista, landscape photography, highly detailed, 8k, masterpiece"--\x3e\n```\n\n---\n\n## Quick Template\n\n```\n[count], [hair], [eyes], [clothing], [expression], [pose], [location], [time/weather], [lighting], [style], highly detailed, best quality, masterpiece\n```\n\n---\n\n## Best Practices\n\n1. **Subject count first** - Always start with `1girl`, `2boys`, etc.\n2. **Tag order matters** - Earlier tags have stronger influence\n3. **Be specific** - More detail = better results\n4. **Include quality tags** - Always end with quality modifiers\n5. **Use negative prompts** - Prevent common issues\n6. **Stay consistent** - Same character = same exact tags\n7. **Test weights** - Adjust emphasis for problem areas\n8. **Don\'t over-tag** - Focus on important elements (15-40 tags ideal)\n\n---\n\n## Common Mistakes\n\n Missing subject count: `long hair, blue eyes, standing`\n Include subject: `1girl, long hair, blue eyes, standing`\n\n Vague: `girl in room`\n Specific: `1girl, long black hair, bedroom, sitting on bed, morning light`\n\n No quality tags: `1girl, red hair, smiling`\n With quality: `1girl, red hair, smiling, highly detailed, best quality`\n\n Tag overload: `1girl, beautiful, gorgeous, stunning, amazing, incredible, perfect`\n Balanced: `1girl, beautiful, highly detailed, best quality`\n\n---\n\n**Generate prompts frequently (~250 words). Each `\x3c!--img-prompt="..."--\x3e` on its own line, entire prompt on single line.**\n',N="nai-4.5-full";function C(){return A.trim()}const M=[{id:"default",name:"Default",template:C(),predefined:!0},{id:N,name:"NAI 4.5 Full",template:'# NovelAI 4.5 FULL Image Prompt Generation Guide\n\nGenerate image prompts for NovelAI Diffusion 4.5 Full using structured tag-based prompts. Insert prompts at natural narrative points, approximately every 250 words or at major scene changes.\n\n**IMPORTANT: Generate image prompts frequently throughout the story - aim for approximately one prompt every 250 words or at each major scene change.**\n\n**CRITICAL MULTI-CHARACTER RULE: When a scene has 2 or more characters present, you MUST use the pipe `|` separator syntax. This is NOT optional - it is required for proper multi-character generation.**\n\n---\n\n## Core Philosophy: Tags as Foundation, Prose for Nuance\n\nNovelAI is trained on Danbooru\'s tag system. **Tag-based prompts** (comma-separated) provide the most precise and controllable results for most use cases.\n\n**Tags are superior for:**\n- Character consistency and specific attributes\n- Style control and art medium selection\n- Precise visual elements (colors, clothing, objects)\n- Reproducible and predictable results\n\n**Natural language can enhance prompts for:**\n- Complex scenes with specific moods and atmospheres (e.g., "a sense of tension and anticipation")\n- Intricate relationships between characters (e.g., "a knight protecting a child from a dragon")\n- Nuanced descriptions that tags alone might not capture\n- Creative exploration beyond standard conventions\n\n**Best practice: Hybrid approach**\n- Start with natural language for scene/mood/relationships\n- Follow with tags for precision: quality tags, style tags, specific attributes\n- Example: `A majestic tiger stalking through tropical rainforest, dappled sunlight, masterpiece, best quality, cinematic lighting, vibrant colors, detailed fur`\n\n**However, for most prompts in story illustration, tag-based format is recommended for consistency and control.**\n\n---\n\n## Format Requirements\n\n**Format:** `\x3c!--img-prompt="your description here"--\x3e`\n\n**Frequency:** Insert prompts approximately **every 250 words** or at major scene changes. Don\'t skip scenes - each significant moment should have a visual prompt.\n\n**Example:**\n```\nStory text continues.\n\x3c!--img-prompt="1girl, bedroom, sitting, long hair, smiling, very aesthetic, masterpiece, best quality, highres, no text, no watermark"--\x3e\nMore story text.\n```\n\n---\n\n## Prompt Structure\n\nEvery prompt should follow this order for optimal results:\n\n1. **Subject count tags** (MANDATORY): `1girl`, `2boys`, `1boy, 1girl`, `no humans`\n2. **Character specifics**: Character names, series tags if known\n3. **Quality & aesthetic tags** (MANDATORY): `very aesthetic, masterpiece, best quality, highres, no text, no watermark`\n4. **Style tags**: Art medium, artist style, art movement\n5. **Composition**: Shot type, angle, pose\n6. **Environment**: Location, background details\n7. **Lighting**: Light type, effects\n8. **Color scheme**: Dominant colors, color style\n9. **Detailed descriptors**: Clothing, expression, hair, eyes, accessories\n\n**Tag order matters:** Earlier tags have stronger influence. This is a "priority instruction list", not a "bag of words".\n\n---\n\n## Mandatory Quality Tags\n\n**ALWAYS include these in EVERY prompt for high-quality output:**\n\nNovelAI\'s official default quality tags (recommended to use all):\n- `very aesthetic` - Enhanced aesthetic quality\n- `masterpiece` - Most powerful aesthetic tag for V4.5\n- `best quality` - Essential quality baseline\n- `highres` - High resolution output\n- `no text` - Prevents text artifacts in image\n- `no watermark` - Prevents watermark artifacts\n\nAdditional optional quality tag:\n- `absurdres` - Absolute high resolution quality\n\n**Recommended quality tag string:** `very aesthetic, masterpiece, best quality, highres, no text, no watermark`\n\n---\n\n## Subject Count Tags (MANDATORY)\n\n**Always start prompts with:**\n- `no humans` - No people (landscapes, objects)\n- `1girl` / `1boy` / `1other` - Single character\n- `2girls` / `2boys` / `1boy, 1girl` - Two characters\n- `3girls` / `2girls, 1boy` etc. - Three+ characters (max 6)\n\n---\n\n## Style Control Tags\n\n### Art Medium\n- `oil painting (medium)` - Oil painting texture\n- `watercolor (medium)` - Watercolor transparency\n- `ink (medium)` - Ink/pen drawing style\n- `sketch` - Sketch/rough style\n- `anime screencap` - Anime screenshot style\n- `game cg` - Game CG style\n\n### Art Style\n- `art nouveau` - Decorative curves, organic forms\n- `impressionism` - Light/shadow emphasis\n- `ukiyo-e` - Japanese woodblock print\n- `realistic` / `photorealistic` - Photographic realism\n\n### Coloring\n- `monochrome` - Black and white\n- `pastel colors` - Soft, low saturation colors\n- `limited palette` - Few colors, unified look\n- `high contrast` - Strong light/dark contrast\n\n### Special Effects\n- `bokeh` - Blurred background with light spots\n- `lens flare` - Light flare effect\n- `chromatic aberration` - Color fringing effect\n- `motion blur` - Speed/movement blur\n\n---\n\n## Special Tags\n\n**Year tags:** `year XXXX` - Mimic art style from specific year\n- Example: `year 2014` for 2014 anime aesthetics\n\n**Location tag:** `location` - Combines indoor/outdoor, indicates specific scene needed\n\n**Dataset tags (MUST be at very start):**\n- `fur dataset` - For furry/kemono art\n- `background dataset` - For landscapes, no people, photographic style\n\n---\n\n## Tag Emphasis System\n\n### Bracket Emphasis\n- `{tag}` - Strengthen by 1.05\n- `{{tag}}` - Strengthen by 1.1025\n- `[tag]` - Weaken by 1.05\n- `[[tag]]` - Weaken by 1.1025\n\n### Numerical Emphasis\n- `1.5::tag::` - Multiply weight by 1.5\n- `0.5::tag::` - Multiply weight by 0.5\n- `-1::tag::` - Negative weight (removes/inverts concept)\n\n**Negative weight examples:**\n- `-1::hat::` - Remove hat from character\n- `-1::monochrome::` - Force colorful image\n- `-2.5::flat color::` - Add detailed shading\n\n**In Undesired Content:** Emphasis works in reverse - `{tag}` means avoid more strongly\n\n---\n\n## Multi-Character Prompting (2+ characters)\n\n**CRITICAL: When scenes involve 2+ characters, ALWAYS use the pipe `|` separator syntax for best results.**\n\n** WRONG - Do NOT use this format for multi-character scenes:**\n```\n1boy, 1girl, indoors, living room, close-up, emilia (re:zero), long silver hair, purple eyes, white dress, flushed cheeks, arms around neck, looking at viewer, short dark hair, casual clothes, gentle expression, very aesthetic, masterpiece, best quality, highres, no text, no watermark\n```\n*This format will confuse the AI about which features belong to which character! Both characters\' features are mixed together without clear separation.*\n\n** CORRECT - ALWAYS use pipe separators for 2+ characters:**\n```\n1boy, 1girl, indoors, living room, close-up, intimate distance, very aesthetic, masterpiece, best quality, highres, no text, no watermark | girl, emilia (re:zero), long silver hair, purple eyes, white dress, flushed cheeks, source#embrace, arms around neck, looking at viewer | boy, short dark hair, casual clothes, target#embrace, close to her, gentle expression\n```\n\n**Structure:** `base prompt | character 1 | character 2 | ...`\n\n**Base prompt must include:**\n- Subject count tags (MANDATORY): `2girls`, `1boy, 1girl`, `3boys`, etc.\n- Quality tags (MANDATORY): `very aesthetic, masterpiece, best quality, highres, no text, no watermark`\n- Scene, location, lighting\n- Spatial positioning: `side by side`, `facing each other`, `close together`\n\n**Each character prompt must include:**\n- Character type (no number): `girl`, `boy`, `other`\n- Character name if known: `character_name (series_name)`\n- Physical features: hair color, eye color, body type\n- Clothing, expression, pose\n- Body framing: `upper body`, `full body`, `portrait`\n- **Action tags with prefixes when interacting (see below)**\n\n**Interaction action tag prefixes:**\n\nUse these when characters interact physically or socially:\n\n- `source#[action]` - The character actively performing/initiating the action\n- `target#[action]` - The character passively receiving the action\n- `mutual#[action]` - Both characters doing the action together simultaneously\n\n**Common interaction actions:**\n\n**Physical contact:**\n- Hugging: `source#hug` (person hugging), `target#hug` (being hugged), `mutual#hug` (both hugging each other)\n- Kissing: `source#kiss` (initiating kiss), `target#kiss` (receiving kiss), `mutual#kiss` (both kissing)\n- Headpat: `source#headpat` (giving headpat), `target#headpat` (receiving headpat)\n- Embrace: `source#embrace` (embracing), `target#embrace` (being embraced)\n- Hand holding: `mutual#handholding` (both holding hands)\n- Dancing: `mutual#dancing` (dancing together)\n- High five: `mutual#high five` (both giving high five)\n\n**Visual interaction:**\n- Looking: `source#looking at another` (actively looking), `target#being looked at` (being looked at)\n\n**Social interaction:**\n- Communication: `source#talking`, `target#listening`\n- Pointing: `source#pointing`, `target#pointed at`\n- Laughing: `mutual#laughing` (laughing together)\n- Playing: `mutual#playing` (playing together)\n\n**When to use which prefix:**\n- If one character is clearly doing something TO another  use `source#` and `target#`\n- If both characters are doing the same action together  use `mutual#` for both\n- Example: Person A hugging Person B  A gets `source#hug`, B gets `target#hug`\n- Example: Two people hugging each other equally  Both get `mutual#hug`\n\n**Why this matters:** Without pipe separators and proper action tags, the AI cannot properly understand which physical features and actions belong to which character, leading to confused or incorrect anatomy.\n\n---\n\n## Composition & Framing\n\n**Always specify framing:**\n- `portrait` - Head and shoulders\n- `upper body` - Waist up\n- `cowboy shot` - Thighs up\n- `full body` - Entire body visible\n- `from above` / `from below` / `from side` / `from behind` - Camera angle\n\n**Pose details (be specific):**\n- Arms: `arms at sides`, `arms crossed`, `arms raised`, `one arm raised`\n- Hands: `hands on hips`, `hands clasped`, `hand in hair`, `hands together`\n- Legs: `legs crossed`, `legs apart`, `one knee up`\n- Sitting: `sitting`, `seiza`, `crossed legs`, `legs to side`\n- Standing: `standing`, `contrapposto`, `casual stance`\n- Action: `walking`, `running`, `jumping`, `reaching`\n\n**More detail = Better anatomy.** For complex poses, add MORE tags, not fewer.\n\n---\n\n## Negative Prompts (Undesired Content)\n\n**Core principle:** Describe what you DON\'T want directly (use `blurry`, not `not sharp`)\n\n**Essential negative prompts:**\n\n**Quality:**\n`lowres, worst quality, bad quality, normal quality, low quality, jpeg artifacts, blurry, ugly`\n\n**Anatomy:**\n`bad anatomy, bad hands, missing fingers, extra digit, fewer digits, bad feet, malformed limbs, extra limbs, fused fingers, bad proportions`\n\n**Artifacts:**\n`text, watermark, signature, username, artist name, error, cropped, out of frame`\n\n**Style issues:**\n`monochrome` (if want color), `sketch` (if want finished), `duplicate, mutation, deformed, bad composition`\n\n**Warning:** Over-stuffing negative prompts can reduce AI creativity. Use strategically based on specific needs.\n\n---\n\n## Character Consistency\n\n**For known characters (from anime/game/novel):**\n- **CRITICAL: Always use Danbooru character tags** in format: `character_name (series_name)`\n- This ensures the AI recognizes the character and generates consistent appearance\n- Examples: `nilou (genshin impact)`, `frieren (sousou no frieren)`, `hatsune miku (vocaloid)`\n- Check Danbooru to find the exact tag format for the character\n- **IMPORTANT: When using character tags, DO NOT override their canonical features (hair color, eye color, etc.) unless intentionally creating an AU version**\n\n**For original characters:**\n- Use identical descriptions throughout: hair color, eye color, body type, clothing, distinctive features\n- Be consistent with every detail to maintain character appearance across multiple images\n- Keep a character reference sheet with exact tags to use consistently\n\n---\n\n## Example Prompts\n\n**Single character:**\n```\n\x3c!--img-prompt="1girl, bedroom, morning sunlight, sitting on bed, long red hair, purple eyes, peaceful expression, white nightgown, very aesthetic, masterpiece, best quality, highres, no text, no watermark, soft lighting, detailed background"--\x3e\n```\n\n**No humans landscape:**\n```\n\x3c!--img-prompt="no humans, ancient forest, towering trees, dappled sunlight, moss-covered ground, mysterious atmosphere, very aesthetic, masterpiece, best quality, highres, no text, no watermark, detailed, fantasy"--\x3e\n```\n\n**Two characters with mutual interaction (cuddling):**\n```\n\x3c!--img-prompt="1boy, 1girl, living room, afternoon, sitting on couch, close together, mutual#cuddling, very aesthetic, masterpiece, best quality, highres, no text, no watermark, soft lighting, warm atmosphere | girl, emilia (re:zero), long silver hair, purple eyes, white dress, leaning against him, head on shoulder, smiling, eyes closed, relaxed expression | boy, short black hair, blue eyes, casual shirt and jeans, arm around her shoulders, gentle smile, looking down at her"--\x3e\n```\n\n**Two characters with source/target interaction (embrace):**\n```\n\x3c!--img-prompt="1boy, 1girl, bedroom, evening, close-up, intimate distance, very aesthetic, masterpiece, best quality, highres, no text, no watermark, soft lighting | girl, emilia (re:zero), long silver hair, purple eyes, white dress, flushed cheeks, source#embrace, arms around his neck, looking up at him, gentle smile | boy, short dark hair, brown eyes, casual shirt, target#embrace, hands on her waist, looking down at her, affectionate expression"--\x3e\n```\n\n**Two characters - headpat interaction:**\n```\n\x3c!--img-prompt="1boy, 1girl, school hallway, afternoon, standing, very aesthetic, masterpiece, best quality, highres, no text, no watermark | boy, tall, short brown hair, school uniform, source#headpat, hand on her head, smiling, looking down at her | girl, shorter, long black hair, school uniform, target#headpat, looking up, blushing, happy expression, hands clasped in front"--\x3e\n```\n\n**Group scene - three characters:**\n```\n\x3c!--img-prompt="3girls, park, sunny day, standing together, cherry blossoms, very aesthetic, masterpiece, best quality, highres, no text, no watermark, vibrant colors, spring atmosphere | girl, long blonde hair, green eyes, sundress, holding ice cream, laughing, looking at friends | girl, short pink hair, blue eyes, casual t-shirt and shorts, peace sign, cheerful smile | girl, medium brown hair, brown eyes, cardigan and skirt, shy smile, holding camera"--\x3e\n```\n\n**Action scene - running:**\n```\n\x3c!--img-prompt="1girl, city street, late afternoon, running, dynamic pose, motion blur background, very aesthetic, masterpiece, best quality, highres, no text, no watermark, cinematic | girl, frieren (sousou no frieren), long white hair flowing, green eyes, mage outfit, determined expression, full body, from side, arms pumping"--\x3e\n```\n\n**Character portrait:**\n```\n\x3c!--img-prompt="1girl, indoor cafe, afternoon window light, portrait, close-up, very aesthetic, masterpiece, best quality, highres, no text, no watermark, bokeh background, warm lighting | girl, long black hair, brown eyes, cozy sweater, holding coffee cup, gentle smile, looking at viewer, soft expression"--\x3e\n```\n\n---\n\n## Critical Reminders\n\n- **GENERATE FREQUENTLY: Every ~250 words or major scene change**\n- **ALWAYS include official quality tags: `very aesthetic, masterpiece, best quality, highres, no text, no watermark`**\n- **ALWAYS include subject count tags: `1girl`, `2boys`, `1boy, 1girl`, etc.**\n- **For known characters: MUST use Danbooru character tags `character_name (series_name)` and DO NOT override canonical features**\n- **Tag order matters: Earlier tags = stronger influence**\n- ** CRITICAL: For 2+ characters, MUST use `|` separator - NO EXCEPTIONS**\n- ** CRITICAL: For character interactions, use appropriate action tags:**\n  - `source#[action]` for character performing action\n  - `target#[action]` for character receiving action  \n  - `mutual#[action]` for simultaneous mutual action\n- **More specific tags = better anatomy**\n- **Complex poses need MAXIMUM detail**\n- **Use emphasis system for fine control: `{tag}`, `1.5::tag::`, `-1::tag::`**\n\n---\n\n**Provide the complete story content with image prompts inserted at natural narrative moments. Each `\x3c!--img-prompt="..."--\x3e` tag must be on its own line (no extra blank lines before/after), with entire tag content on a single line.**\n'.trim(),predefined:!0}];function O(e,t){const n=t.find((t=>t.id===e));if(n)return n;const r=function(e){return M.find((t=>t.id===e))}(e);return r||M[0]}function L(e){return M.some((t=>t.id===e))}var D=__webpack_require__(293);function G(){return{...y.a$,metaPrompt:C()}}function q(e){const t=G(),n=e.extensionSettings[y.a2];if(!n)return t;const r={...t,...n},i=O(r.currentPresetId,r.customPresets||[]);return r.metaPrompt=i.template,r}function B(e,t){t.extensionSettings[y.a2]=e,t.saveSettingsDebounced()}const j='**TASK:** Update an image generation prompt based on user feedback.\n\n**Current Prompt Tags:**\n{{{currentPrompt}}}\n\n**User\'s Requested Changes:**\n{{{userFeedback}}}\n\n**Your Task:**\n1. Modify the current tags based on the user\'s feedback\n2. Keep the comma-separated tag format (e.g., "tag1, tag2, tag3")\n3. Preserve tags not mentioned in the feedback\n4. Output ONLY the updated tags in HTML comment format\n5. Do NOT write explanations, stories, or conversational text\n\n**Required Output Format:**\n\x3c!--img-prompt="updated tags here"--\x3e\n\n**Examples:**\n\nInput tags: "1girl, red hair, blue eyes, park"\nFeedback: "change to indoor bedroom"\nOutput: \x3c!--img-prompt="1girl, red hair, blue eyes, bedroom, indoors"--\x3e\n\nInput tags: "1boy, sword, battle, outdoor"\nFeedback: "make it peaceful, remove sword"\nOutput: \x3c!--img-prompt="1boy, peaceful, outdoor, nature"--\x3e\n\n**CRITICAL:** Output ONLY the HTML comment line. No other text.\n\n**Your output:**\n',F=(0,_.h)("PromptUpdater");async function U(e,t,n){F.info(`Updating prompt at position ${e.messageId}_${e.promptIndex} with feedback: "${t}"`);const r=(0,k.PW)(e,n);if(!r)return F.error(`No prompt found at position ${e.messageId}_${e.promptIndex}`),null;const i=(0,k.WJ)(r,n);if(!i)return F.error(`Prompt text not found for ID: ${r}`),null;if(!n.generateRaw)throw F.error("generateRaw not available in context"),new Error("LLM generation not available");const s=j.replace("{{{currentPrompt}}}",i).replace("{{{userFeedback}}}",t);let o;F.debug("Sending prompt to LLM for update (using generateRaw)");try{o=await n.generateRaw({systemPrompt:"You are a technical assistant helping to update image generation prompts. Output ONLY the updated prompt in HTML comment format. Do NOT write stories, explanations, or continue any roleplay.",prompt:s})}catch(e){throw F.error("LLM generation failed:",e),e}const a=function(e){for(const t of y.DV){const n=new RegExp(t,"i"),r=e.match(n);if(r&&r[1])return r[1]}return null}(o);if(!a)return F.error("Failed to extract prompt from LLM response:",o),null;F.info(`LLM generated updated prompt: "${a}"`);const l=(0,k.yj)(a,n);return await(0,k.s8)(e,l,t,n),l}var z=__webpack_require__(629);const V=(0,_.h)("ManualGen");async function W(e,t,n,r){return(0,z.Tj)(e,(async()=>{try{if(ue(e))return V.warn(`Cannot generate images for message ${e}: streaming is active`),toastr.warning((0,D.t)("toast.cannotGenerateMessageStreaming"),(0,D.t)("extensionName")),0;V.info(`Generating images for message ${e} in ${t} mode`);const i=n.chat?.[e];if(!i)return V.warn("Message not found:",e),toastr.error((0,D.t)("toast.messageNotFound"),(0,D.t)("extensionName")),0;let s=i.mes;const o=(0,g.g)(s,r.promptDetectionPatterns);if(0===o.length)return V.info("No prompts found in message"),toastr.info((0,D.t)("toast.noPromptsFound"),(0,D.t)("extensionName")),0;if(V.info(`Found ${o.length} prompts`),"replace"===t){const e=s.length;s=function(e,t){const n=(0,g.g)(e,t);let r=e;for(let e=n.length-1;e>=0;e--){const t=n[e],i=r.substring(t.endIndex),s=/^\s*<img\s+[^>]*>/g;let o,a=0;for(;null!==(o=s.exec(i))&&o.index===a;)a+=o[0].length,s.lastIndex=a;a>0&&(r=r.substring(0,t.endIndex)+r.substring(t.endIndex+a))}return r}(s,r.promptDetectionPatterns),V.info(`Replace mode: removed existing images (${e} -> ${s.length} chars)`)}else V.info("Append mode: will append new images after existing ones");const a=(0,g.g)(s,r.promptDetectionPatterns);toastr.info((0,D.m)(a.length,"toast.generatingImages"),(0,D.t)("extensionName")),(0,P.uP)(e,a.length);const l=performance.now(),c=[];for(let t=0;t<a.length;t++){const i=a[t];V.info(`Generating image ${t+1}/${a.length}`);const s=await(0,h.Fz)(i.prompt,n,r.commonStyleTags,r.commonStyleTagsPosition);s&&c.push({prompt:i,imageUrl:s,originalIndex:t}),(0,P.B$)(e,t+1,a.length)}c.sort(((e,t)=>t.prompt.startIndex-e.prompt.startIndex));let u=0;for(const{prompt:e,imageUrl:n,originalIndex:r}of c){const i=e.fullMatch,o=s.indexOf(i);if(-1!==o){let e=o+i.length;if("append"===t){const t=s.substring(e),n=/\s*<img\s+[^>]*>/g;let r,i=0;for(;null!==(r=n.exec(t))&&(r.index===i||""===t.substring(i,r.index).trim());)i=n.lastIndex;i>0&&(e+=i)}const a=`AI generated image #${r+1}`,l=`\n<img src="${n}" title="${a}" alt="${a}">`;s=s.substring(0,e)+l+s.substring(e),u++}else V.warn(`Could not find prompt tag in text: "${i.substring(0,80)}..."`)}const d=performance.now()-l;V.info(`Generated ${u}/${a.length} images (${d.toFixed(0)}ms total)`),i.mes=s;const p=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(p,e),n.updateMessageBlock(e,i);const m=n.eventTypes.MESSAGE_UPDATED;return await n.eventSource.emit(m,e),await n.saveChat(),V.debug("Chat saved after manual generation"),(0,P.UK)(e),u===a.length?toastr.success((0,D.m)(u,"toast.successGenerated"),(0,D.t)("extensionName")):u>0?toastr.warning((0,D.t)("toast.partialGenerated",{success:u,total:a.length}),(0,D.t)("extensionName")):toastr.error((0,D.t)("toast.failedToGenerate"),(0,D.t)("extensionName")),u}catch(t){return V.error("Error during manual image generation:",t),toastr.error((0,D.t)("toast.failedToGenerate"),(0,D.t)("extensionName")),(0,P.UK)(e),0}}),"manual image generation")}function H(e,t,n){const r=new RegExp(`<img\\s+src="${t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}"[^>]*>`,"g").exec(e);if(!r)return V.warn("Image not found in message text:",t),null;const i=r.index,s=e.substring(0,i),o=(0,g.g)(s,n);return 0===o.length?(V.warn("No prompt found before image"),null):o[o.length-1].prompt}async function K(e,t,n,r,i){return(0,z.Tj)(e,(async()=>{try{if(ue(e))return V.warn(`Cannot regenerate image for message ${e}: streaming is active`),toastr.warning((0,D.t)("toast.cannotGenerateMessageStreaming"),(0,D.t)("extensionName")),0;let s=r.chat?.[e];if(!s)return V.error("Message not found:",e),toastr.error((0,D.t)("toast.messageNotFound"),(0,D.t)("extensionName")),0;const o=H(s.mes||"",t,i.promptDetectionPatterns);if(!o)return toastr.error((0,D.t)("toast.promptNotFoundForImage"),(0,D.t)("extensionName")),0;V.info(`Regenerating image for prompt: "${o}" (mode: ${n})`),(0,P.uP)(e,1),toastr.info((0,D.t)("toast.generatingNewImage"),(0,D.t)("extensionName"));const a=await(0,h.Fz)(o,r,i.commonStyleTags,i.commonStyleTagsPosition);if((0,P.B$)(e,1,1),!a)return toastr.error((0,D.t)("toast.failedToGenerateImage"),(0,D.t)("extensionName")),(0,P.UK)(e),0;if(s=r.chat?.[e],!s)return V.error("Message not found after generation:",e),toastr.error((0,D.t)("toast.messageDisappeared"),(0,D.t)("extensionName")),0;let l=s.mes||"";const c=function(e,t,n,r){const i=(0,g.g)(e,r).find((e=>e.prompt===t));if(!i)return null;const s=i.fullMatch,o=i.startIndex,a=e.substring(o+s.length),l=/\s*<img\s+[^>]*>/g;let c,u=0,d=0;for(;null!==(c=l.exec(a))&&(c.index===d||""===a.substring(d,c.index).trim());)if(u++,d=l.lastIndex,c[0].includes(`src="${n}"`))return u;return null}(l,o,t,i.promptDetectionPatterns);if(!c)return V.error("Could not determine image index for regeneration"),toastr.error((0,D.t)("toast.failedToDetermineIndex"),(0,D.t)("extensionName")),0;const u=(0,g.g)(l,i.promptDetectionPatterns).find((e=>e.prompt===o));if(!u)return V.error("Prompt tag not found in text"),toastr.error((0,D.t)("toast.failedToFindPromptTag"),(0,D.t)("extensionName")),0;const d=u.fullMatch;let p=u.startIndex+d.length;if("replace"===n){const e=l.substring(p),n=t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),r=new RegExp(`\\s*<img\\s+src="${n}"[^>]*>`,""),i=e.match(r);if(i&&void 0!==i.index){const e=p+i.index,t=e+i[0].length;l=l.substring(0,e)+l.substring(t),p=e,V.info("Removed and will replace clicked image at same position")}else V.warn("Could not find clicked image in text, will append instead")}else{const e=l.substring(p),t=/\s*<img\s+[^>]*>/g;let n,r=0;for(;null!==(n=t.exec(e))&&(n.index===r||""===e.substring(r,n.index).trim());)r=t.lastIndex;r>0&&(p+=r)}const m=function(e,t,n,r){const i=(0,g.g)(e,r).find((e=>e.prompt===t));if(!i)return 0;const s=i.fullMatch,o=i.startIndex,a=e.substring(o+s.length),l=/\s*<img\s+[^>]*>/g;let c,u=0,d=0;const p=new RegExp(`AI generated image #${n} \\(Regenerated (\\d+)\\)`);for(;null!==(c=l.exec(a))&&(c.index===d||""===a.substring(d,c.index).trim());){d=l.lastIndex;const e=c[0].match(p);if(e){const t=parseInt(e[1],10);t>u&&(u=t)}}return u}(l,o,c,i.promptDetectionPatterns),_=`AI generated image #${c} (Regenerated ${m+1})`,f=`\n<img src="${a}" title="${_}" alt="${_}">`;l=l.substring(0,p)+f+l.substring(p),s.mes=l;const v=r.eventTypes.MESSAGE_EDITED;await r.eventSource.emit(v,e),r.updateMessageBlock(e,s);const y=r.eventTypes.MESSAGE_UPDATED;return await r.eventSource.emit(y,e),await r.saveChat(),toastr.success((0,D.t)("toast.imageRegenerated"),(0,D.t)("extensionName")),V.info("Image regenerated successfully"),(0,P.UK)(e),setTimeout((()=>{Q(r,i)}),100),1}catch(t){return V.error("Error during image regeneration:",t),toastr.error((0,D.t)("toast.failedToGenerateImage"),(0,D.t)("extensionName")),(0,P.UK)(e),0}}),"image regeneration")}async function Y(e,t,n,r){if(ue(e))return void toastr.warning((0,D.t)("toast.cannotManualWhileStreaming"),(0,D.t)("extensionName"));const i=await(0,z.Tj)(e,(async()=>await async function(e,t,n,r){const i=$("#auto_illustrator_prompt_update_dialog");if(i.length>0)return V.debug("Dialog already open, closing it"),$(".auto-illustrator-dialog-backdrop").remove(),i.remove(),null;const s=n.chat?.[e];if(!s)return V.error("Message not found:",e),toastr.error((0,D.t)("toast.messageNotFound"),(0,D.t)("extensionName")),null;V.debug("showPromptUpdateDialogImpl called",{messageId:e,imageSrc:t,messageText:s.mes.substring(0,200)});const o=function(e,t,n,r){const i=new RegExp(`<img\\s+src="${t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}"[^>]*>`,"g").exec(n);if(!i)return V.warn("Image not found in message text:",t),null;const s=i.index,o=n.substring(0,s),a=(0,g.g)(o,r);if(0===a.length)return V.warn("No prompt found before image"),null;const l=a[a.length-1].prompt,c=(0,g.g)(n,r).findIndex((e=>e.prompt===l));return-1===c?(V.warn("Could not find prompt index in full message"),null):{messageId:e,promptIndex:c}}(e,t,s.mes,r.promptDetectionPatterns);if(!o)return V.error("Could not find prompt position for image",{imageSrc:t,messageId:e}),toastr.error((0,D.t)("toast.promptNotFoundForImage"),(0,D.t)("extensionName")),null;V.debug("Found prompt position",o);const a=(0,k.PW)(o,n),l=a?(0,k.WJ)(a,n):H(s.mes,t,r.promptDetectionPatterns);if(!l)return toastr.error((0,D.t)("toast.promptNotFoundForImage"),(0,D.t)("extensionName")),null;const c=l;if(V.debug("Current prompt extracted",{currentPrompt:c,currentPromptId:a}),!a){V.info("Initializing metadata for legacy prompt",{position:o,promptText:c});const e=(0,k.yj)(c,n);(0,k.K5)(o,e,n)}const u=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),n=$("<div>").attr("id","auto_illustrator_prompt_update_dialog").addClass("auto-illustrator-dialog");n.append($("<h3>").text((0,D.t)("dialog.updatePromptTitle"))),n.append($("<label>").text((0,D.t)("dialog.currentPrompt")));const r=$("<div>").addClass("auto-illustrator-current-prompt").text(c);n.append(r),n.append($("<label>").text((0,D.t)("dialog.userFeedback")));const i=$("<textarea>").addClass("auto-illustrator-feedback-textarea").attr("placeholder",(0,D.t)("dialog.feedbackPlaceholder")).attr("rows","4");n.append(i);const s=$("<div>").addClass("auto-illustrator-dialog-buttons"),o=$("<button>").text((0,D.t)("dialog.updateWithAI")).addClass("menu_button").on("click",(()=>{const r=i.val();r&&""!==r.trim()?(t.remove(),n.remove(),e(r.trim())):toastr.warning((0,D.t)("toast.feedbackRequired"),(0,D.t)("extensionName"))})),a=$("<button>").text((0,D.t)("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e(null)}));s.append(o).append(a),n.append(s),$("body").append(t).append(n),t.on("click",(()=>{t.remove(),n.remove(),e(null)})),i.focus()}));if(!u)return V.info("Prompt update cancelled by user"),null;try{toastr.info((0,D.t)("toast.updatingPromptWithAI"),(0,D.t)("extensionName"));const t=await U(o,u,n);if(!t)return V.error("Failed to update prompt - LLM returned null"),toastr.error((0,D.t)("toast.failedToUpdatePrompt"),(0,D.t)("extensionName")),null;const i=(0,k.WJ)(t,n);if(!i)return V.error("Failed to get prompt text for new prompt ID"),toastr.error((0,D.t)("toast.failedToUpdatePrompt"),(0,D.t)("extensionName")),null;V.info(`Prompt updated: "${c}" -> "${i}"`);const a=(0,g.g)(s.mes,r.promptDetectionPatterns)[o.promptIndex];if(!a)return V.error("Could not find prompt match in message"),toastr.error((0,D.t)("toast.failedToUpdatePrompt"),(0,D.t)("extensionName")),null;let l=s.mes;const d=a.fullMatch,p=c.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),m=d.replace(new RegExp(p,"g"),i);l=l.replace(d,m),s.mes=l;const h=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(h,e),n.updateMessageBlock(e,s);const _=n.eventTypes.MESSAGE_UPDATED;await n.eventSource.emit(_,e),await n.saveChat(),toastr.success((0,D.t)("toast.promptUpdated"),(0,D.t)("extensionName"));const f=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),n=$("<div>").attr("id","auto_illustrator_regen_confirm_dialog").addClass("auto-illustrator-dialog");n.append($("<p>").text((0,D.t)("dialog.promptUpdatedRegenerateWithMode")));const i=$("<div>").addClass("auto-illustrator-mode-group"),s=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("replace").prop("checked","replace"===r.manualGenerationMode)).append($("<span>").html(`<strong>${(0,D.t)("dialog.replace")}</strong> ${(0,D.t)("dialog.replaceRegen")}`)),o=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("append").prop("checked","append"===r.manualGenerationMode)).append($("<span>").html(`<strong>${(0,D.t)("dialog.append")}</strong> ${(0,D.t)("dialog.appendRegen")}`));i.append(o).append(s),n.append(i);const a=$("<div>").addClass("auto-illustrator-dialog-buttons"),l=$("<button>").text((0,D.t)("dialog.generate")).addClass("menu_button").on("click",(()=>{const r=n.find('input[name="regen_mode"]:checked').val();t.remove(),n.remove(),e(r)})),c=$("<button>").text((0,D.t)("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e(null)}));a.append(l).append(c),n.append(a),$("body").append(t).append(n),t.on("click",(()=>{t.remove(),n.remove(),e(null)}))}));return V.info("User selected regeneration mode:",f),f}catch(e){return V.error("Error updating prompt:",e),toastr.error((0,D.t)("toast.failedToUpdatePrompt"),(0,D.t)("extensionName")),null}}(e,t,n,r)),"prompt update dialog");i&&(V.info("Regenerating after prompt update",{mode:i}),await K(e,t,i,n,r))}async function X(e,t,n,r){if(ue(e))return void toastr.warning((0,D.t)("toast.cannotGenerateMessageStreaming"),(0,D.t)("extensionName"));const i=$("#auto_illustrator_regen_dialog");if(i.length>0)return V.debug("Dialog already open, closing it"),$(".auto-illustrator-dialog-backdrop").remove(),void i.remove();const s=(0,D.t)("dialog.whatToDo"),o=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),n=$("<div>").attr("id","auto_illustrator_regen_dialog").addClass("auto-illustrator-dialog");n.append($("<p>").text(s));const i=$("<div>").addClass("auto-illustrator-mode-group"),o=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("replace").prop("checked","replace"===r.manualGenerationMode)).append($("<span>").html(`<strong>${(0,D.t)("dialog.replace")}</strong> ${(0,D.t)("dialog.replaceRegen")}`)),a=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("append").prop("checked","append"===r.manualGenerationMode)).append($("<span>").html(`<strong>${(0,D.t)("dialog.append")}</strong> ${(0,D.t)("dialog.appendRegen")}`));i.append(a).append(o),n.append(i);const l=$("<div>").addClass("auto-illustrator-dialog-buttons"),c=$("<button>").text((0,D.t)("dialog.generate")).addClass("menu_button").on("click",(()=>{const r=n.find('input[name="regen_mode"]:checked').val();t.remove(),n.remove(),e(r)})),u=$("<button>").text((0,D.t)("dialog.updatePrompt")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e("update_prompt")})),d=$("<button>").text((0,D.t)("dialog.delete")).addClass("menu_button caution").on("click",(()=>{t.remove(),n.remove(),e("delete")})),p=$("<button>").text((0,D.t)("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e(null)}));l.append(c).append(u).append(d).append(p),n.append(l),$("body").append(t).append(n),t.on("click",(()=>{t.remove(),n.remove(),e(null)}))}));o?"delete"===o?await async function(e,t,n,r){return(0,z.Tj)(e,(async()=>{const i=n.chat?.[e];if(!i)return V.error("Message not found:",e),toastr.error((0,D.t)("toast.messageNotFound"),(0,D.t)("extensionName")),!1;let s=i.mes||"";const o=s.length,a=t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),l=new RegExp(`\\s*<img\\s+src="${a}"[^>]*>`,"g");if(s=s.replace(l,""),s.length===o)return V.warn("Image not found in message text"),toastr.warning((0,D.t)("toast.imageNotFound"),(0,D.t)("extensionName")),!1;i.mes=s;const c=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(c,e),n.updateMessageBlock(e,i);const u=n.eventTypes.MESSAGE_UPDATED;return await n.eventSource.emit(u,e),await n.saveChat(),toastr.success((0,D.t)("toast.imageDeleted"),(0,D.t)("extensionName")),V.info("Image deleted successfully"),setTimeout((()=>{Q(n,r)}),100),!0}),"image deletion")}(e,t,n,r):"update_prompt"===o?await Y(e,t,n,r):await K(e,t,o,n,r):V.info("Action cancelled by user")}function Q(e,t){$('.mes_text img[title^="AI generated image"]').off("click.auto_illustrator_regen"),$('.mes_text img[title^="AI generated image"]').on("click.auto_illustrator_regen",(function(){const n=$(this),r=n.closest(".mes").attr("mesid");if(!r)return void V.warn("Could not find message ID for clicked image");const i=parseInt(r,10);if(isNaN(i))return void V.warn("Invalid message ID:",r);const s=n.attr("src");s?(V.info(`Image clicked: messageId=${i}, src=${s.substring(0,50)}...`),X(i,s,e,t)):V.warn("Image has no src attribute")})),V.debug(`Added click handlers to ${$('.mes_text img[title^="AI generated image"]').length} images`)}function J(e,t,n,r){const i=n.chat?.[t];if(!i||i.is_user)return;if(!(0,g.R)(i.mes))return;const s=$(e);if(s.find(".auto_illustrator_manual_gen").length>0)return;const o=$("<div>").addClass("mes_button auto_illustrator_manual_gen fa-solid fa-wand-magic-sparkles").attr("title",(0,D.t)("button.manualGenerate")).on("click",(async()=>{if(ue(t))toastr.warning((0,D.t)("toast.cannotGenerateMessageStreaming"),(0,D.t)("extensionName"));else{o.prop("disabled",!0),o.css("opacity","0.5");try{await async function(e,t,n){if(ue(e))return void toastr.warning((0,D.t)("toast.cannotGenerateMessageStreaming"),(0,D.t)("extensionName"));const r=$("#auto_illustrator_manual_gen_dialog");if(r.length>0)return V.debug("Dialog already open, closing it"),$(".auto-illustrator-dialog-backdrop").remove(),void r.remove();const i=t.chat?.[e];if(!i)return void V.warn("Message not found:",e);const s=(0,g.g)(i.mes,n.promptDetectionPatterns);if(0===s.length)return void toastr.info((0,D.t)("toast.noPromptsFound"),(0,D.t)("extensionName"));const o=(0,D.m)(s.length,"dialog.foundPrompts")+"\n\n"+(0,D.t)("dialog.howToGenerate"),a=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),r=$("<div>").attr("id","auto_illustrator_manual_gen_dialog").addClass("auto-illustrator-dialog");r.append($("<p>").text(o));const i=$("<div>").addClass("auto-illustrator-mode-group"),s=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","generation_mode").val("replace").prop("checked","replace"===n.manualGenerationMode)).append($("<span>").html(`<strong>${(0,D.t)("dialog.replace")}</strong> ${(0,D.t)("dialog.replaceDesc")}`)),a=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","generation_mode").val("append").prop("checked","append"===n.manualGenerationMode)).append($("<span>").html(`<strong>${(0,D.t)("dialog.append")}</strong> ${(0,D.t)("dialog.appendDesc")}`));i.append(a).append(s),r.append(i);const l=$("<div>").addClass("auto-illustrator-dialog-buttons"),c=$("<button>").text((0,D.t)("dialog.generate")).addClass("menu_button").on("click",(()=>{const n=r.find('input[name="generation_mode"]:checked').val();t.remove(),r.remove(),e(n)})),u=$("<button>").text((0,D.t)("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),r.remove(),e(null)}));l.append(c).append(u),r.append(l),$("body").append(t).append(r),t.on("click",(()=>{t.remove(),r.remove(),e(null)}))}));a?await W(e,a,t,n):V.info("Generation cancelled by user")}(t,n,r)}finally{o.prop("disabled",!1),o.css("opacity","1")}}})),a=s.find(".extraMesButtons");a.length>0&&a.append(o)}var Z=__webpack_require__(974);const ee=(0,_.h)("Main");let te,ne,re=!1,ie=null,se=null,oe=!1,ae=null,le=null,ce=null;function ue(e){const t=le?.isActive()??!1;return void 0===e?t:t&&de===e}let de=null;function pe(e){return de===e}function me(){const e=document.getElementById(y.he.ENABLED),t=document.getElementById(y.he.META_PROMPT),n=document.getElementById(y.he.META_PROMPT_PRESET_SELECT),r=document.getElementById(y.he.META_PROMPT_PRESET_DELETE),i=document.getElementById(y.he.PRESET_EDITOR),s=document.getElementById(y.he.PRESET_VIEWER),o=document.getElementById(y.he.PRESET_PREVIEW),a=document.getElementById(y.he.STREAMING_ENABLED),l=document.getElementById(y.he.STREAMING_POLL_INTERVAL),c=document.getElementById(y.he.MAX_CONCURRENT),u=document.getElementById(y.he.MIN_GENERATION_INTERVAL),d=document.getElementById(y.he.LOG_LEVEL),p=document.getElementById(y.he.PROMPT_PATTERNS),m=document.getElementById(y.he.COMMON_STYLE_TAGS),g=document.getElementById(y.he.COMMON_STYLE_TAGS_POSITION),h=document.getElementById(y.he.MANUAL_GEN_MODE);if(e&&(e.checked=ne.enabled),a&&(a.checked=ne.streamingEnabled),l&&(l.value=ne.streamingPollInterval.toString()),c&&(c.value=ne.maxConcurrentGenerations.toString()),u&&(u.value=ne.minGenerationInterval.toString()),d&&(d.value=ne.logLevel),p&&(p.value=ne.promptDetectionPatterns.join("\n")),m&&(m.value=ne.commonStyleTags),g&&(g.value=ne.commonStyleTagsPosition),h&&(h.value=ne.manualGenerationMode),n){const e=n.querySelector("#custom_presets_group");e&&(e.innerHTML="",ne.customPresets.forEach((t=>{const n=document.createElement("option");n.value=t.id,n.textContent=t.name,e.appendChild(n)}))),n.value=ne.currentPresetId}if(r){const e=L(ne.currentPresetId);r.disabled=e,r.title=e?"Cannot delete predefined presets":"Delete custom preset"}o&&(o.textContent=ne.metaPrompt),t&&(t.value=ne.metaPrompt),i&&(i.style.display="none"),s&&(s.style.display="block"),re=!1,ge()}function ge(){const e=document.getElementById(y.he.PATTERN_VALIDATION_STATUS);if(!e)return;const t=function(){const e=ne.metaPrompt,t=ne.promptDetectionPatterns;if(!e||!t||0===t.length)return!1;try{return(0,Z.lJ)(e,t).length>0}catch(e){return ee.warn("Error validating prompt patterns:",e),!1}}();e.className="pattern-validation-status",t?(e.classList.add("validation-success"),e.innerHTML=`\n      <span class="validation-message">${(0,D.t)("settings.validationSuccess")}</span>\n    `):(e.classList.add("validation-warning"),e.innerHTML=`\n      <span class="validation-message">${(0,D.t)("settings.validationWarning")}</span>\n      <span class="validation-hint">${(0,D.t)("settings.validationHint")}</span>\n    `)}function he(e,t,n,r){const i=Math.round(e/r)*r;return Math.max(t,Math.min(n,i))}function _e(){const e=document.getElementById(y.he.ENABLED),t=document.getElementById(y.he.META_PROMPT),n=document.getElementById(y.he.STREAMING_ENABLED),r=document.getElementById(y.he.STREAMING_POLL_INTERVAL),i=document.getElementById(y.he.MAX_CONCURRENT),s=document.getElementById(y.he.MIN_GENERATION_INTERVAL),o=document.getElementById(y.he.LOG_LEVEL),a=document.getElementById(y.he.PROMPT_PATTERNS),l=document.getElementById(y.he.COMMON_STYLE_TAGS),c=document.getElementById(y.he.COMMON_STYLE_TAGS_POSITION),u=document.getElementById(y.he.MANUAL_GEN_MODE);if(ne.enabled=e?.checked??ne.enabled,ne.metaPrompt=t?.value??ne.metaPrompt,ne.streamingEnabled=n?.checked??ne.streamingEnabled,r){const e=parseInt(r.value),t=he(e,y.BB.MIN,y.BB.MAX,y.BB.STEP);ne.streamingPollInterval=t,r.value=t.toString(),t!==e&&toastr.warning((0,D.t)("toast.valueAdjusted",{original:e,clamped:t,min:y.BB.MIN,max:y.BB.MAX,step:y.BB.STEP}),(0,D.t)("extensionName"))}if(i){const e=parseInt(i.value),t=he(e,y.zY.MIN,y.zY.MAX,y.zY.STEP);ne.maxConcurrentGenerations=t,i.value=t.toString(),t!==e&&toastr.warning((0,D.t)("toast.valueAdjustedNoStep",{original:e,clamped:t,min:y.zY.MIN,max:y.zY.MAX}),(0,D.t)("extensionName"))}if(s){const e=parseInt(s.value),t=he(e,y.uF.MIN,y.uF.MAX,y.uF.STEP);ne.minGenerationInterval=t,s.value=t.toString(),t!==e&&toastr.warning((0,D.t)("toast.valueAdjusted",{original:e,clamped:t,min:y.uF.MIN,max:y.uF.MAX,step:y.uF.STEP}),(0,D.t)("extensionName"))}ne.logLevel=o?.value??ne.logLevel,ne.promptDetectionPatterns=a?a.value.split("\n").map((e=>e.trim())).filter((e=>e.length>0)):ne.promptDetectionPatterns,ne.commonStyleTags=l?.value??ne.commonStyleTags,ne.commonStyleTagsPosition=c?.value??ne.commonStyleTagsPosition,ne.manualGenerationMode=u?.value??ne.manualGenerationMode,(0,_.He)(ne.logLevel),(0,h.xn)(ne.maxConcurrentGenerations),(0,h.Hl)(ne.minGenerationInterval),B(ne,te),ge(),ee.info("Settings updated:",ne)}function fe(){ne=G(),B(ne,te),me(),ee.info("Settings reset to defaults")}function ve(){const e=document.getElementById(y.he.PROMPT_PATTERNS);e&&(e.value=y.DV.join("\n"),_e()),ee.info("Prompt patterns reset to defaults")}function ye(){re&&xe();const e=document.getElementById(y.he.META_PROMPT_PRESET_SELECT);if(!e)return;const t=e.value,n=O(t,ne.customPresets);ne.currentPresetId=t,ne.metaPrompt=n.template,B(ne,te),me(),ee.info("Preset changed:",{id:t,name:n.name})}function be(){const e=document.getElementById(y.he.PRESET_EDITOR),t=document.getElementById(y.he.PRESET_VIEWER),n=document.getElementById(y.he.META_PROMPT),r=document.getElementById(y.he.META_PROMPT_PRESET_SAVE);if(e&&t&&n){if(t.style.display="none",e.style.display="block",n.removeAttribute("readonly"),n.value=ne.metaPrompt,r){const e=L(ne.currentPresetId);r.disabled=e,r.title=e?"Cannot save changes to predefined presets (use Save As)":"Save changes to this preset"}re=!0,ee.info("Entered preset edit mode")}}function Ee(){if(L(ne.currentPresetId))return void toastr.error((0,D.t)("settings.cannotDeletePredefined"),(0,D.t)("extensionName"));const e=document.getElementById(y.he.META_PROMPT);if(!e)return;const t=e.value,n=ne.customPresets.findIndex((e=>e.id===ne.currentPresetId));if(-1===n)return void toastr.error((0,D.t)("toast.presetNotFound"),(0,D.t)("extensionName"));ne.customPresets[n].template=t,ne.metaPrompt=t,B(ne,te);const r=document.getElementById(y.he.PRESET_EDITOR),i=document.getElementById(y.he.PRESET_VIEWER);r&&(r.style.display="none"),i&&(i.style.display="block"),re=!1,me(),toastr.success((0,D.t)("toast.presetSaved"),(0,D.t)("extensionName")),ee.info("Preset saved:",ne.customPresets[n].name)}function we(){const e=document.getElementById(y.he.META_PROMPT);if(!e)return;const t=e.value,n=prompt((0,D.t)("prompt.enterPresetName"));if(!n||""===n.trim())return;const r=n.trim();if(function(e){const t=e.toLowerCase();return M.some((e=>e.name.toLowerCase()===t))}(r))return void toastr.error((0,D.t)("toast.cannotUsePredefinedNames"),(0,D.t)("extensionName"));const i=ne.customPresets.find((e=>e.name===r));if(i){if(!confirm((0,D.t)("prompt.overwritePreset",{name:r})))return;i.template=t,ne.currentPresetId=i.id,ne.metaPrompt=t}else{const e={id:`custom-${Date.now()}`,name:r,template:t,predefined:!1};ne.customPresets.push(e),ne.currentPresetId=e.id,ne.metaPrompt=t}B(ne,te);const s=document.getElementById(y.he.PRESET_EDITOR),o=document.getElementById(y.he.PRESET_VIEWER);s&&(s.style.display="none"),o&&(o.style.display="block"),re=!1,me(),toastr.success((0,D.t)("toast.presetSavedNamed",{name:r}),(0,D.t)("extensionName")),ee.info("Preset saved as:",r)}function xe(){const e=document.getElementById(y.he.PRESET_EDITOR),t=document.getElementById(y.he.PRESET_VIEWER),n=document.getElementById(y.he.META_PROMPT);e&&t&&n&&(e.style.display="none",t.style.display="block",n.setAttribute("readonly","readonly"),n.value=ne.metaPrompt,re=!1,ee.info("Cancelled preset edit"))}function ke(){if(L(ne.currentPresetId))return void toastr.error((0,D.t)("toast.cannotDeletePredefined"),(0,D.t)("extensionName"));const e=ne.customPresets.find((e=>e.id===ne.currentPresetId));if(!e)return void toastr.error((0,D.t)("toast.presetNotFound"),(0,D.t)("extensionName"));if(!confirm((0,D.t)("prompt.overwritePreset",{name:e.name})))return;ne.customPresets=ne.customPresets.filter((e=>e.id!==ne.currentPresetId)),ne.currentPresetId="default";const t=O("default",ne.customPresets);ne.metaPrompt=t.template,B(ne,te),me(),toastr.success((0,D.t)("toast.presetDeleted",{name:e.name}),(0,D.t)("extensionName")),ee.info("Preset deleted:",e.name)}function Te(){if(le?.isActive())return;if(!ne.streamingEnabled||!ne.enabled)return;if(!te.chat||0===te.chat.length)return;const e=te.chat.length-1,t=te.chat[e];t.is_user||t.is_system||(le&&de===e?ee.debug(`Already monitoring message ${e}, skipping reinitialization`):(ee.info(`First stream token received, starting streaming for message ${e}`),le&&le.stop(),ce&&ce.stop(),ae=new x,ce=new R(ae,te,ne,ne.maxConcurrentGenerations),le=new I(ae,te,ne,ne.streamingPollInterval,(()=>ce?.trigger())),de=e,oe=!1,se=null,le.start(e),ce.start(e),ee.info("Streaming monitor and processor started")))}function Ie(){ee.info("MESSAGE_RECEIVED fired for streaming, setting flag"),oe=!0,Pe()}async function Pe(){if(se&&oe){const{images:e,messageId:t}=se;ee.info(`Both conditions met, inserting ${e.length} deferred images`),se=null,oe=!1;const{insertDeferredImages:n}=await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,722));await n(e,t,te)}}async function Se(){if(ie=null,ee.debug("Generation ended, cleared generation type"),!le||!ce||!ae)return;ee.info("GENERATION_ENDED, cleaning up streaming"),le.finalScan(),le.stop(),await ce.processRemaining();const e=ce.getDeferredImages(),t=de,n=ae.getStats();ee.info("Final streaming stats:",n),ee.info(`Deferred images count: ${e.length} for message ${t}`),ce.stop(),e.length>0&&null!==t&&(se={images:e,messageId:t},ee.info(`${e.length} images ready, checking if MESSAGE_RECEIVED fired`)),ae=null,le=null,ce=null,de=null;const r=n.FAILED;r>0&&toastr.warning((0,D.t)("toast.streamingFailed",{count:r}),(0,D.t)("extensionName")),await Pe()}function Re(){ee.debug("Adding manual generation buttons to existing messages"),$(".mes").each(((e,t)=>{const n=$(t),r=n.attr("mesid");if(r){const e=parseInt(r,10);isNaN(e)||J(n,e,te,ne)}}))}!function(){ee.info("Initializing extension...");try{te=SillyTavern.getContext(),ee.info("Got SillyTavern context")}catch(e){return void ee.error("Failed to get SillyTavern context:",e)}(0,D.J)(te),ee.info("Initialized i18n"),ne=q(te),ee.info("Loaded settings:",ne),(0,_.He)(ne.logLevel),(0,h.SV)(ne.maxConcurrentGenerations,ne.minGenerationInterval),ee.info(`Initialized concurrency limiter: max=${ne.maxConcurrentGenerations}, minInterval=${ne.minGenerationInterval}ms`);const e=v(te,ne),t=te.eventTypes.MESSAGE_RECEIVED;te.eventSource.on(t,e),te.eventSource.on(t,(e=>{setTimeout((()=>{const t=$(`.mes[mesid="${e}"]`);t.length>0&&J(t,e,te,ne),Q(te,ne)}),100)}));const n=te.eventTypes.MESSAGE_UPDATED;te.eventSource.on(n,(()=>{setTimeout((()=>{Q(te,ne)}),100)}));const r=te.eventTypes.GENERATION_STARTED;te.eventSource.on(r,((e,t,n)=>{n?ee.debug("Generation started (dry run), skipping type tracking",{type:e}):(ie=e,ee.info("Generation started (actual)",{type:e}))}));const i=te.eventTypes.CHAT_COMPLETION_PROMPT_READY;te.eventSource.on(i,(e=>{if(e?.dryRun)return void ee.info("Skipping prompt ready processing for dry run");if(!e?.chat)return;!function(e,t=y.DV){b.info("Pruning generated images from chat history");for(const n of e){if("user"===n.role||"system"===n.role)continue;const e=(0,g.g)(n.content,t);let r=n.content;for(let t=e.length-1;t>=0;t--){const n=e[t],i=r.substring(n.endIndex),s=/^\s*<img\s+[^>]*>/g;let o,a=0;for(;null!==(o=s.exec(i))&&o.index===a;)a+=o[0].length,s.lastIndex=a;a>0&&(r=r.substring(0,n.endIndex)+r.substring(n.endIndex+a))}n.content!==r&&(n.content=r,b.info("Pruned generated images from assistant message"))}}(e.chat);const t=ie||"normal";ne.enabled&&ne.metaPrompt&&!["quiet","impersonate"].includes(t)?(ee.info("Injecting meta-prompt as last system message",{currentGenerationType:ie,effectiveType:t,metaPromptLength:ne.metaPrompt.length}),e.chat.push({role:"system",content:ne.metaPrompt})):ee.info("Skipping meta-prompt injection",{enabled:ne.enabled,hasMetaPrompt:!!ne.metaPrompt,currentGenerationType:ie,effectiveType:t,reason:ne.enabled?ne.metaPrompt?`generation type is ${t}`:"no meta-prompt":"extension disabled"})}));const s=te.eventTypes.STREAM_TOKEN_RECEIVED,o=te.eventTypes.GENERATION_ENDED;te.eventSource.on(s,Te),te.eventSource.on(o,Se),ee.info("Event handlers registered:",{MESSAGE_RECEIVED:t,MESSAGE_UPDATED:n,GENERATION_STARTED:r,CHAT_COMPLETION_PROMPT_READY:i,STREAM_TOKEN_RECEIVED:s,GENERATION_ENDED:o});const a=document.getElementById("extensions_settings2");if(a){const e=`\n    <div class="auto-illustrator-settings">\n      <div class="inline-drawer">\n        <div class="inline-drawer-toggle inline-drawer-header">\n          <b>${(0,D.t)("extensionName")}</b>\n          <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>\n        </div>\n        <div class="inline-drawer-content">\n          <div style="display: flex; align-items: center; justify-content: space-between;">\n            <label class="checkbox_label" for="${y.he.ENABLED}">\n              <input id="${y.he.ENABLED}" type="checkbox" />\n              <span>${(0,D.t)("settings.enable")}</span>\n            </label>\n            <div id="${y.he.RESET_BUTTON}" class="menu_button menu_button_icon">\n              <i class="fa-solid fa-undo"></i>\n              <span>${(0,D.t)("settings.resetDefaults")}</span>\n            </div>\n          </div>\n\n          <div class="preset-management">\n            <label>${(0,D.t)("settings.metaPromptPreset")}</label>\n            <div class="preset-toolbar">\n              <select id="${y.he.META_PROMPT_PRESET_SELECT}" class="text_pole flex_fill">\n                <optgroup label="${(0,D.t)("settings.predefinedPresets")}">\n                  <option value="default">Default</option>\n                  <option value="nai-4.5-full">NAI 4.5 Full</option>\n                </optgroup>\n                <optgroup label="${(0,D.t)("settings.customPresets")}" id="custom_presets_group">\n                  \x3c!-- populated by JavaScript --\x3e\n                </optgroup>\n              </select>\n              <button id="${y.he.META_PROMPT_PRESET_EDIT}" class="menu_button menu_button_icon" title="${(0,D.t)("settings.editPreset")}">\n                <i class="fa-solid fa-edit"></i>\n              </button>\n              <button id="${y.he.META_PROMPT_PRESET_DELETE}" class="menu_button menu_button_icon" title="${(0,D.t)("settings.deletePreset")}">\n                <i class="fa-solid fa-trash"></i>\n              </button>\n            </div>\n\n            <div id="${y.he.PRESET_EDITOR}" style="display:none">\n              <label for="${y.he.META_PROMPT}">\n                <span>${(0,D.t)("settings.metaPromptTemplate")}</span>\n                <small>${(0,D.t)("settings.editingPresetHint")}</small>\n                <textarea id="${y.he.META_PROMPT}" class="text_pole textarea_compact" rows="10" readonly></textarea>\n              </label>\n              <div class="preset-edit-actions">\n                <button id="${y.he.META_PROMPT_PRESET_SAVE}" class="menu_button">\n                  <i class="fa-solid fa-save"></i> ${(0,D.t)("settings.save")}\n                </button>\n                <button id="${y.he.META_PROMPT_PRESET_SAVE_AS}" class="menu_button">\n                  <i class="fa-solid fa-copy"></i> ${(0,D.t)("settings.saveAs")}\n                </button>\n                <button id="${y.he.META_PROMPT_PRESET_CANCEL}" class="menu_button">\n                  <i class="fa-solid fa-times"></i> ${(0,D.t)("settings.cancel")}\n                </button>\n              </div>\n            </div>\n\n            <div id="${y.he.PRESET_VIEWER}" class="preset-content-preview">\n              <label>${(0,D.t)("settings.presetContentPreview")}</label>\n              <pre id="${y.he.PRESET_PREVIEW}" class="preset-preview-text"></pre>\n            </div>\n\n            <div id="${y.he.PATTERN_VALIDATION_STATUS}" class="pattern-validation-status">\n              \x3c!-- Validation status will be populated by JavaScript --\x3e\n            </div>\n          </div>\n\n          <hr>\n\n          <label class="checkbox_label" for="${y.he.STREAMING_ENABLED}">\n            <input id="${y.he.STREAMING_ENABLED}" type="checkbox" />\n            <span>${(0,D.t)("settings.streamingEnabled")}</span>\n            <small>${(0,D.t)("settings.streamingEnabledDesc")}</small>\n          </label>\n\n          <label for="${y.he.STREAMING_POLL_INTERVAL}">\n            <span>${(0,D.t)("settings.streamingPollInterval")}</span>\n            <small>${(0,D.t)("settings.streamingPollIntervalDesc")}</small>\n            <input id="${y.he.STREAMING_POLL_INTERVAL}" class="text_pole" type="number" min="${y.BB.MIN}" max="${y.BB.MAX}" step="${y.BB.STEP}" />\n          </label>\n\n          <label for="${y.he.MAX_CONCURRENT}">\n            <span>${(0,D.t)("settings.maxConcurrent")}</span>\n            <small>${(0,D.t)("settings.maxConcurrentDesc")}</small>\n            <input id="${y.he.MAX_CONCURRENT}" class="text_pole" type="number" min="${y.zY.MIN}" max="${y.zY.MAX}" step="${y.zY.STEP}" />\n          </label>\n\n          <label for="${y.he.MIN_GENERATION_INTERVAL}">\n            <span>${(0,D.t)("settings.minGenerationInterval")}</span>\n            <small>${(0,D.t)("settings.minGenerationIntervalDesc")}</small>\n            <input id="${y.he.MIN_GENERATION_INTERVAL}" class="text_pole" type="number" min="${y.uF.MIN}" max="${y.uF.MAX}" step="${y.uF.STEP}" />\n          </label>\n\n          <label for="${y.he.PROMPT_PATTERNS}">\n            <span>${(0,D.t)("settings.promptPatterns")}</span>\n            <small>${(0,D.t)("settings.promptPatternsDesc")}</small>\n            <div style="display: flex; gap: 0.5rem; align-items: flex-start;">\n              <textarea id="${y.he.PROMPT_PATTERNS}" class="text_pole textarea_compact" rows="5" style="flex: 1;"></textarea>\n              <button id="${y.he.PROMPT_PATTERNS_RESET}" class="menu_button menu_button_icon" title="${(0,D.t)("settings.promptPatternsReset")}">\n                <i class="fa-solid fa-undo"></i>\n              </button>\n            </div>\n          </label>\n\n          <label for="${y.he.COMMON_STYLE_TAGS}">\n            <span>${(0,D.t)("settings.commonStyleTags")}</span>\n            <small>${(0,D.t)("settings.commonStyleTagsDesc")}</small>\n            <textarea id="${y.he.COMMON_STYLE_TAGS}" class="text_pole textarea_compact" rows="3" placeholder="${(0,D.t)("settings.commonStyleTagsPlaceholder")}"></textarea>\n          </label>\n\n          <label for="${y.he.COMMON_STYLE_TAGS_POSITION}">\n            <span>${(0,D.t)("settings.commonStyleTagsPosition")}</span>\n            <select id="${y.he.COMMON_STYLE_TAGS_POSITION}" class="text_pole">\n              <option value="prefix">${(0,D.t)("settings.commonStyleTagsPrefix")}</option>\n              <option value="suffix">${(0,D.t)("settings.commonStyleTagsSuffix")}</option>\n            </select>\n          </label>\n\n          <label for="${y.he.MANUAL_GEN_MODE}">\n            <span>${(0,D.t)("settings.manualGenerationMode")}</span>\n            <small>${(0,D.t)("settings.manualGenerationModeDesc")}</small>\n            <select id="${y.he.MANUAL_GEN_MODE}" class="text_pole">\n              <option value="append">${(0,D.t)("settings.manualGenerationModeAppend")}</option>\n              <option value="replace">${(0,D.t)("settings.manualGenerationModeReplace")}</option>\n            </select>\n          </label>\n\n          <label for="${y.he.LOG_LEVEL}">\n            <span>${(0,D.t)("settings.logLevel")}</span>\n            <small>${(0,D.t)("settings.logLevelDesc")}</small>\n            <select id="${y.he.LOG_LEVEL}" class="text_pole">\n              <option value="trace">${(0,D.t)("settings.logLevel.trace")}</option>\n              <option value="debug">${(0,D.t)("settings.logLevel.debug")}</option>\n              <option value="info">${(0,D.t)("settings.logLevel.info")}</option>\n              <option value="warn">${(0,D.t)("settings.logLevel.warn")}</option>\n              <option value="error">${(0,D.t)("settings.logLevel.error")}</option>\n              <option value="silent">${(0,D.t)("settings.logLevel.silent")}</option>\n            </select>\n          </label>\n        </div>\n      </div>\n    </div>\n  `.trim();a.insertAdjacentHTML("beforeend",e);const t=document.getElementById(y.he.ENABLED),n=document.getElementById(y.he.META_PROMPT_PRESET_SELECT),r=document.getElementById(y.he.META_PROMPT_PRESET_EDIT),i=document.getElementById(y.he.META_PROMPT_PRESET_SAVE),s=document.getElementById(y.he.META_PROMPT_PRESET_SAVE_AS),o=document.getElementById(y.he.META_PROMPT_PRESET_DELETE),l=document.getElementById(y.he.META_PROMPT_PRESET_CANCEL),c=document.getElementById(y.he.STREAMING_ENABLED),u=document.getElementById(y.he.STREAMING_POLL_INTERVAL),d=document.getElementById(y.he.MAX_CONCURRENT),p=document.getElementById(y.he.MIN_GENERATION_INTERVAL),m=document.getElementById(y.he.LOG_LEVEL),g=document.getElementById(y.he.PROMPT_PATTERNS),h=document.getElementById(y.he.PROMPT_PATTERNS_RESET),_=document.getElementById(y.he.COMMON_STYLE_TAGS),f=document.getElementById(y.he.COMMON_STYLE_TAGS_POSITION),v=document.getElementById(y.he.MANUAL_GEN_MODE),b=document.getElementById(y.he.RESET_BUTTON);t?.addEventListener("change",_e),n?.addEventListener("change",ye),r?.addEventListener("click",be),i?.addEventListener("click",Ee),s?.addEventListener("click",we),o?.addEventListener("click",ke),l?.addEventListener("click",xe),c?.addEventListener("change",_e),u?.addEventListener("change",_e),d?.addEventListener("change",_e),p?.addEventListener("change",_e),m?.addEventListener("change",_e),g?.addEventListener("change",_e),h?.addEventListener("click",ve),_?.addEventListener("change",_e),f?.addEventListener("change",_e),v?.addEventListener("change",_e),b?.addEventListener("click",fe),me()}ee.info("Extension initialized successfully");const l=te.eventTypes.CHAT_CHANGED;te.eventSource.on(l,(()=>{ee.info("CHAT_CHANGED - reloading settings"),ne=q(te),(0,_.He)(ne.logLevel),(0,h.xn)(ne.maxConcurrentGenerations),(0,h.Hl)(ne.minGenerationInterval),me(),setTimeout((()=>{Re(),Q(te,ne)}),100)})),Re(),Q(te,ne)}()})()})();
\ No newline at end of file
+(()=>{var __webpack_modules__={741:(e,t,n)=>{"use strict";var r,i,s;s=n(735),i=n(813),r=function(){class e{constructor(e={}){this.options=e,s.load(this.options,this.defaults,this),this.Events=new i(this),this._arr=[],this._resetPromise(),this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise(((e,t)=>this._resolve=e))}_flush(){return clearTimeout(this._timeout),this._lastFlush=Date.now(),this._resolve(),this.Events.trigger("batch",this._arr),this._arr=[],this._resetPromise()}add(e){var t;return this._arr.push(e),t=this._promise,this._arr.length===this.maxSize?this._flush():null!=this.maxTime&&1===this._arr.length&&(this._timeout=setTimeout((()=>this._flush()),this.maxTime)),t}}return e.prototype.defaults={maxTime:null,maxSize:null,Promise},e}.call(void 0),e.exports=r},403:(e,t,n)=>{"use strict";function r(e,t){return o(e)||function(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}(e,t)||s()}function i(e){return o(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||s()}function s(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e){if(Array.isArray(e))return e}function a(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function l(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function o(e){a(s,r,i,o,l,"next",e)}function l(e){a(s,r,i,o,l,"throw",e)}o(void 0)}))}}var c,u,d,p,m,g,h,f,_,v=[].splice;_=n(735),m=n(324),d=n(985),p=n(44),g=n(960),u=n(813),h=n(274),f=n(663),c=function(){class e{constructor(t={},...n){var r,i;this._addToQueue=this._addToQueue.bind(this),this._validateOptions(t,n),_.load(t,this.instanceDefaults,this),this._queues=new m(10),this._scheduled={},this._states=new h(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[])),this._limiter=null,this.Events=new u(this),this._submitLock=new f("submit",this.Promise),this._registerLock=new f("register",this.Promise),i=_.load(t,this.storeDefaults,{}),this._store=function(){if("redis"===this.datastore||"ioredis"===this.datastore||null!=this.connection)return r=_.load(t,this.redisStoreDefaults,{}),new g(this,i,r);if("local"===this.datastore)return r=_.load(t,this.localStoreDefaults,{}),new p(this,i,r);throw new e.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}.call(this),this._queues.on("leftzero",(()=>{var e;return null!=(e=this._store.heartbeat)&&"function"==typeof e.ref?e.ref():void 0})),this._queues.on("zero",(()=>{var e;return null!=(e=this._store.heartbeat)&&"function"==typeof e.unref?e.unref():void 0}))}_validateOptions(t,n){if(null==t||"object"!=typeof t||0!==n.length)throw new e.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(e){return this._store.__publish__(e)}disconnect(e=!0){return this._store.__disconnect__(e)}chain(e){return this._limiter=e,this}queued(e){return this._queues.queued(e)}clusterQueued(){return this._store.__queued__()}empty(){return 0===this.queued()&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(e){return this._states.jobStatus(e)}jobs(e){return this._states.statusJobs(e)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(e=1){return this._store.__check__(e)}_clearGlobalState(e){return null!=this._scheduled[e]&&(clearTimeout(this._scheduled[e].expiration),delete this._scheduled[e],!0)}_free(e,t,n,r){var i=this;return l((function*(){var t,s;try{if(s=(yield i._store.__free__(e,n.weight)).running,i.Events.trigger("debug",`Freed ${n.id}`,r),0===s&&i.empty())return i.Events.trigger("idle")}catch(e){return t=e,i.Events.trigger("error",t)}}))()}_run(e,t,n){var r,i,s;return t.doRun(),r=this._clearGlobalState.bind(this,e),s=this._run.bind(this,e,t),i=this._free.bind(this,e,t),this._scheduled[e]={timeout:setTimeout((()=>t.doExecute(this._limiter,r,s,i)),n),expiration:null!=t.options.expiration?setTimeout((function(){return t.doExpire(r,s,i)}),n+t.options.expiration):void 0,job:t}}_drainOne(e){return this._registerLock.schedule((()=>{var t,n,r,i,s;if(0===this.queued())return this.Promise.resolve(null);s=this._queues.getFirst();var o=r=s.first();return i=o.options,t=o.args,null!=e&&i.weight>e?this.Promise.resolve(null):(this.Events.trigger("debug",`Draining ${i.id}`,{args:t,options:i}),n=this._randomIndex(),this._store.__register__(n,i.weight,i.expiration).then((({success:e,wait:o,reservoir:a})=>{var l;return this.Events.trigger("debug",`Drained ${i.id}`,{success:e,args:t,options:i}),e?(s.shift(),(l=this.empty())&&this.Events.trigger("empty"),0===a&&this.Events.trigger("depleted",l),this._run(n,r,o),this.Promise.resolve(i.weight)):this.Promise.resolve(null)})))}))}_drainAll(e,t=0){return this._drainOne(e).then((n=>{var r;return null!=n?(r=null!=e?e-n:e,this._drainAll(r,t+n)):this.Promise.resolve(t)})).catch((e=>this.Events.trigger("error",e)))}_dropAllQueued(e){return this._queues.shiftAll((function(t){return t.doDrop({message:e})}))}stop(t={}){var n,r;return t=_.load(t,this.stopDefaults),r=e=>{var t;return t=()=>{var t;return(t=this._states.counts)[0]+t[1]+t[2]+t[3]===e},new this.Promise(((e,n)=>t()?e():this.on("done",(()=>{if(t())return this.removeAllListeners("done"),e()}))))},n=t.dropWaitingJobs?(this._run=function(e,n){return n.doDrop({message:t.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule((()=>this._submitLock.schedule((()=>{var e,n,i;for(e in n=this._scheduled)i=n[e],"RUNNING"===this.jobStatus(i.job.options.id)&&(clearTimeout(i.timeout),clearTimeout(i.expiration),i.job.doDrop({message:t.dropErrorMessage}));return this._dropAllQueued(t.dropErrorMessage),r(0)}))))):this.schedule({priority:9,weight:0},(()=>r(1))),this._receive=function(n){return n._reject(new e.prototype.BottleneckError(t.enqueueErrorMessage))},this.stop=()=>this.Promise.reject(new e.prototype.BottleneckError("stop() has already been called")),n}_addToQueue(t){var n=this;return l((function*(){var r,i,s,o,a,l,c;r=t.args,o=t.options;try{var u=yield n._store.__submit__(n.queued(),o.weight);a=u.reachedHWM,i=u.blocked,c=u.strategy}catch(e){return s=e,n.Events.trigger("debug",`Could not queue ${o.id}`,{args:r,options:o,error:s}),t.doDrop({error:s}),!1}return i?(t.doDrop(),!0):a&&(null!=(l=c===e.prototype.strategy.LEAK?n._queues.shiftLastFrom(o.priority):c===e.prototype.strategy.OVERFLOW_PRIORITY?n._queues.shiftLastFrom(o.priority+1):c===e.prototype.strategy.OVERFLOW?t:void 0)&&l.doDrop(),null==l||c===e.prototype.strategy.OVERFLOW)?(null==l&&t.doDrop(),a):(t.doQueue(a,i),n._queues.push(t),yield n._drainAll(),a)}))()}_receive(t){return null!=this._states.jobStatus(t.options.id)?(t._reject(new e.prototype.BottleneckError(`A job with the same id already exists (id=${t.options.id})`)),!1):(t.doReceive(),this._submitLock.schedule(this._addToQueue,t))}submit(...e){var t,n,s,o,a,l,c,u,p;"function"==typeof e[0]?(l=i(e),n=l[0],e=l.slice(1),c=r(v.call(e,-1),1),t=c[0],o=_.load({},this.jobDefaults)):(o=(u=i(e))[0],n=u[1],e=u.slice(2),p=r(v.call(e,-1),1),t=p[0],o=_.load(o,this.jobDefaults));return a=(...e)=>new this.Promise((function(t,r){return n(...e,(function(...e){return(null!=e[0]?r:t)(e)}))})),(s=new d(a,e,o,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise)).promise.then((function(e){return"function"==typeof t?t(...e):void 0})).catch((function(e){return Array.isArray(e)?"function"==typeof t?t(...e):void 0:"function"==typeof t?t(e):void 0})),this._receive(s)}schedule(...e){var t,n,r;if("function"==typeof e[0]){var s=i(e);r=s[0],e=s.slice(1),n={}}else{var o=i(e);n=o[0],r=o[1],e=o.slice(2)}return t=new d(r,e,n,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),this._receive(t),t.promise}wrap(e){var t,n;return t=this.schedule.bind(this),(n=function(...n){return t(e.bind(this),...n)}).withOptions=function(n,...r){return t(n,e,...r)},n}updateSettings(e={}){var t=this;return l((function*(){return yield t._store.__updateSettings__(_.overwrite(e,t.storeDefaults)),_.overwrite(e,t.instanceDefaults,t),t}))()}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(e=0){return this._store.__incrementReservoir__(e)}}return e.default=e,e.Events=u,e.version=e.prototype.version=n(349).r,e.strategy=e.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3},e.BottleneckError=e.prototype.BottleneckError=n(477),e.Group=e.prototype.Group=n(945),e.RedisConnection=e.prototype.RedisConnection=n(97),e.IORedisConnection=e.prototype.IORedisConnection=n(657),e.Batcher=e.prototype.Batcher=n(741),e.prototype.jobDefaults={priority:5,weight:1,expiration:null,id:"<no-id>"},e.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:e.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null},e.prototype.localStoreDefaults={Promise,timeout:null,heartbeatInterval:250},e.prototype.redisStoreDefaults={Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,Redis:null,clientOptions:{},clusterNodes:null,clearDatastore:!1,connection:null},e.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:!0,trackDoneStatus:!1,Promise},e.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:!0,dropErrorMessage:"This limiter has been stopped."},e}.call(void 0),e.exports=c},477:e=>{"use strict";var t;t=class extends Error{},e.exports=t},708:e=>{"use strict";var t;t=class{constructor(e,t){this.incr=e,this.decr=t,this._first=null,this._last=null,this.length=0}push(e){var t;this.length++,"function"==typeof this.incr&&this.incr(),t={value:e,prev:this._last,next:null},null!=this._last?(this._last.next=t,this._last=t):this._first=this._last=t}shift(){var e;if(null!=this._first)return this.length--,"function"==typeof this.decr&&this.decr(),e=this._first.value,null!=(this._first=this._first.next)?this._first.prev=null:this._last=null,e}first(){if(null!=this._first)return this._first.value}getArray(){var e,t,n;for(e=this._first,n=[];null!=e;)n.push((t=e,e=e.next,t.value));return n}forEachShift(e){var t;for(t=this.shift();null!=t;)e(t),t=this.shift()}debug(){var e,t,n,r,i;for(e=this._first,i=[];null!=e;)i.push((t=e,e=e.next,{value:t.value,prev:null!=(n=t.prev)?n.value:void 0,next:null!=(r=t.next)?r.value:void 0}));return i}},e.exports=t},813:e=>{"use strict";function t(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function n(e){return function(){var n=this,r=arguments;return new Promise((function(i,s){var o=e.apply(n,r);function a(e){t(o,i,s,a,l,"next",e)}function l(e){t(o,i,s,a,l,"throw",e)}a(void 0)}))}}var r;r=class{constructor(e){if(this.instance=e,this._events={},null!=this.instance.on||null!=this.instance.once||null!=this.instance.removeAllListeners)throw new Error("An Emitter already exists for this object");this.instance.on=(e,t)=>this._addListener(e,"many",t),this.instance.once=(e,t)=>this._addListener(e,"once",t),this.instance.removeAllListeners=(e=null)=>null!=e?delete this._events[e]:this._events={}}_addListener(e,t,n){var r;return null==(r=this._events)[e]&&(r[e]=[]),this._events[e].push({cb:n,status:t}),this.instance}listenerCount(e){return null!=this._events[e]?this._events[e].length:0}trigger(e,...t){var r=this;return n((function*(){var i,s;try{if("debug"!==e&&r.trigger("debug",`Event triggered: ${e}`,t),null==r._events[e])return;return r._events[e]=r._events[e].filter((function(e){return"none"!==e.status})),s=r._events[e].map(function(){var e=n((function*(e){var n,i;if("none"!==e.status){"once"===e.status&&(e.status="none");try{return"function"==typeof(null!=(i="function"==typeof e.cb?e.cb(...t):void 0)?i.then:void 0)?yield i:i}catch(e){return n=e,r.trigger("error",n),null}}}));return function(t){return e.apply(this,arguments)}}()),(yield Promise.all(s)).find((function(e){return null!=e}))}catch(e){return i=e,r.trigger("error",i),null}}))()}},e.exports=r},945:(e,t,n)=>{"use strict";function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function i(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function s(e){return function(){var t=this,n=arguments;return new Promise((function(r,s){var o=e.apply(t,n);function a(e){i(o,r,s,a,l,"next",e)}function l(e){i(o,r,s,a,l,"throw",e)}a(void 0)}))}}var o,a,l,c,u,d;d=n(735),o=n(813),c=n(97),l=n(657),u=n(618),a=function(){class e{constructor(e={}){this.deleteKey=this.deleteKey.bind(this),this.limiterOptions=e,d.load(this.limiterOptions,this.defaults,this),this.Events=new o(this),this.instances={},this.Bottleneck=n(403),this._startAutoCleanup(),this.sharedConnection=null!=this.connection,null==this.connection&&("redis"===this.limiterOptions.datastore?this.connection=new c(Object.assign({},this.limiterOptions,{Events:this.Events})):"ioredis"===this.limiterOptions.datastore&&(this.connection=new l(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(e=""){var t;return null!=(t=this.instances[e])?t:(()=>{var t;return t=this.instances[e]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${e}`,timeout:this.timeout,connection:this.connection})),this.Events.trigger("created",t,e),t})()}deleteKey(e=""){var t=this;return s((function*(){var n,r;return r=t.instances[e],t.connection&&(n=yield t.connection.__runCommand__(["del",...u.allKeys(`${t.id}-${e}`)])),null!=r&&(delete t.instances[e],yield r.disconnect()),null!=r||n>0}))()}limiters(){var e,t,n,r;for(e in n=[],t=this.instances)r=t[e],n.push({key:e,limiter:r});return n}keys(){return Object.keys(this.instances)}clusterKeys(){var e=this;return s((function*(){var t,n,i,s,o,a,l;if(null==e.connection)return e.Promise.resolve(e.keys());for(o=[],t=null,l=`b_${e.id}-`.length,9;0!==t;){var c=r(yield e.connection.__runCommand__(["scan",null!=t?t:0,"match",`b_${e.id}-*_settings`,"count",1e4]),2);for(t=~~c[0],i=0,a=(n=c[1]).length;i<a;i++)s=n[i],o.push(s.slice(l,-9))}return o}))()}_startAutoCleanup(){var e,t=this;return clearInterval(this.interval),"function"==typeof(e=this.interval=setInterval(s((function*(){var e,n,r,i,s,o;for(n in s=Date.now(),i=[],r=t.instances){o=r[n];try{(yield o._store.__groupCheck__(s))?i.push(t.deleteKey(n)):i.push(void 0)}catch(t){e=t,i.push(o.Events.trigger("error",e))}}return i})),this.timeout/2)).unref?e.unref():void 0}updateSettings(e={}){if(d.overwrite(e,this.defaults,this),d.overwrite(e,e,this.limiterOptions),null!=e.timeout)return this._startAutoCleanup()}disconnect(e=!0){var t;if(!this.sharedConnection)return null!=(t=this.connection)?t.disconnect(e):void 0}}return e.prototype.defaults={timeout:3e5,connection:null,Promise,id:"group-key"},e}.call(void 0),e.exports=a},657:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function o(e){asyncGeneratorStep(s,r,i,o,a,"next",e)}function a(e){asyncGeneratorStep(s,r,i,o,a,"throw",e)}o(void 0)}))}}var Events,IORedisConnection,Scripts,parser;parser=__webpack_require__(735),Events=__webpack_require__(813),Scripts=__webpack_require__(618),IORedisConnection=function(){class IORedisConnection{constructor(options={}){parser.load(options,this.defaults,this),null==this.Redis&&(this.Redis=eval("require")("ioredis")),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null!=this.clusterNodes?(this.client=new this.Redis.Cluster(this.clusterNodes,this.clientOptions),this.subscriber=new this.Redis.Cluster(this.clusterNodes,this.clientOptions)):null!=this.client&&null==this.client.duplicate?this.subscriber=new this.Redis.Cluster(this.client.startupNodes,this.client.options):(null==this.client&&(this.client=new this.Redis(this.clientOptions)),this.subscriber=this.client.duplicate()),this.limiters={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then((()=>(this._loadScripts(),{client:this.client,subscriber:this.subscriber})))}_setup(e,t){return e.setMaxListeners(0),new this.Promise(((n,r)=>(e.on("error",(e=>this.Events.trigger("error",e))),t&&e.on("message",((e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0})),"ready"===e.status?n():e.once("ready",n))))}_loadScripts(){return Scripts.names.forEach((e=>this.client.defineCommand(e,{lua:Scripts.payload(e)})))}__runCommand__(e){var t=this;return _asyncToGenerator((function*(){yield t.ready;var n=_slicedToArray(yield t.client.pipeline([e]).exec(),1),r=_slicedToArray(n[0],2);return r[0],r[1]}))()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map((t=>new this.Promise(((n,r)=>this.subscriber.subscribe(t,(()=>(this.limiters[t]=e,n()))))))))}__removeLimiter__(e){var t=this;return[e.channel(),e.channel_client()].forEach(function(){var e=_asyncToGenerator((function*(e){return t.terminated||(yield t.subscriber.unsubscribe(e)),delete t.limiters[e]}));return function(t){return e.apply(this,arguments)}}())}__scriptArgs__(e,t,n,r){var i;return[(i=Scripts.keys(e,t)).length].concat(i,n,r)}__scriptFn__(e){return this.client[e].bind(this.client)}disconnect(e=!0){var t,n,r,i;for(t=0,r=(i=Object.keys(this.limiters)).length;t<r;t++)n=i[t],clearInterval(this.limiters[n]._store.heartbeat);return this.limiters={},this.terminated=!0,e?this.Promise.all([this.client.quit(),this.subscriber.quit()]):(this.client.disconnect(),this.subscriber.disconnect(),this.Promise.resolve())}}return IORedisConnection.prototype.datastore="ioredis",IORedisConnection.prototype.defaults={Redis:null,clientOptions:{},clusterNodes:null,client:null,Promise,Events:null},IORedisConnection}.call(void 0),module.exports=IORedisConnection},985:(e,t,n)=>{"use strict";function r(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function i(e){return function(){var t=this,n=arguments;return new Promise((function(i,s){var o=e.apply(t,n);function a(e){r(o,i,s,a,l,"next",e)}function l(e){r(o,i,s,a,l,"throw",e)}a(void 0)}))}}var s,o,a;a=n(735),s=n(477),o=class{constructor(e,t,n,r,i,s,o,l){this.task=e,this.args=t,this.rejectOnDrop=i,this.Events=s,this._states=o,this.Promise=l,this.options=a.load(n,r),this.options.priority=this._sanitizePriority(this.options.priority),this.options.id===r.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`),this.promise=new this.Promise(((e,t)=>{this._resolve=e,this._reject=t})),this.retryCount=0}_sanitizePriority(e){var t;return(t=~~e!==e?5:e)<0?0:t>9?9:t}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error:e,message:t="This job has been dropped by Bottleneck"}={}){return!!this._states.remove(this.options.id)&&(this.rejectOnDrop&&this._reject(null!=e?e:new s(t)),this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise}),!0)}_assertStatus(e){var t;if((t=this._states.jobStatus(this.options.id))!==e&&("DONE"!==e||null!==t))throw new s(`Invalid job status ${t}, expected ${e}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){return this._states.start(this.options.id),this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(e,t){return this._assertStatus("RECEIVED"),this._states.next(this.options.id),this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM:e,blocked:t})}doRun(){return 0===this.retryCount?(this._assertStatus("QUEUED"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),this.Events.trigger("scheduled",{args:this.args,options:this.options})}doExecute(e,t,n,r){var s=this;return i((function*(){var i,o,a;0===s.retryCount?(s._assertStatus("RUNNING"),s._states.next(s.options.id)):s._assertStatus("EXECUTING"),o={args:s.args,options:s.options,retryCount:s.retryCount},s.Events.trigger("executing",o);try{if(a=yield null!=e?e.schedule(s.options,s.task,...s.args):s.task(...s.args),t())return s.doDone(o),yield r(s.options,o),s._assertStatus("DONE"),s._resolve(a)}catch(e){return i=e,s._onFailure(i,o,t,n,r)}}))()}doExpire(e,t,n){var r,i;return this._states.jobStatus("RUNNING"===this.options.id)&&this._states.next(this.options.id),this._assertStatus("EXECUTING"),i={args:this.args,options:this.options,retryCount:this.retryCount},r=new s(`This job timed out after ${this.options.expiration} ms.`),this._onFailure(r,i,e,t,n)}_onFailure(e,t,n,r,s){var o=this;return i((function*(){var i,a;if(n())return null!=(i=yield o.Events.trigger("failed",e,t))?(a=~~i,o.Events.trigger("retry",`Retrying ${o.options.id} after ${a} ms`,t),o.retryCount++,r(a)):(o.doDone(t),yield s(o.options,t),o._assertStatus("DONE"),o._reject(e))}))()}doDone(e){return this._assertStatus("EXECUTING"),this._states.next(this.options.id),this.Events.trigger("done",e)}},e.exports=o},44:(e,t,n)=>{"use strict";function r(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function i(e){return function(){var t=this,n=arguments;return new Promise((function(i,s){var o=e.apply(t,n);function a(e){r(o,i,s,a,l,"next",e)}function l(e){r(o,i,s,a,l,"throw",e)}a(void 0)}))}}var s,o,a;a=n(735),s=n(477),o=class{constructor(e,t,n){this.instance=e,this.storeOptions=t,this.clientId=this.instance._randomIndex(),a.load(n,n,this),this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now(),this._running=0,this._done=0,this._unblockTime=0,this.ready=this.Promise.resolve(),this.clients={},this._startHeartbeat()}_startHeartbeat(){var e;return null==this.heartbeat&&(null!=this.storeOptions.reservoirRefreshInterval&&null!=this.storeOptions.reservoirRefreshAmount||null!=this.storeOptions.reservoirIncreaseInterval&&null!=this.storeOptions.reservoirIncreaseAmount)?"function"==typeof(e=this.heartbeat=setInterval((()=>{var e,t,n,r,i;if(r=Date.now(),null!=this.storeOptions.reservoirRefreshInterval&&r>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval&&(this._lastReservoirRefresh=r,this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount,this.instance._drainAll(this.computeCapacity())),null!=this.storeOptions.reservoirIncreaseInterval&&r>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval){var s=this.storeOptions;if(e=s.reservoirIncreaseAmount,n=s.reservoirIncreaseMaximum,i=s.reservoir,this._lastReservoirIncrease=r,(t=null!=n?Math.min(e,n-i):e)>0)return this.storeOptions.reservoir+=t,this.instance._drainAll(this.computeCapacity())}}),this.heartbeatInterval)).unref?e.unref():void 0:clearInterval(this.heartbeat)}__publish__(e){var t=this;return i((function*(){return yield t.yieldLoop(),t.instance.Events.trigger("message",e.toString())}))()}__disconnect__(e){var t=this;return i((function*(){return yield t.yieldLoop(),clearInterval(t.heartbeat),t.Promise.resolve()}))()}yieldLoop(e=0){return new this.Promise((function(t,n){return setTimeout(t,e)}))}computePenalty(){var e;return null!=(e=this.storeOptions.penalty)?e:15*this.storeOptions.minTime||5e3}__updateSettings__(e){var t=this;return i((function*(){return yield t.yieldLoop(),a.overwrite(e,e,t.storeOptions),t._startHeartbeat(),t.instance._drainAll(t.computeCapacity()),!0}))()}__running__(){var e=this;return i((function*(){return yield e.yieldLoop(),e._running}))()}__queued__(){var e=this;return i((function*(){return yield e.yieldLoop(),e.instance.queued()}))()}__done__(){var e=this;return i((function*(){return yield e.yieldLoop(),e._done}))()}__groupCheck__(e){var t=this;return i((function*(){return yield t.yieldLoop(),t._nextRequest+t.timeout<e}))()}computeCapacity(){var e,t,n=this.storeOptions;return e=n.maxConcurrent,t=n.reservoir,null!=e&&null!=t?Math.min(e-this._running,t):null!=e?e-this._running:null!=t?t:null}conditionsCheck(e){var t;return null==(t=this.computeCapacity())||e<=t}__incrementReservoir__(e){var t=this;return i((function*(){var n;return yield t.yieldLoop(),n=t.storeOptions.reservoir+=e,t.instance._drainAll(t.computeCapacity()),n}))()}__currentReservoir__(){var e=this;return i((function*(){return yield e.yieldLoop(),e.storeOptions.reservoir}))()}isBlocked(e){return this._unblockTime>=e}check(e,t){return this.conditionsCheck(e)&&this._nextRequest-t<=0}__check__(e){var t=this;return i((function*(){var n;return yield t.yieldLoop(),n=Date.now(),t.check(e,n)}))()}__register__(e,t,n){var r=this;return i((function*(){var e,n;return yield r.yieldLoop(),e=Date.now(),r.conditionsCheck(t)?(r._running+=t,null!=r.storeOptions.reservoir&&(r.storeOptions.reservoir-=t),n=Math.max(r._nextRequest-e,0),r._nextRequest=e+n+r.storeOptions.minTime,{success:!0,wait:n,reservoir:r.storeOptions.reservoir}):{success:!1}}))()}strategyIsBlock(){return 3===this.storeOptions.strategy}__submit__(e,t){var n=this;return i((function*(){var r,i,o;if(yield n.yieldLoop(),null!=n.storeOptions.maxConcurrent&&t>n.storeOptions.maxConcurrent)throw new s(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${n.storeOptions.maxConcurrent}`);return i=Date.now(),o=null!=n.storeOptions.highWater&&e===n.storeOptions.highWater&&!n.check(t,i),(r=n.strategyIsBlock()&&(o||n.isBlocked(i)))&&(n._unblockTime=i+n.computePenalty(),n._nextRequest=n._unblockTime+n.storeOptions.minTime,n.instance._dropAllQueued()),{reachedHWM:o,blocked:r,strategy:n.storeOptions.strategy}}))()}__free__(e,t){var n=this;return i((function*(){return yield n.yieldLoop(),n._running-=t,n._done+=t,n.instance._drainAll(n.computeCapacity()),{running:n._running}}))()}},e.exports=o},324:(e,t,n)=>{"use strict";var r,i,s;r=n(708),i=n(813),s=class{constructor(e){this.Events=new i(this),this._length=0,this._lists=function(){var t,n,i;for(i=[],t=1,n=e;1<=n?t<=n:t>=n;1<=n?++t:--t)i.push(new r((()=>this.incr()),(()=>this.decr())));return i}.call(this)}incr(){if(0==this._length++)return this.Events.trigger("leftzero")}decr(){if(0==--this._length)return this.Events.trigger("zero")}push(e){return this._lists[e.options.priority].push(e)}queued(e){return null!=e?this._lists[e].length:this._length}shiftAll(e){return this._lists.forEach((function(t){return t.forEachShift(e)}))}getFirst(e=this._lists){var t,n,r;for(t=0,n=e.length;t<n;t++)if((r=e[t]).length>0)return r;return[]}shiftLastFrom(e){return this.getFirst(this._lists.slice(e).reverse()).shift()}},e.exports=s},97:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function o(e){asyncGeneratorStep(s,r,i,o,a,"next",e)}function a(e){asyncGeneratorStep(s,r,i,o,a,"throw",e)}o(void 0)}))}}var Events,RedisConnection,Scripts,parser;parser=__webpack_require__(735),Events=__webpack_require__(813),Scripts=__webpack_require__(618),RedisConnection=function(){class RedisConnection{constructor(options={}){parser.load(options,this.defaults,this),null==this.Redis&&(this.Redis=eval("require")("redis")),null==this.Events&&(this.Events=new Events(this)),this.terminated=!1,null==this.client&&(this.client=this.Redis.createClient(this.clientOptions)),this.subscriber=this.client.duplicate(),this.limiters={},this.shas={},this.ready=this.Promise.all([this._setup(this.client,!1),this._setup(this.subscriber,!0)]).then((()=>this._loadScripts())).then((()=>({client:this.client,subscriber:this.subscriber})))}_setup(e,t){return e.setMaxListeners(0),new this.Promise(((n,r)=>(e.on("error",(e=>this.Events.trigger("error",e))),t&&e.on("message",((e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0})),e.ready?n():e.once("ready",n))))}_loadScript(e){return new this.Promise(((t,n)=>{var r;return r=Scripts.payload(e),this.client.multi([["script","load",r]]).exec(((r,i)=>null!=r?n(r):(this.shas[e]=i[0],t(i[0]))))}))}_loadScripts(){return this.Promise.all(Scripts.names.map((e=>this._loadScript(e))))}__runCommand__(e){var t=this;return _asyncToGenerator((function*(){return yield t.ready,new t.Promise(((n,r)=>t.client.multi([e]).exec_atomic((function(e,t){return null!=e?r(e):n(t[0])}))))}))()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map((t=>new this.Promise(((n,r)=>{var i;return i=r=>{if(r===t)return this.subscriber.removeListener("subscribe",i),this.limiters[t]=e,n()},this.subscriber.on("subscribe",i),this.subscriber.subscribe(t)})))))}__removeLimiter__(e){var t=this;return this.Promise.all([e.channel(),e.channel_client()].map(function(){var e=_asyncToGenerator((function*(e){return t.terminated||(yield new t.Promise(((n,r)=>t.subscriber.unsubscribe(e,(function(t,i){return null!=t?r(t):i===e?n():void 0}))))),delete t.limiters[e]}));return function(t){return e.apply(this,arguments)}}()))}__scriptArgs__(e,t,n,r){var i;return i=Scripts.keys(e,t),[this.shas[e],i.length].concat(i,n,r)}__scriptFn__(e){return this.client.evalsha.bind(this.client)}disconnect(e=!0){var t,n,r,i;for(t=0,r=(i=Object.keys(this.limiters)).length;t<r;t++)n=i[t],clearInterval(this.limiters[n]._store.heartbeat);return this.limiters={},this.terminated=!0,this.client.end(e),this.subscriber.end(e),this.Promise.resolve()}}return RedisConnection.prototype.datastore="redis",RedisConnection.prototype.defaults={Redis:null,clientOptions:{},client:null,Promise,Events:null},RedisConnection}.call(void 0),module.exports=RedisConnection},960:(e,t,n)=>{"use strict";function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw s}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function i(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function s(e){return function(){var t=this,n=arguments;return new Promise((function(r,s){var o=e.apply(t,n);function a(e){i(o,r,s,a,l,"next",e)}function l(e){i(o,r,s,a,l,"throw",e)}a(void 0)}))}}var o,a,l,c,u;u=n(735),o=n(477),l=n(97),a=n(657),c=class{constructor(e,t,n){this.instance=e,this.storeOptions=t,this.originalId=this.instance.id,this.clientId=this.instance._randomIndex(),u.load(n,n,this),this.clients={},this.capacityPriorityCounters={},this.sharedConnection=null!=this.connection,null==this.connection&&(this.connection="redis"===this.instance.datastore?new l({Redis:this.Redis,clientOptions:this.clientOptions,Promise:this.Promise,Events:this.instance.Events}):"ioredis"===this.instance.datastore?new a({Redis:this.Redis,clientOptions:this.clientOptions,clusterNodes:this.clusterNodes,Promise:this.Promise,Events:this.instance.Events}):void 0),this.instance.connection=this.connection,this.instance.datastore=this.connection.datastore,this.ready=this.connection.ready.then((e=>(this.clients=e,this.runScript("init",this.prepareInitSettings(this.clearDatastore))))).then((()=>this.connection.__addLimiter__(this.instance))).then((()=>this.runScript("register_client",[this.instance.queued()]))).then((()=>{var e;return"function"==typeof(e=this.heartbeat=setInterval((()=>this.runScript("heartbeat",[]).catch((e=>this.instance.Events.trigger("error",e)))),this.heartbeatInterval)).unref&&e.unref(),this.clients}))}__publish__(e){var t=this;return s((function*(){return(yield t.ready).client.publish(t.instance.channel(),`message:${e.toString()}`)}))()}onMessage(e,t){var n=this;return s((function*(){var e,i,o,a,l,c,u,d,p,m;try{u=t.indexOf(":");var g=[t.slice(0,u),t.slice(u+1)];if(o=g[1],"capacity"===(m=g[0]))return yield n.instance._drainAll(o.length>0?~~o:void 0);if("capacity-priority"===m){var h=r(o.split(":"),3);return p=h[0],d=h[1],i=h[2],e=p.length>0?~~p:void 0,d===n.clientId?(a=yield n.instance._drainAll(e),c=null!=e?e-(a||0):"",yield n.clients.client.publish(n.instance.channel(),`capacity-priority:${c}::${i}`)):""===d?(clearTimeout(n.capacityPriorityCounters[i]),delete n.capacityPriorityCounters[i],n.instance._drainAll(e)):n.capacityPriorityCounters[i]=setTimeout(s((function*(){var t;try{return delete n.capacityPriorityCounters[i],yield n.runScript("blacklist_client",[d]),yield n.instance._drainAll(e)}catch(e){return t=e,n.instance.Events.trigger("error",t)}})),1e3)}if("message"===m)return n.instance.Events.trigger("message",o);if("blocked"===m)return yield n.instance._dropAllQueued()}catch(e){return l=e,n.instance.Events.trigger("error",l)}}))()}__disconnect__(e){return clearInterval(this.heartbeat),this.sharedConnection?this.connection.__removeLimiter__(this.instance):this.connection.disconnect(e)}runScript(e,t){var n=this;return s((function*(){return"init"!==e&&"register_client"!==e&&(yield n.ready),new n.Promise(((r,i)=>{var s,o;return s=[Date.now(),n.clientId].concat(t),n.instance.Events.trigger("debug",`Calling Redis script: ${e}.lua`,s),o=n.connection.__scriptArgs__(e,n.originalId,s,(function(e,t){return null!=e?i(e):r(t)})),n.connection.__scriptFn__(e)(...o)})).catch((r=>"SETTINGS_KEY_NOT_FOUND"===r.message?"heartbeat"===e?n.Promise.resolve():n.runScript("init",n.prepareInitSettings(!1)).then((()=>n.runScript(e,t))):"UNKNOWN_CLIENT"===r.message?n.runScript("register_client",[n.instance.queued()]).then((()=>n.runScript(e,t))):n.Promise.reject(r)))}))()}prepareArray(e){var t,n,r,i;for(r=[],t=0,n=e.length;t<n;t++)i=e[t],r.push(null!=i?i.toString():"");return r}prepareObject(e){var t,n,r;for(n in t=[],e)r=e[n],t.push(n,null!=r?r.toString():"");return t}prepareInitSettings(e){var t;return(t=this.prepareObject(Object.assign({},this.storeOptions,{id:this.originalId,version:this.instance.version,groupTimeout:this.timeout,clientTimeout:this.clientTimeout}))).unshift(e?1:0,this.instance.version),t}convertBool(e){return!!e}__updateSettings__(e){var t=this;return s((function*(){return yield t.runScript("update_settings",t.prepareObject(e)),u.overwrite(e,e,t.storeOptions)}))()}__running__(){return this.runScript("running",[])}__queued__(){return this.runScript("queued",[])}__done__(){return this.runScript("done",[])}__groupCheck__(){var e=this;return s((function*(){return e.convertBool(yield e.runScript("group_check",[]))}))()}__incrementReservoir__(e){return this.runScript("increment_reservoir",[e])}__currentReservoir__(){return this.runScript("current_reservoir",[])}__check__(e){var t=this;return s((function*(){return t.convertBool(yield t.runScript("check",t.prepareArray([e])))}))()}__register__(e,t,n){var i=this;return s((function*(){var s,o,a,l=r(yield i.runScript("register",i.prepareArray([e,t,n])),3);return o=l[0],a=l[1],s=l[2],{success:i.convertBool(o),wait:a,reservoir:s}}))()}__submit__(e,t){var n=this;return s((function*(){var i,s,a,l,c;try{var u=r(yield n.runScript("submit",n.prepareArray([e,t])),3);return l=u[0],i=u[1],c=u[2],{reachedHWM:n.convertBool(l),blocked:n.convertBool(i),strategy:c}}catch(e){if(0===(s=e).message.indexOf("OVERWEIGHT")){var d=r(s.message.split(":"),3);throw d[0],t=d[1],a=d[2],new o(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${a}`)}throw s}}))()}__free__(e,t){var n=this;return s((function*(){return{running:yield n.runScript("free",n.prepareArray([e]))}}))()}},e.exports=c},618:(e,t,n)=>{"use strict";var r,i,s;i=n(495),r={refs:i["refs.lua"],validate_keys:i["validate_keys.lua"],validate_client:i["validate_client.lua"],refresh_expiration:i["refresh_expiration.lua"],process_tick:i["process_tick.lua"],conditions_check:i["conditions_check.lua"],get_time:i["get_time.lua"]},t.allKeys=function(e){return[`b_${e}_settings`,`b_${e}_job_weights`,`b_${e}_job_expirations`,`b_${e}_job_clients`,`b_${e}_client_running`,`b_${e}_client_num_queued`,`b_${e}_client_last_registered`,`b_${e}_client_last_seen`]},s={init:{keys:t.allKeys,headers:["process_tick"],refresh_expiration:!0,code:i["init.lua"]},group_check:{keys:t.allKeys,headers:[],refresh_expiration:!1,code:i["group_check.lua"]},register_client:{keys:t.allKeys,headers:["validate_keys"],refresh_expiration:!1,code:i["register_client.lua"]},blacklist_client:{keys:t.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:i["blacklist_client.lua"]},heartbeat:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["heartbeat.lua"]},update_settings:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:i["update_settings.lua"]},running:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["running.lua"]},queued:{keys:t.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:!1,code:i["queued.lua"]},done:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["done.lua"]},check:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!1,code:i["check.lua"]},submit:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:i["submit.lua"]},register:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:!0,code:i["register.lua"]},free:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:i["free.lua"]},current_reservoir:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!1,code:i["current_reservoir.lua"]},increment_reservoir:{keys:t.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:!0,code:i["increment_reservoir.lua"]}},t.names=Object.keys(s),t.keys=function(e,t){return s[e].keys(t)},t.payload=function(e){var t;return t=s[e],Array.prototype.concat(r.refs,t.headers.map((function(e){return r[e]})),t.refresh_expiration?r.refresh_expiration:"",t.code).join("\n")}},274:(e,t,n)=>{"use strict";var r,i;r=n(477),i=class{constructor(e){this.status=e,this._jobs={},this.counts=this.status.map((function(){return 0}))}next(e){var t,n;return n=(t=this._jobs[e])+1,null!=t&&n<this.status.length?(this.counts[t]--,this.counts[n]++,this._jobs[e]++):null!=t?(this.counts[t]--,delete this._jobs[e]):void 0}start(e){return 0,this._jobs[e]=0,this.counts[0]++}remove(e){var t;return null!=(t=this._jobs[e])&&(this.counts[t]--,delete this._jobs[e]),null!=t}jobStatus(e){var t;return null!=(t=this.status[this._jobs[e]])?t:null}statusJobs(e){var t,n,i,s;if(null!=e){if((n=this.status.indexOf(e))<0)throw new r(`status must be one of ${this.status.join(", ")}`);for(t in s=[],i=this._jobs)i[t]===n&&s.push(t);return s}return Object.keys(this._jobs)}statusCounts(){return this.counts.reduce(((e,t,n)=>(e[this.status[n]]=t,e)),{})}},e.exports=i},663:(e,t,n)=>{"use strict";function r(e,t,n,r,i,s,o){try{var a=e[s](o),l=a.value}catch(e){return void n(e)}a.done?t(l):Promise.resolve(l).then(r,i)}function i(e){return function(){var t=this,n=arguments;return new Promise((function(i,s){var o=e.apply(t,n);function a(e){r(o,i,s,a,l,"next",e)}function l(e){r(o,i,s,a,l,"throw",e)}a(void 0)}))}}var s,o;s=n(708),o=class{constructor(e,t){this.schedule=this.schedule.bind(this),this.name=e,this.Promise=t,this._running=0,this._queue=new s}isEmpty(){return 0===this._queue.length}_tryToRun(){var e=this;return i((function*(){var t,n,r,s,o,a,l;if(e._running<1&&e._queue.length>0){e._running++;var c=e._queue.shift();return l=c.task,t=c.args,o=c.resolve,s=c.reject,n=yield i((function*(){try{return a=yield l(...t),function(){return o(a)}}catch(e){return r=e,function(){return s(r)}}}))(),e._running--,e._tryToRun(),n()}}))()}schedule(e,...t){var n,r,i;return i=r=null,n=new this.Promise((function(e,t){return i=e,r=t})),this._queue.push({task:e,args:t,resolve:i,reject:r}),this._tryToRun(),n}},e.exports=o},390:(e,t,n)=>{"use strict";e.exports=n(403)},735:(e,t)=>{"use strict";t.load=function(e,t,n={}){var r,i,s;for(r in t)s=t[r],n[r]=null!=(i=e[r])?i:s;return n},t.overwrite=function(e,t,n={}){var r,i;for(r in e)i=e[r],void 0!==t[r]&&(n[r]=i);return n}},208:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(601),i=n.n(r),s=n(314),o=n.n(s)()(i());o.push([e.id,"/* Clickable AI-generated images */\n.mes_text img[title^='AI generated image'] {\n  cursor: pointer;\n  transition:\n    opacity 0.2s,\n    transform 0.2s,\n    box-shadow 0.2s;\n}\n\n.mes_text img[title^='AI generated image']:hover {\n  opacity: 0.85;\n  transform: scale(1.02);\n  box-shadow: 0 0 15px rgba(155, 89, 182, 0.6);\n}\n\n/* Image generation progress widget */\n/* Legacy per-message widget (deprecated) */\n.ai-img-progress-widget {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(155, 89, 182, 0.3);\n  border-radius: 4px;\n  margin-top: 0.5rem;\n  font-size: 0.9rem;\n  color: #ffffff;\n  animation: fadeIn 0.3s ease-in;\n  backdrop-filter: blur(4px);\n}\n\n/* Global progress widget above user input */\n.ai-img-progress-widget-global {\n  /* Use sticky positioning within #sheld for reliable visibility */\n  position: sticky;\n  bottom: 0;\n  /* Use margin auto for centering instead of left+transform with sticky */\n  margin-left: auto;\n  margin-right: auto;\n  margin-bottom: 0.5rem;\n  z-index: 100;\n  pointer-events: auto;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  gap: 0.75rem;\n  padding: 0.75rem 1.5rem;\n  min-width: 200px;\n  min-height: 40px;\n  background: rgba(0, 0, 0, 0.85);\n  border: 1px solid rgba(155, 89, 182, 0.5);\n  border-radius: 6px;\n  font-size: 0.9rem;\n  color: #ffffff;\n  animation: fadeIn 0.3s ease-in;\n  backdrop-filter: blur(8px);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  max-width: 90%;\n}\n\n.ai-img-progress-text-container {\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n  flex: 1;\n  min-width: 150px;\n}\n\n.ai-img-progress-spinner {\n  width: 16px;\n  height: 16px;\n  min-width: 16px;\n  min-height: 16px;\n  border: 2px solid rgba(255, 255, 255, 0.3);\n  border-top-color: #9b59b6;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n  flex-shrink: 0;\n}\n\n.ai-img-progress-text {\n  flex: 1;\n  white-space: nowrap;\n  line-height: 1.4;\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    transform: translateY(-5px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n/* Mobile optimizations for progress widget */\n@media (max-width: 768px) {\n  .ai-img-progress-widget {\n    font-size: 0.85rem;\n    padding: 0.4rem 0.8rem;\n  }\n\n  .ai-img-progress-widget-global {\n    font-size: 0.85rem;\n    padding: 0.6rem 1.2rem;\n    bottom: 100px;\n  }\n\n  .ai-img-progress-spinner {\n    width: 14px;\n    height: 14px;\n  }\n}\n\n/* Preset Management Styles */\n.preset-management {\n  margin: 1rem 0;\n}\n\n.preset-toolbar {\n  display: flex;\n  gap: 0.5rem;\n  align-items: center;\n  margin-bottom: 0.5rem;\n}\n\n.preset-toolbar .flex_fill {\n  flex: 1;\n}\n\n.preset-toolbar button {\n  flex-shrink: 0;\n}\n\n.preset-toolbar button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.preset-content-preview {\n  margin-top: 0.5rem;\n  padding: 0.75rem;\n  background-color: rgba(0, 0, 0, 0.1);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  border-radius: 4px;\n}\n\n.preset-content-preview label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: bold;\n  font-size: 0.9rem;\n}\n\n.preset-preview-text {\n  font-family: 'Courier New', Courier, monospace;\n  font-size: 0.85rem;\n  white-space: pre-wrap;\n  word-break: break-word;\n  max-height: 200px;\n  overflow-y: auto;\n  margin: 0;\n  padding: 0.5rem;\n  background-color: rgba(0, 0, 0, 0.2);\n  border-radius: 3px;\n}\n\n.preset-edit-actions {\n  display: flex;\n  gap: 0.5rem;\n  margin-top: 0.5rem;\n}\n\n.preset-edit-actions button {\n  flex: 1;\n}\n\n.preset-edit-actions button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Pattern Validation Status */\n.pattern-validation-status {\n  margin-top: 0.75rem;\n  padding: 0.75rem;\n  border-radius: 4px;\n  font-size: 0.9rem;\n  line-height: 1.5;\n}\n\n.pattern-validation-status.validation-success {\n  background-color: rgba(76, 175, 80, 0.1);\n  border: 1px solid rgba(76, 175, 80, 0.3);\n  color: #81c784;\n}\n\n.pattern-validation-status.validation-warning {\n  background-color: rgba(255, 152, 0, 0.1);\n  border: 1px solid rgba(255, 152, 0, 0.3);\n  color: #ffb74d;\n}\n\n.pattern-validation-status .validation-icon {\n  margin-right: 0.5rem;\n  font-weight: bold;\n}\n\n.pattern-validation-status .validation-message {\n  display: block;\n}\n\n.pattern-validation-status .validation-hint {\n  display: block;\n  margin-top: 0.5rem;\n  font-size: 0.85rem;\n  opacity: 0.8;\n}\n\n/* Manual Generation Button */\n.auto_illustrator_manual_gen {\n  color: #9b59b6 !important;\n  cursor: pointer;\n}\n\n.auto_illustrator_manual_gen:hover {\n  color: #bb79d6 !important;\n}\n\n.auto_illustrator_manual_gen:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n/* Manual Generation Dialog Backdrop */\n.auto-illustrator-dialog-backdrop {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.7);\n  z-index: 9999;\n}\n\n/* All dialogs (manual generation, regeneration, prompt update, confirmation) */\n.auto-illustrator-dialog {\n  position: fixed;\n  top: 10vh;\n  left: 50%;\n  transform: translateX(-50%);\n  background: var(--SmartThemeBlurTintColor, #2a2a2a);\n  border: 2px solid var(--SmartThemeBorderColor, #666);\n  border-radius: 8px;\n  padding: 1.5rem;\n  max-width: 500px;\n  max-height: 85vh;\n  width: 90%;\n  z-index: 10000;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);\n  color: #ffffff;\n  overflow-y: auto;\n  box-sizing: border-box;\n}\n\n/* Regeneration confirmation dialog - position lower for easier tapping */\n#auto_illustrator_regen_confirm_dialog {\n  top: 35vh;\n}\n\n/* Mobile optimizations */\n@media (max-width: 768px) {\n  .auto-illustrator-dialog {\n    width: 95%;\n    padding: 1rem;\n    top: 5vh;\n    max-height: 90vh;\n  }\n\n  #auto_illustrator_regen_confirm_dialog {\n    top: 30vh;\n  }\n\n  .auto-illustrator-dialog h3 {\n    font-size: 1rem;\n  }\n\n  .auto-illustrator-dialog p {\n    font-size: 0.9rem;\n  }\n}\n\n.auto-illustrator-dialog p {\n  margin: 0 0 1rem 0;\n  line-height: 1.6;\n  white-space: pre-line;\n  color: #ffffff;\n  font-size: 1rem;\n}\n\n.auto-illustrator-dialog h3 {\n  margin: 0 0 1rem 0;\n  color: #ffffff;\n  font-size: 1.2rem;\n}\n\n.auto-illustrator-dialog label {\n  display: block;\n  margin: 0.5rem 0 0.25rem 0;\n  color: #ffffff;\n  font-size: 0.9rem;\n}\n\n.auto-illustrator-dialog textarea {\n  width: 100%;\n  min-height: 80px;\n  padding: 0.5rem;\n  background: rgba(0, 0, 0, 0.3);\n  border: 1px solid var(--SmartThemeBorderColor, #666);\n  border-radius: 4px;\n  color: #ffffff;\n  font-family: inherit;\n  font-size: 0.9rem;\n  resize: vertical;\n  box-sizing: border-box;\n}\n\n.auto-illustrator-dialog textarea:focus {\n  outline: none;\n  border-color: #9b59b6;\n  background: rgba(0, 0, 0, 0.4);\n}\n\n.auto-illustrator-dialog textarea::placeholder {\n  color: rgba(255, 255, 255, 0.4);\n}\n\n.auto-illustrator-feedback-textarea {\n  margin-bottom: 0.5rem;\n}\n\n.auto-illustrator-mode-group {\n  margin: 1rem 0;\n  display: flex;\n  flex-direction: column;\n  gap: 0.75rem;\n}\n\n.auto-illustrator-mode-option {\n  display: flex;\n  align-items: flex-start;\n  gap: 0.75rem;\n  padding: 0.75rem;\n  border: 1px solid var(--SmartThemeBorderColor, #666);\n  border-radius: 4px;\n  cursor: pointer;\n  transition: background-color 0.2s;\n  color: #ffffff;\n  background: rgba(0, 0, 0, 0.2);\n}\n\n.auto-illustrator-mode-option span {\n  color: #ffffff;\n  line-height: 1.5;\n}\n\n.auto-illustrator-mode-option:hover {\n  background-color: rgba(255, 255, 255, 0.05);\n}\n\n.auto-illustrator-mode-option input[type=\"radio\"] {\n  margin-top: 0.2rem;\n  cursor: pointer;\n  flex-shrink: 0;\n}\n\n.auto-illustrator-mode-option span {\n  flex: 1;\n  line-height: 1.4;\n}\n\n.auto-illustrator-mode-option strong {\n  display: block;\n  margin-bottom: 0.25rem;\n}\n\n.auto-illustrator-dialog-buttons {\n  display: flex;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  margin-top: 1.5rem;\n  flex-wrap: wrap;\n}\n\n.auto-illustrator-dialog-buttons button {\n  min-width: 100px;\n  flex: 1 1 auto;\n  white-space: nowrap;\n}\n\n/* Mobile button optimizations */\n@media (max-width: 768px) {\n  .auto-illustrator-dialog-buttons {\n    gap: 0.4rem;\n    margin-top: 1rem;\n  }\n\n  .auto-illustrator-dialog-buttons button {\n    min-width: 80px;\n    font-size: 0.9rem;\n    padding: 0.5rem 0.75rem;\n  }\n}",""]);const a=o},314:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var o={};if(r)for(var a=0;a<this.length;a++){var l=this[a][0];null!=l&&(o[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&o[u[0]]||(void 0!==s&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=s),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),i&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=i):u[4]="".concat(i)),t.push(u))}},t}},601:e=>{"use strict";e.exports=function(e){return e[1]}},65:function(e,t,n){var r,i;!function(s,o){"use strict";r=function(){var e=function(){},t="undefined",n=typeof window!==t&&typeof window.navigator!==t&&/Trident\/|MSIE /.test(window.navigator.userAgent),r=["trace","debug","info","warn","error"],i={},s=null;function o(e,t){var n=e[t];if("function"==typeof n.bind)return n.bind(e);try{return Function.prototype.bind.call(n,e)}catch(t){return function(){return Function.prototype.apply.apply(n,[e,arguments])}}}function a(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function l(r){return"debug"===r&&(r="log"),typeof console!==t&&("trace"===r&&n?a:void 0!==console[r]?o(console,r):void 0!==console.log?o(console,"log"):e)}function c(){for(var n=this.getLevel(),i=0;i<r.length;i++){var s=r[i];this[s]=i<n?e:this.methodFactory(s,n,this.name)}if(this.log=this.debug,typeof console===t&&n<this.levels.SILENT)return"No console available for logging"}function u(e){return function(){typeof console!==t&&(c.call(this),this[e].apply(this,arguments))}}function d(e,t,n){return l(e)||u.apply(this,arguments)}function p(e,n){var o,a,l,u=this,p="loglevel";function m(e){var n=(r[e]||"silent").toUpperCase();if(typeof window!==t&&p){try{return void(window.localStorage[p]=n)}catch(e){}try{window.document.cookie=encodeURIComponent(p)+"="+n+";"}catch(e){}}}function g(){var e;if(typeof window!==t&&p){try{e=window.localStorage[p]}catch(e){}if(typeof e===t)try{var n=window.document.cookie,r=encodeURIComponent(p),i=n.indexOf(r+"=");-1!==i&&(e=/^([^;]+)/.exec(n.slice(i+r.length+1))[1])}catch(e){}return void 0===u.levels[e]&&(e=void 0),e}}function h(){if(typeof window!==t&&p){try{window.localStorage.removeItem(p)}catch(e){}try{window.document.cookie=encodeURIComponent(p)+"=; expires=Thu, 01 Jan 1970 00:00:00 UTC"}catch(e){}}}function f(e){var t=e;if("string"==typeof t&&void 0!==u.levels[t.toUpperCase()]&&(t=u.levels[t.toUpperCase()]),"number"==typeof t&&t>=0&&t<=u.levels.SILENT)return t;throw new TypeError("log.setLevel() called with invalid level: "+e)}"string"==typeof e?p+=":"+e:"symbol"==typeof e&&(p=void 0),u.name=e,u.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},u.methodFactory=n||d,u.getLevel=function(){return null!=l?l:null!=a?a:o},u.setLevel=function(e,t){return l=f(e),!1!==t&&m(l),c.call(u)},u.setDefaultLevel=function(e){a=f(e),g()||u.setLevel(e,!1)},u.resetLevel=function(){l=null,h(),c.call(u)},u.enableAll=function(e){u.setLevel(u.levels.TRACE,e)},u.disableAll=function(e){u.setLevel(u.levels.SILENT,e)},u.rebuild=function(){if(s!==u&&(o=f(s.getLevel())),c.call(u),s===u)for(var e in i)i[e].rebuild()},o=f(s?s.getLevel():"WARN");var _=g();null!=_&&(l=f(_)),c.call(u)}(s=new p).getLogger=function(e){if("symbol"!=typeof e&&"string"!=typeof e||""===e)throw new TypeError("You must supply a name when creating a logger.");var t=i[e];return t||(t=i[e]=new p(e,s.methodFactory)),t};var m=typeof window!==t?window.log:void 0;return s.noConflict=function(){return typeof window!==t&&window.log===s&&(window.log=m),s},s.getLoggers=function(){return i},s.default=s,s},void 0===(i="function"==typeof r?r.call(t,n,t,e):r)||(e.exports=i)}()},72:e=>{"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var s={},o=[],a=0;a<e.length;a++){var l=e[a],c=r.base?l[0]+r.base:l[0],u=s[c]||0,d="".concat(c," ").concat(u);s[c]=u+1;var p=n(d),m={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(m);else{var g=i(m,r);r.byIndex=a,t.splice(a,0,{identifier:d,updater:g,references:1})}o.push(d)}return o}function i(e,t){var n=t.domAPI(t);n.update(e);return function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,i){var s=r(e=e||[],i=i||{});return function(e){e=e||[];for(var o=0;o<s.length;o++){var a=n(s[o]);t[a].references--}for(var l=r(e,i),c=0;c<s.length;c++){var u=n(s[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}s=l}}},659:e=>{"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},540:e=>{"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},56:(e,t,n)=>{"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},825:e=>{"use strict";e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var i=void 0!==n.layer;i&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,i&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var s=n.sourceMap;s&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},113:e=>{"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},495:e=>{"use strict";e.exports=JSON.parse("{\"blacklist_client.lua\":\"local blacklist = ARGV[num_static_argv + 1]\\n\\nif redis.call('zscore', client_last_seen_key, blacklist) then\\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\\nend\\n\\n\\nreturn {}\\n\",\"check.lua\":\"local weight = tonumber(ARGV[num_static_argv + 1])\\n\\nlocal capacity = process_tick(now, false)['capacity']\\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\\n\\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\\n\",\"conditions_check.lua\":\"local conditions_check = function (capacity, weight)\\n  return capacity == nil or weight <= capacity\\nend\\n\",\"current_reservoir.lua\":\"return process_tick(now, false)['reservoir']\\n\",\"done.lua\":\"process_tick(now, false)\\n\\nreturn tonumber(redis.call('hget', settings_key, 'done'))\\n\",\"free.lua\":\"local index = ARGV[num_static_argv + 1]\\n\\nredis.call('zadd', job_expirations_key, 0, index)\\n\\nreturn process_tick(now, false)['running']\\n\",\"get_time.lua\":\"redis.replicate_commands()\\n\\nlocal get_time = function ()\\n  local time = redis.call('time')\\n\\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\\nend\\n\",\"group_check.lua\":\"return not (redis.call('exists', settings_key) == 1)\\n\",\"heartbeat.lua\":\"process_tick(now, true)\\n\",\"increment_reservoir.lua\":\"local incr = tonumber(ARGV[num_static_argv + 1])\\n\\nredis.call('hincrby', settings_key, 'reservoir', incr)\\n\\nlocal reservoir = process_tick(now, true)['reservoir']\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn reservoir\\n\",\"init.lua\":\"local clear = tonumber(ARGV[num_static_argv + 1])\\nlocal limiter_version = ARGV[num_static_argv + 2]\\nlocal num_local_argv = num_static_argv + 2\\n\\nif clear == 1 then\\n  redis.call('del', unpack(KEYS))\\nend\\n\\nif redis.call('exists', settings_key) == 0 then\\n  -- Create\\n  local args = {'hmset', settings_key}\\n\\n  for i = num_local_argv + 1, #ARGV do\\n    table.insert(args, ARGV[i])\\n  end\\n\\n  redis.call(unpack(args))\\n  redis.call('hmset', settings_key,\\n    'nextRequest', now,\\n    'lastReservoirRefresh', now,\\n    'lastReservoirIncrease', now,\\n    'running', 0,\\n    'done', 0,\\n    'unblockTime', 0,\\n    'capacityPriorityCounter', 0\\n  )\\n\\nelse\\n  -- Apply migrations\\n  local settings = redis.call('hmget', settings_key,\\n    'id',\\n    'version'\\n  )\\n  local id = settings[1]\\n  local current_version = settings[2]\\n\\n  if current_version ~= limiter_version then\\n    local version_digits = {}\\n    for k, v in string.gmatch(current_version, \\\"([^.]+)\\\") do\\n      table.insert(version_digits, tonumber(k))\\n    end\\n\\n    -- 2.10.0\\n    if version_digits[2] < 10 then\\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\\n      redis.call('hsetnx', settings_key, 'done', 0)\\n      redis.call('hset', settings_key, 'version', '2.10.0')\\n    end\\n\\n    -- 2.11.1\\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\\n        redis.call('hmset', settings_key,\\n          'lastReservoirRefresh', now,\\n          'version', '2.11.1'\\n        )\\n      end\\n    end\\n\\n    -- 2.14.0\\n    if version_digits[2] < 14 then\\n      local old_running_key = 'b_'..id..'_running'\\n      local old_executing_key = 'b_'..id..'_executing'\\n\\n      if redis.call('exists', old_running_key) == 1 then\\n        redis.call('rename', old_running_key, job_weights_key)\\n      end\\n      if redis.call('exists', old_executing_key) == 1 then\\n        redis.call('rename', old_executing_key, job_expirations_key)\\n      end\\n      redis.call('hset', settings_key, 'version', '2.14.0')\\n    end\\n\\n    -- 2.15.2\\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\\n      redis.call('hset', settings_key, 'version', '2.15.2')\\n    end\\n\\n    -- 2.17.0\\n    if version_digits[2] < 17 then\\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\\n      redis.call('hset', settings_key, 'version', '2.17.0')\\n    end\\n\\n    -- 2.18.0\\n    if version_digits[2] < 18 then\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\\n      redis.call('hset', settings_key, 'version', '2.18.0')\\n    end\\n\\n  end\\n\\n  process_tick(now, false)\\nend\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn {}\\n\",\"process_tick.lua\":\"local process_tick = function (now, always_publish)\\n\\n  local compute_capacity = function (maxConcurrent, running, reservoir)\\n    if maxConcurrent ~= nil and reservoir ~= nil then\\n      return math.min((maxConcurrent - running), reservoir)\\n    elseif maxConcurrent ~= nil then\\n      return maxConcurrent - running\\n    elseif reservoir ~= nil then\\n      return reservoir\\n    else\\n      return nil\\n    end\\n  end\\n\\n  local settings = redis.call('hmget', settings_key,\\n    'id',\\n    'maxConcurrent',\\n    'running',\\n    'reservoir',\\n    'reservoirRefreshInterval',\\n    'reservoirRefreshAmount',\\n    'lastReservoirRefresh',\\n    'reservoirIncreaseInterval',\\n    'reservoirIncreaseAmount',\\n    'reservoirIncreaseMaximum',\\n    'lastReservoirIncrease',\\n    'capacityPriorityCounter',\\n    'clientTimeout'\\n  )\\n  local id = settings[1]\\n  local maxConcurrent = tonumber(settings[2])\\n  local running = tonumber(settings[3])\\n  local reservoir = tonumber(settings[4])\\n  local reservoirRefreshInterval = tonumber(settings[5])\\n  local reservoirRefreshAmount = tonumber(settings[6])\\n  local lastReservoirRefresh = tonumber(settings[7])\\n  local reservoirIncreaseInterval = tonumber(settings[8])\\n  local reservoirIncreaseAmount = tonumber(settings[9])\\n  local reservoirIncreaseMaximum = tonumber(settings[10])\\n  local lastReservoirIncrease = tonumber(settings[11])\\n  local capacityPriorityCounter = tonumber(settings[12])\\n  local clientTimeout = tonumber(settings[13])\\n\\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\\n\\n  --\\n  -- Process 'running' changes\\n  --\\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\\n\\n  if #expired > 0 then\\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\\n\\n    local flush_batch = function (batch, acc)\\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\\n                      redis.call('hdel',  job_weights_key, unpack(batch))\\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\\n                      redis.call('hdel',  job_clients_key, unpack(batch))\\n\\n      -- Calculate sum of removed weights\\n      for i = 1, #weights do\\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\\n      end\\n\\n      -- Calculate sum of removed weights by client\\n      local client_weights = {}\\n      for i = 1, #clients do\\n        local removed = tonumber(weights[i]) or 0\\n        if removed > 0 then\\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\\n        end\\n      end\\n    end\\n\\n    local acc = {\\n      ['total'] = 0,\\n      ['client_weights'] = {}\\n    }\\n    local batch_size = 1000\\n\\n    -- Compute changes to Zsets and apply changes to Hashes\\n    for i = 1, #expired, batch_size do\\n      local batch = {}\\n      for j = i, math.min(i + batch_size - 1, #expired) do\\n        table.insert(batch, expired[j])\\n      end\\n\\n      flush_batch(batch, acc)\\n    end\\n\\n    -- Apply changes to Zsets\\n    if acc['total'] > 0 then\\n      redis.call('hincrby', settings_key, 'done', acc['total'])\\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\\n    end\\n\\n    for client, weight in pairs(acc['client_weights']) do\\n      redis.call('zincrby', client_running_key, -weight, client)\\n    end\\n  end\\n\\n  --\\n  -- Process 'reservoir' changes\\n  --\\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\\n    reservoir = reservoirRefreshAmount\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'lastReservoirRefresh', now\\n    )\\n  end\\n\\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\\n    local incr = reservoirIncreaseAmount * num_intervals\\n    if reservoirIncreaseMaximum ~= nil then\\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\\n    end\\n    if incr > 0 then\\n      reservoir = (reservoir or 0) + incr\\n    end\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\\n    )\\n  end\\n\\n  --\\n  -- Clear unresponsive clients\\n  --\\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\\n  local unresponsive_lookup = {}\\n  local terminated_clients = {}\\n  for i = 1, #unresponsive do\\n    unresponsive_lookup[unresponsive[i]] = true\\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\\n      table.insert(terminated_clients, unresponsive[i])\\n    end\\n  end\\n  if #terminated_clients > 0 then\\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\\n  end\\n\\n  --\\n  -- Broadcast capacity changes\\n  --\\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\\n\\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\\n    -- always_publish or was not unlimited, now unlimited\\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\\n\\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\\n    -- capacity was increased\\n    -- send the capacity message to the limiter having the lowest number of running jobs\\n    -- the tiebreaker is the limiter having not registered a job in the longest time\\n\\n    local lowest_concurrency_value = nil\\n    local lowest_concurrency_clients = {}\\n    local lowest_concurrency_last_registered = {}\\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\\n\\n    for i = 1, #client_concurrencies, 2 do\\n      local client = client_concurrencies[i]\\n      local concurrency = tonumber(client_concurrencies[i+1])\\n\\n      if (\\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\\n      ) and (\\n        not unresponsive_lookup[client]\\n      ) and (\\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\\n      ) then\\n        lowest_concurrency_value = concurrency\\n        table.insert(lowest_concurrency_clients, client)\\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\\n        table.insert(lowest_concurrency_last_registered, last_registered)\\n      end\\n    end\\n\\n    if #lowest_concurrency_clients > 0 then\\n      local position = 1\\n      local earliest = lowest_concurrency_last_registered[1]\\n\\n      for i,v in ipairs(lowest_concurrency_last_registered) do\\n        if v < earliest then\\n          position = i\\n          earliest = v\\n        end\\n      end\\n\\n      local next_client = lowest_concurrency_clients[position]\\n      redis.call('publish', 'b_'..id,\\n        'capacity-priority:'..(final_capacity or '')..\\n        ':'..next_client..\\n        ':'..capacityPriorityCounter\\n      )\\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\\n    else\\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\\n    end\\n  end\\n\\n  return {\\n    ['capacity'] = final_capacity,\\n    ['running'] = running,\\n    ['reservoir'] = reservoir\\n  }\\nend\\n\",\"queued.lua\":\"local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\\n\\nlocal sum = 0\\nfor i = 1, #client_queued do\\n  sum = sum + tonumber(client_queued[i])\\nend\\n\\nreturn sum\\n\",\"refresh_expiration.lua\":\"local refresh_expiration = function (now, nextRequest, groupTimeout)\\n\\n  if groupTimeout ~= nil then\\n    local ttl = (nextRequest + groupTimeout) - now\\n\\n    for i = 1, #KEYS do\\n      redis.call('pexpire', KEYS[i], ttl)\\n    end\\n  end\\n\\nend\\n\",\"refs.lua\":\"local settings_key = KEYS[1]\\nlocal job_weights_key = KEYS[2]\\nlocal job_expirations_key = KEYS[3]\\nlocal job_clients_key = KEYS[4]\\nlocal client_running_key = KEYS[5]\\nlocal client_num_queued_key = KEYS[6]\\nlocal client_last_registered_key = KEYS[7]\\nlocal client_last_seen_key = KEYS[8]\\n\\nlocal now = tonumber(ARGV[1])\\nlocal client = ARGV[2]\\n\\nlocal num_static_argv = 2\\n\",\"register.lua\":\"local index = ARGV[num_static_argv + 1]\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\\n\\nlocal state = process_tick(now, false)\\nlocal capacity = state['capacity']\\nlocal reservoir = state['reservoir']\\n\\nlocal settings = redis.call('hmget', settings_key,\\n  'nextRequest',\\n  'minTime',\\n  'groupTimeout'\\n)\\nlocal nextRequest = tonumber(settings[1])\\nlocal minTime = tonumber(settings[2])\\nlocal groupTimeout = tonumber(settings[3])\\n\\nif conditions_check(capacity, weight) then\\n\\n  redis.call('hincrby', settings_key, 'running', weight)\\n  redis.call('hset', job_weights_key, index, weight)\\n  if expiration ~= nil then\\n    redis.call('zadd', job_expirations_key, now + expiration, index)\\n  end\\n  redis.call('hset', job_clients_key, index, client)\\n  redis.call('zincrby', client_running_key, weight, client)\\n  redis.call('hincrby', client_num_queued_key, client, -1)\\n  redis.call('zadd', client_last_registered_key, now, client)\\n\\n  local wait = math.max(nextRequest - now, 0)\\n  local newNextRequest = now + wait + minTime\\n\\n  if reservoir == nil then\\n    redis.call('hset', settings_key,\\n      'nextRequest', newNextRequest\\n    )\\n  else\\n    reservoir = reservoir - weight\\n    redis.call('hmset', settings_key,\\n      'reservoir', reservoir,\\n      'nextRequest', newNextRequest\\n    )\\n  end\\n\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\n\\n  return {true, wait, reservoir}\\n\\nelse\\n  return {false}\\nend\\n\",\"register_client.lua\":\"local queued = tonumber(ARGV[num_static_argv + 1])\\n\\n-- Could have been re-registered concurrently\\nif not redis.call('zscore', client_last_seen_key, client) then\\n  redis.call('zadd', client_running_key, 0, client)\\n  redis.call('hset', client_num_queued_key, client, queued)\\n  redis.call('zadd', client_last_registered_key, 0, client)\\nend\\n\\nredis.call('zadd', client_last_seen_key, now, client)\\n\\nreturn {}\\n\",\"running.lua\":\"return process_tick(now, false)['running']\\n\",\"submit.lua\":\"local queueLength = tonumber(ARGV[num_static_argv + 1])\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\n\\nlocal capacity = process_tick(now, false)['capacity']\\n\\nlocal settings = redis.call('hmget', settings_key,\\n  'id',\\n  'maxConcurrent',\\n  'highWater',\\n  'nextRequest',\\n  'strategy',\\n  'unblockTime',\\n  'penalty',\\n  'minTime',\\n  'groupTimeout'\\n)\\nlocal id = settings[1]\\nlocal maxConcurrent = tonumber(settings[2])\\nlocal highWater = tonumber(settings[3])\\nlocal nextRequest = tonumber(settings[4])\\nlocal strategy = tonumber(settings[5])\\nlocal unblockTime = tonumber(settings[6])\\nlocal penalty = tonumber(settings[7])\\nlocal minTime = tonumber(settings[8])\\nlocal groupTimeout = tonumber(settings[9])\\n\\nif maxConcurrent ~= nil and weight > maxConcurrent then\\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\\nend\\n\\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\\n  and not (\\n    conditions_check(capacity, weight)\\n    and nextRequest - now <= 0\\n  )\\n)\\n\\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\\n\\nif blocked then\\n  local computedPenalty = penalty\\n  if computedPenalty == nil then\\n    if minTime == 0 then\\n      computedPenalty = 5000\\n    else\\n      computedPenalty = 15 * minTime\\n    end\\n  end\\n\\n  local newNextRequest = now + computedPenalty + minTime\\n\\n  redis.call('hmset', settings_key,\\n    'unblockTime', now + computedPenalty,\\n    'nextRequest', newNextRequest\\n  )\\n\\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\\n  local queued_reset = {}\\n  for i = 1, #clients_queued_reset do\\n    table.insert(queued_reset, clients_queued_reset[i])\\n    table.insert(queued_reset, 0)\\n  end\\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\\n\\n  redis.call('publish', 'b_'..id, 'blocked:')\\n\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\nend\\n\\nif not blocked and not reachedHWM then\\n  redis.call('hincrby', client_num_queued_key, client, 1)\\nend\\n\\nreturn {reachedHWM, blocked, strategy}\\n\",\"update_settings.lua\":\"local args = {'hmset', settings_key}\\n\\nfor i = num_static_argv + 1, #ARGV do\\n  table.insert(args, ARGV[i])\\nend\\n\\nredis.call(unpack(args))\\n\\nprocess_tick(now, true)\\n\\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\\nrefresh_expiration(0, 0, groupTimeout)\\n\\nreturn {}\\n\",\"validate_client.lua\":\"if not redis.call('zscore', client_last_seen_key, client) then\\n  return redis.error_reply('UNKNOWN_CLIENT')\\nend\\n\\nredis.call('zadd', client_last_seen_key, now, client)\\n\",\"validate_keys.lua\":\"if not (redis.call('exists', settings_key) == 1) then\\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\\nend\\n\"}")},349:e=>{"use strict";e.exports={r:"2.19.5"}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.nc=void 0;var __webpack_exports__={};(()=>{"use strict";__webpack_require__.d(__webpack_exports__,{QF:()=>ht,C$:()=>tt,zH:()=>et});var e=__webpack_require__(72),t=__webpack_require__.n(e),n=__webpack_require__(825),r=__webpack_require__.n(n),i=__webpack_require__(659),s=__webpack_require__.n(i),o=__webpack_require__(56),a=__webpack_require__.n(o),l=__webpack_require__(540),c=__webpack_require__.n(l),u=__webpack_require__(113),d=__webpack_require__.n(u),p=__webpack_require__(208),m={};m.styleTagTransform=d(),m.setAttributes=a(),m.insert=s().bind(null,"head"),m.domAPI=r(),m.insertStyleElement=c();t()(p.A,m);p.A&&p.A.locals&&p.A.locals;const g=/<img-prompt="([^"\\]*(?:\\.[^"\\]*)*)"\s*>/g;function h(){return new RegExp(g.source,g.flags)}function f(e){return e.replace(/\\"/g,'"')}function _(e){const t=e.map((e=>`(?:${e})`)).join("|");return new RegExp(t,"g")}function v(e,t){const n=_(t),r=[];let i;for(;null!==(i=n.exec(e));){const e=i.slice(1).find((e=>void 0!==e));e&&e.trim().length>0&&r.push({prompt:f(e.trim()),fullMatch:i[0],startIndex:i.index,endIndex:i.index+i[0].length})}return r}const y="auto_illustrator",b={DEFAULT:300,MIN:100,MAX:1e3,STEP:50},E={DEFAULT:1,MIN:1,MAX:5,STEP:1},w={DEFAULT:0,MIN:0,MAX:1e4,STEP:100},x=['\x3c!--img-prompt="([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"\\s*--\x3e','<img-prompt="([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"\\s*>','<img_prompt="([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"\\s*>'],k={enabled:!0,streamingEnabled:!0,streamingPollInterval:b.DEFAULT,maxConcurrentGenerations:E.DEFAULT,minGenerationInterval:w.DEFAULT,logLevel:"info",currentPresetId:"default",customPresets:[],manualGenerationMode:"append",promptDetectionPatterns:x,commonStyleTags:"",commonStyleTagsPosition:"prefix"},T={ENABLED:"auto_illustrator_enabled",META_PROMPT:"auto_illustrator_meta_prompt",META_PROMPT_PRESET_SELECT:"auto_illustrator_preset_select",META_PROMPT_PRESET_EDIT:"auto_illustrator_preset_edit",META_PROMPT_PRESET_SAVE:"auto_illustrator_preset_save",META_PROMPT_PRESET_SAVE_AS:"auto_illustrator_preset_save_as",META_PROMPT_PRESET_DELETE:"auto_illustrator_preset_delete",META_PROMPT_PRESET_CANCEL:"auto_illustrator_preset_cancel",PRESET_EDITOR:"auto_illustrator_preset_editor",PRESET_VIEWER:"auto_illustrator_preset_viewer",PRESET_PREVIEW:"auto_illustrator_preset_preview",STREAMING_ENABLED:"auto_illustrator_streaming_enabled",STREAMING_POLL_INTERVAL:"auto_illustrator_streaming_poll_interval",MAX_CONCURRENT:"auto_illustrator_max_concurrent",MIN_GENERATION_INTERVAL:"auto_illustrator_min_generation_interval",LOG_LEVEL:"auto_illustrator_log_level",MANUAL_GEN_MODE:"auto_illustrator_manual_gen_mode",PROMPT_PATTERNS:"auto_illustrator_prompt_patterns",PROMPT_PATTERNS_RESET:"auto_illustrator_prompt_patterns_reset",PATTERN_VALIDATION_STATUS:"auto_illustrator_pattern_validation_status",COMMON_STYLE_TAGS:"auto_illustrator_common_style_tags",COMMON_STYLE_TAGS_POSITION:"auto_illustrator_common_style_tags_position",RESET_BUTTON:"auto_illustrator_reset"};function I(e,t=x){if(0===t.length)return!1;if(t.length>1){return _(t).test(e)}return h().test(e)}function S(e,t=x){if(0===t.length)return[];if(t.length>1)return v(e,t);const n=[],r=h();let i;for(;null!==(i=r.exec(e));){const e=f(i[1]).trim();0!==e.length&&n.push({fullMatch:i[0],prompt:e,startIndex:i.index,endIndex:i.index+i[0].length})}return n}var P=__webpack_require__(390),A=__webpack_require__.n(P),R=__webpack_require__(65),N=__webpack_require__.n(R);const C="[Auto Illustrator]",M=N().getLogger("auto-illustrator");function O(e){M.setLevel(e)}function D(e,t){return e?`${C} [${e}] ${t}`:`${C} ${t}`}function L(e){return{trace:(t,...n)=>M.trace(D(e,t),...n),debug:(t,...n)=>M.debug(D(e,t),...n),info:(t,...n)=>M.info(D(e,t),...n),warn:(t,...n)=>M.warn(D(e,t),...n),error:(t,...n)=>M.error(D(e,t),...n)}}M.setLevel(N().levels.INFO);let G=null;function q(e,t){const n=G?G(e,e):e;if(!t)return n;let r=n;for(const[e,n]of Object.entries(t))r=r.replace(new RegExp(`\\{${e}\\}`,"g"),String(n));return r}function B(e,t,n){return q(t,{...n,count:e})}const j=L("PromptMetadata");function F(e){return`${e.messageId}_${e.promptIndex}`}function U(e){return e.chat_metadata||(e.chat_metadata={}),e.chat_metadata.auto_illustrator||(e.chat_metadata.auto_illustrator={imageUrlToPromptId:{},promptIdToText:{},promptPositionHistory:{}}),e.chat_metadata.auto_illustrator}function z(e,t){const n=U(t),r=function(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t|=0;return`prompt_${Math.abs(t).toString(36)}_${Date.now().toString(36)}`}(e);return n.promptIdToText[r]||(n.promptIdToText[r]=e,j.debug(`Recorded new prompt: ${r}`)),r}function V(e,t,n){U(n).imageUrlToPromptId[e]=t,j.debug(`Linked image to prompt: ${t}`)}function W(e,t,n){const r=U(n),i=F(e);r.promptPositionHistory[i]||(r.promptPositionHistory[i]={versions:[{promptId:t,feedback:"",timestamp:Date.now()}]},j.debug(`Initialized position history: ${i}`))}function H(e,t){const n=U(t),r=F(e),i=n.promptPositionHistory[r];return i&&0!==i.versions.length?i.versions[i.versions.length-1].promptId:null}function Y(e,t){return U(t).promptIdToText[e]||null}const K=L("ProgressWidget"),X=new Map;function Q(){const e=document.getElementById("ai-img-progress-global");if(!e)return void K.warn("Global widget not found during update");if(K.info(`Updating global widget display: ${X.size} message(s), display will be: ${0===X.size?"none":"flex"}`),e.innerHTML="",0===X.size)return e.style.display="none",void K.debug("No active messages, hiding widget");e.style.display="flex";const t=document.createElement("div");t.className="ai-img-progress-spinner",e.appendChild(t);const n=document.createElement("div");n.className="ai-img-progress-text-container";for(const[e,t]of X.entries()){const r=document.createElement("div");r.className="ai-img-progress-text",r.textContent=q("toast.generatingImagesProgressWithMessage",{messageId:String(e),current:String(t.current),total:String(t.total)}),n.appendChild(r)}e.appendChild(n);const r=window.getComputedStyle(e),i=e.getBoundingClientRect();K.info(`Widget rendered - display: ${r.display}, visibility: ${r.visibility}, position: ${r.position}, zIndex: ${r.zIndex}, bottom: ${r.bottom}`),K.info(`Widget position - top: ${i.top}px, left: ${i.left}px, bottom: ${i.bottom}px, right: ${i.right}px, width: ${i.width}px, height: ${i.height}px`),K.info(`Widget content: ${e.children.length} children, innerHTML length: ${e.innerHTML.length}`),K.debug(`Updated global widget: ${X.size} message(s) in progress`)}function J(e,t,n){!function(){const e=document.getElementById("ai-img-progress-global");if(e)return e;const t=document.createElement("div");t.id="ai-img-progress-global",t.className="ai-img-progress-widget-global",t.style.display="none";const n=document.getElementById("sheld"),r=document.getElementById("form_sheld");n&&r?(n.insertBefore(t,r),K.info("Created global progress widget and inserted into #sheld before #form_sheld")):(K.error("Could not find #sheld or #form_sheld, falling back to body append"),document.body.appendChild(t),K.warn("Widget appended to body as fallback (may have positioning issues)"))}(),X.set(e,{current:t,total:n,startTime:X.get(e)?.startTime||Date.now()}),Q(),K.info(`Added/updated progress for message ${e}: ${t}/${n}`)}function Z(e,t){return J(e,0,t),!0}function ee(e,t,n){!function(e,t,n){const r=X.get(e);r?(X.set(e,{current:t,total:n,startTime:r.startTime}),Q(),K.debug(`Updated progress for message ${e}: ${t}/${n}`)):K.warn(`Cannot update progress for message ${e}: not being tracked`)}(e,t,n)}function te(e){!function(e){X.delete(e)&&(Q(),K.info(`Removed progress for message ${e}`))}(e)}function ne(e,t,n,r){Z(e,t)}const re=L("DomQueue"),ie=new(A().Group)({maxConcurrent:1,trackDoneStatus:!0});async function se(e,t,n){const r=ie.key(e.toString()),i=n||"DOM operation";return re.debug(`Scheduling ${i} for message ${e}`),r.schedule((async()=>{re.debug(`Executing ${i} for message ${e}`);try{const n=await t();return re.debug(`Completed ${i} for message ${e}`),n}catch(t){throw re.error(`Failed ${i} for message ${e}:`,t),t}}))}const oe=L("Generator");let ae=null;function le(e,t=0){oe.info(`Initializing Bottleneck limiter (maxConcurrent: ${e}, minTime: ${t}ms)`),ae=new(A())({maxConcurrent:e,minTime:t,trackDoneStatus:!0}),ae.on("depleted",(()=>{oe.debug("Image generation queue depleted (all jobs complete)")})),ae.on("idle",(()=>{oe.debug("Image generation queue idle (no pending jobs)")})),ae.on("error",(e=>{oe.error("Bottleneck error:",e)}))}function ce(e){if(!ae)return oe.warn("Image limiter not initialized, initializing now"),void le(e);oe.info(`Updating maxConcurrent: ${e}`),ae.updateSettings({maxConcurrent:e})}function ue(e){if(!ae)return oe.warn("Image limiter not initialized, initializing now"),void le(1,e);oe.info(`Updating minTime: ${e}ms`),ae.updateSettings({minTime:e})}function de(e,t,n,r){const i=e.indexOf(t);if(-1===i)return oe.warn("Could not find prompt tag in text:",t),{text:e,success:!1};const s=i+t.length;if(e.substring(s,s+200).includes(`src="${n}"`))return oe.info("Image already inserted, skipping:",n),{text:e,success:!1};const o=function(e,t){const n=`AI generated image #${t+1}`;return`<img src="${e}" title="${n}" alt="${n}">`}(n,r);return{text:e.substring(0,s)+"\n"+o+e.substring(s),success:!0}}async function pe(e,t,n,r,i){if(ae||(oe.warn("Image limiter not initialized, using defaults (1, 0ms)"),ae=new(A())({maxConcurrent:1,minTime:0,trackDoneStatus:!0})),i?.aborted)return oe.info("Generation aborted before scheduling:",e),null;const s=`${e}_${Date.now()}_${Math.random().toString(36).substring(7)}`;return ae.schedule({id:s},(async()=>{if(i?.aborted)return oe.info("Generation aborted after scheduling:",e),null;const s=n&&r?function(e,t,n){if(!t||""===t.trim())return e;const r=me(e),i=me(t),s="prefix"===n?[...i,...r]:[...r,...i];return function(e){const t=new Map;for(const n of e){const e=n.toLowerCase();t.has(e)||t.set(e,n)}return Array.from(t.values())}(s).join(", ")}(e,n,r):e;oe.info("Generating image for prompt:",s),n&&s!==e&&(oe.debug(`Original prompt: "${e}"`),oe.debug(`Enhanced with common tags: "${s}"`));const o=performance.now();try{const e=t.SlashCommandParser?.commands?.sd;if(!e||!e.callback)return oe.error("SD command not available"),oe.info("Available commands:",Object.keys(t.SlashCommandParser?.commands||{})),null;oe.info("Calling SD command...");const n=await e.callback({quiet:"true"},s),r=performance.now()-o;return oe.info(`Generated image URL: ${n} (took ${r.toFixed(0)}ms)`),n}catch(e){const t=performance.now()-o;return oe.error(`Error generating image (after ${t.toFixed(0)}ms):`,e),null}}))}function me(e){return e&&""!==e.trim()?e.split(",").map((e=>e.trim())).filter((e=>e.length>0)):[]}const ge=L("MessageHandler");async function he(e,t,n,r,i,s){if(I(e,r)){ge.info("Processing message for images:",t);try{const o=await async function(e,t,n,r,i,s){const o=S(e,n);if(oe.info("Found",o.length,"image prompts to process"),0===o.length)return e;if(oe.info("Extracted prompts:",o.map((e=>e.prompt))),void 0!==s)for(let e=0;e<o.length;e++)W({messageId:s,promptIndex:e},z(o[e].prompt,t),t),oe.debug(`Initialized metadata for prompt at position ${s}_${e}`);const a=o.length;toastr.info(B(a,"toast.generatingImages"),q("extensionName")),void 0!==s&&ne(s,a);const l=performance.now(),c=[];for(let e=0;e<o.length;e++){const n=o[e],l=await pe(n.prompt,t,r,i);c.push(l),void 0!==s&&ee(s,e+1,a)}const u=performance.now()-l,d=c.filter((e=>e)).length;oe.info(`Generated ${d} images successfully (total time: ${u.toFixed(0)}ms, avg: ${(u/a).toFixed(0)}ms per image)`),d===a?toastr.success(B(d,"toast.successGenerated"),q("extensionName")):d>0?toastr.warning(q("toast.partialGenerated",{success:d,total:a}),q("extensionName")):toastr.error(q("toast.failedToGenerate"),q("extensionName"));let p=e;for(let e=o.length-1;e>=0;e--){const n=o[e],r=c[e];if(r){const i=de(p,n.fullMatch,r,e);if(i.success&&(p=i.text,oe.info("Added image after prompt at index",e),void 0!==s)){const n=H({messageId:s,promptIndex:e},t);n?(V(r,n,t),oe.debug(`Recorded image-prompt association: ${r} -> ${n}`)):oe.warn(`No promptId found for position ${s}_${e}`)}}else oe.info("Image generation failed for prompt at index",e,"- keeping tag")}return void 0!==s&&te(s),p}(e,n,r,i,s,t);n.chat&&n.chat[t]&&(n.chat[t].mes=o)}catch(e){ge.error("Error processing message:",e)}}}const fe=L("Pruner");const _e=L("Queue");function ve(e,t){const n=`${e}:${t}`;let r=0;for(let e=0;e<n.length;e++){r=(r<<5)-r+n.charCodeAt(e),r|=0}return`prompt_${Math.abs(r).toString(36)}`}class ye{constructor(){this.prompts=new Map}addPrompt(e,t,n,r){const i=ve(e,n);if(this.prompts.has(i))return _e.info("Prompt already queued:",i),null;const s={id:i,prompt:e,fullMatch:t,startIndex:n,endIndex:r,state:"QUEUED",attempts:0,detectedAt:Date.now()};return this.prompts.set(i,s),_e.info("Added prompt:",i,e),s}hasPrompt(e,t){const n=ve(e,t);return this.prompts.has(n)}hasPromptByText(e){for(const t of this.prompts.values())if(t.prompt===e)return!0;return!1}getNextPending(){for(const e of this.prompts.values())if("QUEUED"===e.state)return e;return null}updateState(e,t,n){const r=this.prompts.get(e);r?(r.state=t,"GENERATING"===t&&(r.generationStartedAt=Date.now(),r.attempts++),"COMPLETED"!==t&&"FAILED"!==t||(r.completedAt=Date.now()),n?.imageUrl&&(r.imageUrl=n.imageUrl),n?.error&&(r.error=n.error),_e.info("Updated state:",e,t)):_e.warn("Prompt not found:",e)}getPrompt(e){return this.prompts.get(e)}getAllPrompts(){return Array.from(this.prompts.values())}getPromptsByState(e){return this.getAllPrompts().filter((t=>t.state===e))}getStats(){const e={DETECTED:0,QUEUED:0,GENERATING:0,COMPLETED:0,FAILED:0};for(const t of this.prompts.values())e[t.state]++;return e}clear(){_e.info("Clearing queue"),this.prompts.clear()}size(){return this.prompts.size}adjustPositionsAfterInsertion(e,t,n=Date.now()){for(const r of this.prompts.values())r.detectedAt<n&&r.startIndex>e&&("QUEUED"===r.state||"GENERATING"===r.state)&&(r.startIndex+=t,r.endIndex+=t)}}const be=L("Monitor");class Ee{constructor(e,t,n,r=300,i){this.messageId=-1,this.lastSeenText="",this.pollInterval=null,this.isRunning=!1,this.queue=e,this.context=t,this.settings=n,this.intervalMs=r,this.onNewPromptsCallback=i}start(e){this.isRunning&&(be.warn("Already running, stopping previous monitor"),this.stop()),this.messageId=e,this.lastSeenText="",this.isRunning=!0,be.info(`Starting monitor for message ${e} (interval: ${this.intervalMs}ms)`),this.pollInterval=setInterval((()=>{this.checkForNewPrompts()}),this.intervalMs),this.checkForNewPrompts()}stop(){this.isRunning&&(be.info("Stopping monitor"),this.isRunning=!1,this.pollInterval&&(clearInterval(this.pollInterval),this.pollInterval=null),this.messageId=-1,this.lastSeenText="")}finalScan(){be.info("Performing final scan for remaining prompts"),this.checkForNewPrompts()}checkForNewPrompts(){if(!this.isRunning||this.messageId<0)return;const e=this.context.chat?.[this.messageId];if(!e)return void be.warn("Message not found:",this.messageId);const t=e.mes||"";if(t===this.lastSeenText)return;be.trace(`Text changed (${this.lastSeenText.length} -> ${t.length} chars)`);const n=this.extractNewPrompts(t);if(n.length>0){be.info(`Found ${n.length} new prompts`);const e=S(t,this.settings.promptDetectionPatterns);for(const t of n){const n=e.findIndex((e=>e.startIndex===t.startIndex&&e.endIndex===t.endIndex&&e.prompt===t.prompt));if(n>=0){const e=z(t.prompt,this.context);W({messageId:this.messageId,promptIndex:n},e,this.context),be.debug(`Initialized metadata for prompt at position ${this.messageId}_${n}`)}this.queue.addPrompt(t.prompt,t.fullMatch,t.startIndex,t.endIndex)}this.onNewPromptsCallback&&this.onNewPromptsCallback()}this.lastSeenText=t}extractNewPrompts(e){const t=S(e,this.settings.promptDetectionPatterns),n=[];for(const e of t)this.queue.hasPromptByText(e.prompt)||n.push(e);return n}getStatus(){return{isRunning:this.isRunning,messageId:this.messageId,lastTextLength:this.lastSeenText.length,intervalMs:this.intervalMs}}isActive(){return this.isRunning}}const we=L("Processor");class xe{constructor(e,t,n,r=1){this.messageId=-1,this.isRunning=!1,this.isProcessing=!1,this.activeGenerations=0,this.processPromise=null,this.deferredImages=[],this.barrier=null,this.queue=e,this.context=t,this.settings=n,this.maxConcurrent=r}start(e,t){this.isRunning&&(we.warn("Already running, stopping previous processor"),this.stop()),this.messageId=e,this.isRunning=!0,this.activeGenerations=0,this.deferredImages=[],this.barrier=t??null,we.info(`Starting processor for message ${e} (max concurrent: ${this.maxConcurrent}) ${t?"with barrier":"without barrier"}`),Z(e,0),this.processNext()}stop(){this.isRunning&&(we.info("Stopping processor"),this.isRunning=!1,this.messageId=-1)}async processNext(){if(!(!this.isRunning||this.activeGenerations>=this.maxConcurrent||this.isProcessing)){this.isProcessing=!0;try{const e=this.queue.getNextPending();if(!e)return this.isProcessing=!1,void we.info("No pending prompts, waiting...");we.info(`Processing prompt: ${e.id}`);const t=this.queue.size();t>0&&ne(this.messageId,t),this.queue.updateState(e.id,"GENERATING"),this.activeGenerations++,this.generateImageForPrompt(e).then((()=>{this.activeGenerations--,this.processNext()})).catch((e=>{we.error("Unexpected error:",e),this.activeGenerations--,this.processNext()})),this.activeGenerations<this.maxConcurrent?(this.isProcessing=!1,setImmediate((()=>this.processNext()))):this.isProcessing=!1}catch(e){we.error("Error in processNext:",e),this.isProcessing=!1}}}async generateImageForPrompt(e){try{we.info(`Generating image for: ${e.prompt}`);const t=await pe(e.prompt,this.context,this.settings.commonStyleTags,this.settings.commonStyleTagsPosition);if(t){this.queue.updateState(e.id,"COMPLETED",{imageUrl:t}),we.info(`Generated image: ${t}`),this.deferredImages.push({prompt:e,imageUrl:t}),we.info(`Deferred image insertion (${this.deferredImages.length} total)`);const n=this.queue.getStats(),r=n.COMPLETED+n.FAILED;ee(this.messageId,r,this.queue.size())}else{this.queue.updateState(e.id,"FAILED",{error:"Image generation returned null"}),we.warn(`Failed to generate image for: ${e.prompt}`);const t=this.queue.getStats(),n=t.COMPLETED+t.FAILED;ee(this.messageId,n,this.queue.size())}}catch(t){this.queue.updateState(e.id,"FAILED",{error:t instanceof Error?t.message:String(t)}),we.error("Error generating image:",t);const n=this.queue.getStats(),r=n.COMPLETED+n.FAILED;ee(this.messageId,r,this.queue.size())}}async processRemaining(){if(we.info("Processing remaining prompts..."),this.barrier&&"arrive"in this.barrier&&(we.info("Signaling genDone to barrier (before waiting for completions)"),this.barrier.arrive("genDone")),this.activeGenerations>0){for(we.debug(`Waiting for ${this.activeGenerations} active generations to complete...`);this.activeGenerations>0;)await new Promise((e=>setTimeout(e,100)));we.debug("All active generations completed")}const e=this.queue.getPromptsByState("QUEUED");if(we.info(`${e.length} prompts remaining`),e.length>0){for(const t of e)await this.generateImageForPrompt(t);we.info("Finished processing remaining prompts")}}trigger(){this.isRunning&&!this.isProcessing&&this.processNext()}getDeferredImages(){return this.deferredImages}clearDeferredImages(){this.deferredImages=[]}getStatus(){return{isRunning:this.isRunning,messageId:this.messageId,activeGenerations:this.activeGenerations,maxConcurrent:this.maxConcurrent,queueStats:this.queue.getStats()}}}const ke=L("Barrier");class Te{constructor(e,t){if(this.resolved=!1,this.timeoutHandle=null,0===e.length)throw new Error("Barrier must have at least one condition");this.needed=new Set(e),this.whenReady=new Promise(((e,t)=>{this._resolve=e,this._reject=t})),ke.debug(`Barrier created, waiting for: ${Array.from(e).join(", ")}`),t&&t>0&&(this.timeoutHandle=setTimeout((()=>{if(!this.resolved){const e=Array.from(this.needed),n=new Error(`Barrier timeout after ${t}ms. Still waiting for: ${e.join(", ")}`);ke.error("Barrier timeout:",n),this.resolved=!0,this._reject(n)}}),t))}arrive(e){this.resolved?ke.warn(`Barrier already resolved, ignoring arrival of: ${e}`):this.needed.has(e)?(ke.debug(`Barrier condition met: ${e}`),this.needed.delete(e),0===this.needed.size?(ke.info("All barrier conditions met, resolving"),this.resolved=!0,this.timeoutHandle&&(clearTimeout(this.timeoutHandle),this.timeoutHandle=null),this._resolve()):ke.debug(`Still waiting for: ${Array.from(this.needed).join(", ")} (${this.needed.size} remaining)`)):ke.warn(`Unknown condition: ${e}, expected one of: ${Array.from(this.needed).join(", ")}`)}isResolved(){return this.resolved}getRemainingConditions(){return Array.from(this.needed)}getRemainingCount(){return this.needed.size}}const Ie=L("SessionManager");class Se{constructor(){this.currentSession=null}startSession(e,t,n){this.currentSession&&(Ie.warn(`Starting new session for message ${e}, cancelling existing session for message ${this.currentSession.messageId}`),this.cancelSession());const r=`session_${e}_${Date.now()}`,i=new Te(["genDone","messageReceived"],3e4),s=new AbortController,o=new ye,a=new xe(o,t,n,n.maxConcurrentGenerations),l=new Ee(o,t,n,n.streamingPollInterval,(()=>{a.trigger()})),c={sessionId:r,messageId:e,barrier:i,abortController:s,queue:o,monitor:l,processor:a,startedAt:Date.now()};return this.currentSession=c,Ie.info(`Started streaming session ${r} for message ${e}`),l.start(e),a.start(e,i),c}cancelSession(){if(!this.currentSession)return;const{sessionId:e,messageId:t,abortController:n,monitor:r,processor:i}=this.currentSession;Ie.info(`Cancelling streaming session ${e} for message ${t}`),n.abort(),r.stop(),i.stop(),this.currentSession=null}endSession(){if(!this.currentSession)return;const{sessionId:e,messageId:t,startedAt:n}=this.currentSession,r=Date.now()-n;Ie.info(`Ending streaming session ${e} for message ${t} (duration: ${r}ms)`),this.currentSession=null}getCurrentSession(){return this.currentSession}isActive(e){return!!this.currentSession&&(void 0===e||this.currentSession.messageId===e)}getStatus(){if(!this.currentSession)return{hasActiveSession:!1,sessionId:null,messageId:null,duration:null,queueSize:null,monitorActive:!1,processorActive:!1};const{sessionId:e,messageId:t,startedAt:n,queue:r,monitor:i,processor:s}=this.currentSession;return{hasActiveSession:!0,sessionId:e,messageId:t,duration:Date.now()-n,queueSize:r.size(),monitorActive:i.isActive(),processorActive:s.getStatus().isRunning}}}const Pe='# Universal Image Prompt Generation Guide (Tag-Based)\n\nGenerate tag-based image prompts for AI image generation models. Insert prompts approximately every 250 words or at major scene changes.\n\n**Format:** `\x3c!--img-prompt="your description here"--\x3e`\n\n**Tag-based prompts work universally across Stable Diffusion, NovelAI, FLUX, and most diffusion models.**\n\n---\n\n## Tag-Based Format\n\n**Structure:** Comma-separated tags in priority order (earlier tags = stronger influence)\n\n```\n[subject count], [character details], [action/pose], [environment], [lighting], [style], [quality tags]\n```\n\n**Example:**\n```\n1girl, long silver hair, blue eyes, white dress, standing in garden, surrounded by flowers, afternoon sunlight, soft focus, highly detailed, best quality\n```\n\n---\n\n## Core Components\n\n### 1. Subject Count (Required - Always First)\n\n**Single character:**\n- `1girl` / `1boy` / `1other`\n\n**Multiple characters:**\n- `2girls` / `2boys` / `1boy, 1girl`\n- `3girls` / `2girls, 1boy` / `3boys`\n- Up to 6 characters max\n\n**No humans:**\n- `no humans` (for landscapes, objects, animals only)\n\n### 2. Character Details\n\n**Hair:**\n- Length: `long hair`, `short hair`, `medium hair`, `very long hair`\n- Style: `straight hair`, `wavy hair`, `curly hair`, `ponytail`, `braided hair`, `twin tails`\n- Color: `black hair`, `blonde hair`, `brown hair`, `red hair`, `white hair`, `silver hair`, `blue hair`, `pink hair`\n\n**Eyes:**\n- Color: `blue eyes`, `brown eyes`, `green eyes`, `red eyes`, `purple eyes`, `golden eyes`\n- Features: `heterochromia`, `glowing eyes`, `closed eyes`\n\n**Body:**\n- Build: `slender`, `athletic`, `muscular`, `petite`, `curvy`, `tall`, `short`\n- Features: `pale skin`, `dark skin`, `tan skin`, `freckles`\n\n**Clothing:**\n- Casual: `t-shirt`, `jeans`, `hoodie`, `sweater`, `casual dress`, `shorts`\n- Formal: `suit`, `dress shirt`, `tie`, `formal dress`, `evening gown`, `tuxedo`\n- Fantasy: `armor`, `robe`, `cloak`, `leather outfit`, `mage outfit`, `knight armor`\n- Modern: `school uniform`, `business suit`, `sportswear`, `kimono`, `yukata`\n- State: `partially clothed`, `torn clothes`, `wet clothes`\n\n### 3. Expression & Pose\n\n**Expressions:**\n- `smiling`, `grinning`, `laughing`, `serious`, `sad`, `angry`, `surprised`, `shocked`\n- `gentle smile`, `smirk`, `frown`, `crying`, `blushing`, `embarrassed`\n- `eyes closed`, `looking at viewer`, `looking away`, `looking down`, `looking up`\n\n**Body poses:**\n- Standing: `standing`, `contrapposto`, `casual stance`\n- Sitting: `sitting`, `sitting on chair`, `sitting on ground`, `seiza`, `crossed legs`\n- Action: `running`, `walking`, `jumping`, `fighting`, `dancing`, `flying`, `falling`\n- Resting: `lying down`, `lying on back`, `lying on side`, `reclining`, `sleeping`\n- Other: `kneeling`, `crouching`, `leaning`, `stretching`\n\n**Arms & hands:**\n- `arms at sides`, `arms crossed`, `arms raised`, `arms behind back`, `arms up`\n- `hand on hip`, `hands on hips`, `hands together`, `hand on own chest`\n- `waving`, `pointing`, `reaching`, `grabbing`, `holding object`\n\n**Legs:**\n- `legs crossed`, `legs apart`, `one knee up`, `legs together`\n\n### 4. Environment & Setting\n\n**Indoor locations:**\n- `bedroom`, `living room`, `kitchen`, `bathroom`, `office`, `classroom`\n- `library`, `cafe`, `restaurant`, `shop`, `museum`, `hallway`, `corridor`\n\n**Outdoor locations:**\n- `forest`, `beach`, `mountain`, `field`, `meadow`, `garden`, `park`\n- `city`, `street`, `alley`, `rooftop`, `bridge`, `river`, `lake`\n\n**Fantasy/Sci-fi:**\n- `castle`, `dungeon`, `tower`, `ruins`, `temple`, `shrine`\n- `spaceship`, `space station`, `laboratory`, `futuristic city`, `cyberpunk city`\n\n**Background:**\n- `detailed background`, `simple background`, `blurred background`, `bokeh`\n- `white background`, `black background`, `gradient background`, `abstract background`\n\n**Time & weather:**\n- Time: `morning`, `noon`, `afternoon`, `evening`, `sunset`, `night`, `midnight`, `dawn`, `dusk`\n- Weather: `sunny`, `cloudy`, `overcast`, `rainy`, `snowy`, `foggy`, `misty`, `stormy`\n- Season: `spring`, `summer`, `autumn`, `winter`\n\n### 5. Lighting\n\n**Natural lighting:**\n- `sunlight`, `natural light`, `daylight`, `moonlight`, `starlight`\n- `sunrise`, `sunset`, `golden hour`, `blue hour`, `twilight`\n\n**Quality:**\n- `bright lighting`, `dim lighting`, `dramatic lighting`, `soft lighting`, `harsh lighting`\n- `warm lighting`, `cool lighting`, `volumetric lighting`, `god rays`, `light rays`\n\n**Direction:**\n- `front lighting`, `backlighting`, `side lighting`, `rim lighting`, `top lighting`\n\n**Effects:**\n- `lens flare`, `light particles`, `glowing`, `bloom`, `shadows`, `dappled sunlight`\n\n### 6. Composition & Camera\n\n**Shot types:**\n- `portrait`, `close-up`, `upper body`, `cowboy shot`, `full body`, `wide shot`\n\n**Angles:**\n- `from above`, `from below`, `from side`, `from behind`, `eye level`\n- `bird\'s eye view`, `worm\'s eye view`, `dutch angle`\n\n**Focus:**\n- `centered`, `off-center`, `depth of field`, `shallow depth of field`, `bokeh`\n- `sharp focus`, `blurred foreground`, `blurred background`\n\n### 7. Art Style\n\n**Photography:**\n- `photo`, `photograph`, `photorealistic`, `realistic`, `professional photography`\n- `portrait photography`, `landscape photography`, `candid photo`\n- `film grain`, `35mm`, `50mm`, `85mm`\n\n**Art styles:**\n- `anime`, `anime style`, `manga style`, `cel shaded`, `flat colors`\n- `digital art`, `concept art`, `illustration`, `painting`, `drawing`\n- `oil painting`, `watercolor`, `ink`, `pencil drawing`, `sketch`\n\n**Art movements:**\n- `impressionism`, `art nouveau`, `art deco`, `baroque`, `renaissance`\n- `minimalist`, `abstract`, `surreal`, `pop art`\n\n**Rendering:**\n- `3d render`, `unreal engine`, `octane render`, `ray tracing`\n- `low poly`, `voxel art`, `pixel art`\n\n**Effects:**\n- `cinematic`, `dramatic`, `epic`, `atmospheric`, `moody`\n- `vibrant colors`, `muted colors`, `pastel colors`, `monochrome`, `black and white`\n- `high contrast`, `low contrast`, `saturated`, `desaturated`\n\n### 8. Quality Tags (Always Include)\n\n**Essential:**\n- `masterpiece`, `best quality`, `high quality`\n- `highly detailed`, `extremely detailed`, `intricate details`\n- `absurdres`, `highres`, `8k`, `4k`\n\n**Optional enhancement:**\n- `sharp focus`, `professional`, `award-winning`\n- `beautiful`, `aesthetic`, `stunning`\n\n---\n\n## Tag Weight & Emphasis\n\n**Increase weight:**\n- `(tag:1.5)` - Multiply weight by 1.5\n- `(tag:1.2)` - Multiply weight by 1.2\n\n**Decrease weight:**\n- `(tag:0.8)` - Multiply weight by 0.8\n- `(tag:0.5)` - Multiply weight by 0.5\n\n**Example:**\n```\n1girl, (beautiful face:1.2), (detailed eyes:1.3), highly detailed, best quality\n```\n\n---\n\n## Negative Prompts\n\n**Always include negative prompt to prevent common issues:**\n\n**Quality issues:**\n```\nlowres, low quality, worst quality, normal quality, jpeg artifacts, blurry, out of focus, ugly, bad quality, poor quality\n```\n\n**Anatomy issues:**\n```\nbad anatomy, bad proportions, deformed, disfigured, malformed, mutated, extra limbs, missing limbs, extra arms, extra legs, missing arms, missing legs, extra fingers, missing fingers, fused fingers, too many fingers, bad hands, bad feet, long neck, long body\n```\n\n**Artifacts:**\n```\nwatermark, signature, text, username, artist name, logo, error, cropped, out of frame, border\n```\n\n**Unwanted elements:**\n```\nduplicate, multiple views, copy, split screen\n```\n\n**Style-specific negatives:**\n- For realistic photos: `cartoon, anime, drawing, painting, illustration, 3d, render`\n- For illustrations: `photograph, photo, photorealistic, realistic`\n\n---\n\n## Character Consistency\n\n**For known characters (from anime/game/novel):**\n- Use format: `character_name (series_name)`\n- Examples: `hatsune miku (vocaloid)`, `frieren (sousou no frieren)`, `link (zelda)`\n- Check Danbooru tags for exact format\n- Don\'t override canonical features (hair color, eye color) unless making AU\n\n**For original characters:**\n- Keep identical tags across all prompts\n- Document: hair color, eye color, clothing, distinctive features\n- Use exact same descriptors every time\n\n---\n\n## Example Prompts\n\n**Portrait:**\n```\n\x3c!--img-prompt="1girl, long auburn hair, green eyes, freckles, cream sweater, gentle smile, sitting by window, natural lighting, soft focus, portrait, highly detailed, best quality, masterpiece"--\x3e\n```\n\n**Fantasy scene:**\n```\n\x3c!--img-prompt="1girl, long silver hair, blue eyes, white and gold robes, casting spell, magical energy, glowing hands, ancient library, floating books, glowing runes, ethereal lighting, fantasy, highly detailed, best quality, masterpiece"--\x3e\n```\n\n**Anime style:**\n```\n\x3c!--img-prompt="1girl, long pink hair, blue eyes, school uniform, cheerful smile, waving, cherry blossom trees, petals falling, spring day, anime style, vibrant colors, highly detailed, best quality"--\x3e\n```\n\n**Action scene:**\n```\n\x3c!--img-prompt="1girl, long red hair, armor, wielding sword, dynamic pose, mid-air, jumping, battlefield, explosions, smoke, dramatic lighting, action scene, highly detailed, best quality, masterpiece"--\x3e\n```\n\n**Landscape:**\n```\n\x3c!--img-prompt="no humans, mountain lake, sunset, orange and pink sky, crystal clear water, reflections, pine trees, snow-capped peaks, golden hour, misty, scenic vista, landscape photography, highly detailed, 8k, masterpiece"--\x3e\n```\n\n---\n\n## Quick Template\n\n```\n[count], [hair], [eyes], [clothing], [expression], [pose], [location], [time/weather], [lighting], [style], highly detailed, best quality, masterpiece\n```\n\n---\n\n## Best Practices\n\n1. **Subject count first** - Always start with `1girl`, `2boys`, etc.\n2. **Tag order matters** - Earlier tags have stronger influence\n3. **Be specific** - More detail = better results\n4. **Include quality tags** - Always end with quality modifiers\n5. **Use negative prompts** - Prevent common issues\n6. **Stay consistent** - Same character = same exact tags\n7. **Test weights** - Adjust emphasis for problem areas\n8. **Don\'t over-tag** - Focus on important elements (15-40 tags ideal)\n\n---\n\n## Common Mistakes\n\n Missing subject count: `long hair, blue eyes, standing`\n Include subject: `1girl, long hair, blue eyes, standing`\n\n Vague: `girl in room`\n Specific: `1girl, long black hair, bedroom, sitting on bed, morning light`\n\n No quality tags: `1girl, red hair, smiling`\n With quality: `1girl, red hair, smiling, highly detailed, best quality`\n\n Tag overload: `1girl, beautiful, gorgeous, stunning, amazing, incredible, perfect`\n Balanced: `1girl, beautiful, highly detailed, best quality`\n\n---\n\n**Generate prompts frequently (~250 words). Each `\x3c!--img-prompt="..."--\x3e` on its own line, entire prompt on single line.**\n',Ae="nai-4.5-full";function Re(){return Pe.trim()}const $e=[{id:"default",name:"Default",template:Re(),predefined:!0},{id:Ae,name:"NAI 4.5 Full",template:'# NovelAI 4.5 FULL Image Prompt Generation Guide\n\nGenerate image prompts for NovelAI Diffusion 4.5 Full using structured tag-based prompts. Insert prompts at natural narrative points, approximately every 250 words or at major scene changes.\n\n**IMPORTANT: Generate image prompts frequently throughout the story - aim for approximately one prompt every 250 words or at each major scene change.**\n\n**CRITICAL MULTI-CHARACTER RULE: When a scene has 2 or more characters present, you MUST use the pipe `|` separator syntax. This is NOT optional - it is required for proper multi-character generation.**\n\n---\n\n## Core Philosophy: Tags as Foundation, Prose for Nuance\n\nNovelAI is trained on Danbooru\'s tag system. **Tag-based prompts** (comma-separated) provide the most precise and controllable results for most use cases.\n\n**Tags are superior for:**\n- Character consistency and specific attributes\n- Style control and art medium selection\n- Precise visual elements (colors, clothing, objects)\n- Reproducible and predictable results\n\n**Natural language can enhance prompts for:**\n- Complex scenes with specific moods and atmospheres (e.g., "a sense of tension and anticipation")\n- Intricate relationships between characters (e.g., "a knight protecting a child from a dragon")\n- Nuanced descriptions that tags alone might not capture\n- Creative exploration beyond standard conventions\n\n**Best practice: Hybrid approach**\n- Start with natural language for scene/mood/relationships\n- Follow with tags for precision: quality tags, style tags, specific attributes\n- Example: `A majestic tiger stalking through tropical rainforest, dappled sunlight, masterpiece, best quality, cinematic lighting, vibrant colors, detailed fur`\n\n**However, for most prompts in story illustration, tag-based format is recommended for consistency and control.**\n\n---\n\n## Format Requirements\n\n**Format:** `\x3c!--img-prompt="your description here"--\x3e`\n\n**Frequency:** Insert prompts approximately **every 250 words** or at major scene changes. Don\'t skip scenes - each significant moment should have a visual prompt.\n\n**Example:**\n```\nStory text continues.\n\x3c!--img-prompt="1girl, bedroom, sitting, long hair, smiling, very aesthetic, masterpiece, best quality, highres, no text, no watermark"--\x3e\nMore story text.\n```\n\n---\n\n## Prompt Structure\n\nEvery prompt should follow this order for optimal results:\n\n1. **Subject count tags** (MANDATORY): `1girl`, `2boys`, `1boy, 1girl`, `no humans`\n2. **Character specifics**: Character names, series tags if known\n3. **Quality & aesthetic tags** (MANDATORY): `very aesthetic, masterpiece, best quality, highres, no text, no watermark`\n4. **Style tags**: Art medium, artist style, art movement\n5. **Composition**: Shot type, angle, pose\n6. **Environment**: Location, background details\n7. **Lighting**: Light type, effects\n8. **Color scheme**: Dominant colors, color style\n9. **Detailed descriptors**: Clothing, expression, hair, eyes, accessories\n\n**Tag order matters:** Earlier tags have stronger influence. This is a "priority instruction list", not a "bag of words".\n\n---\n\n## Mandatory Quality Tags\n\n**ALWAYS include these in EVERY prompt for high-quality output:**\n\nNovelAI\'s official default quality tags (recommended to use all):\n- `very aesthetic` - Enhanced aesthetic quality\n- `masterpiece` - Most powerful aesthetic tag for V4.5\n- `best quality` - Essential quality baseline\n- `highres` - High resolution output\n- `no text` - Prevents text artifacts in image\n- `no watermark` - Prevents watermark artifacts\n\nAdditional optional quality tag:\n- `absurdres` - Absolute high resolution quality\n\n**Recommended quality tag string:** `very aesthetic, masterpiece, best quality, highres, no text, no watermark`\n\n---\n\n## Subject Count Tags (MANDATORY)\n\n**Always start prompts with:**\n- `no humans` - No people (landscapes, objects)\n- `1girl` / `1boy` / `1other` - Single character\n- `2girls` / `2boys` / `1boy, 1girl` - Two characters\n- `3girls` / `2girls, 1boy` etc. - Three+ characters (max 6)\n\n---\n\n## Style Control Tags\n\n### Art Medium\n- `oil painting (medium)` - Oil painting texture\n- `watercolor (medium)` - Watercolor transparency\n- `ink (medium)` - Ink/pen drawing style\n- `sketch` - Sketch/rough style\n- `anime screencap` - Anime screenshot style\n- `game cg` - Game CG style\n\n### Art Style\n- `art nouveau` - Decorative curves, organic forms\n- `impressionism` - Light/shadow emphasis\n- `ukiyo-e` - Japanese woodblock print\n- `realistic` / `photorealistic` - Photographic realism\n\n### Coloring\n- `monochrome` - Black and white\n- `pastel colors` - Soft, low saturation colors\n- `limited palette` - Few colors, unified look\n- `high contrast` - Strong light/dark contrast\n\n### Special Effects\n- `bokeh` - Blurred background with light spots\n- `lens flare` - Light flare effect\n- `chromatic aberration` - Color fringing effect\n- `motion blur` - Speed/movement blur\n\n---\n\n## Special Tags\n\n**Year tags:** `year XXXX` - Mimic art style from specific year\n- Example: `year 2014` for 2014 anime aesthetics\n\n**Location tag:** `location` - Combines indoor/outdoor, indicates specific scene needed\n\n**Dataset tags (MUST be at very start):**\n- `fur dataset` - For furry/kemono art\n- `background dataset` - For landscapes, no people, photographic style\n\n---\n\n## Tag Emphasis System\n\n### Bracket Emphasis\n- `{tag}` - Strengthen by 1.05\n- `{{tag}}` - Strengthen by 1.1025\n- `[tag]` - Weaken by 1.05\n- `[[tag]]` - Weaken by 1.1025\n\n### Numerical Emphasis\n- `1.5::tag::` - Multiply weight by 1.5\n- `0.5::tag::` - Multiply weight by 0.5\n- `-1::tag::` - Negative weight (removes/inverts concept)\n\n**Negative weight examples:**\n- `-1::hat::` - Remove hat from character\n- `-1::monochrome::` - Force colorful image\n- `-2.5::flat color::` - Add detailed shading\n\n**In Undesired Content:** Emphasis works in reverse - `{tag}` means avoid more strongly\n\n---\n\n## Multi-Character Prompting (2+ characters)\n\n**CRITICAL: When scenes involve 2+ characters, ALWAYS use the pipe `|` separator syntax for best results.**\n\n** WRONG - Do NOT use this format for multi-character scenes:**\n```\n1boy, 1girl, indoors, living room, close-up, emilia (re:zero), long silver hair, purple eyes, white dress, flushed cheeks, arms around neck, looking at viewer, short dark hair, casual clothes, gentle expression, very aesthetic, masterpiece, best quality, highres, no text, no watermark\n```\n*This format will confuse the AI about which features belong to which character! Both characters\' features are mixed together without clear separation.*\n\n** CORRECT - ALWAYS use pipe separators for 2+ characters:**\n```\n1boy, 1girl, indoors, living room, close-up, intimate distance, very aesthetic, masterpiece, best quality, highres, no text, no watermark | girl, emilia (re:zero), long silver hair, purple eyes, white dress, flushed cheeks, source#embrace, arms around neck, looking at viewer | boy, short dark hair, casual clothes, target#embrace, close to her, gentle expression\n```\n\n**Structure:** `base prompt | character 1 | character 2 | ...`\n\n**Base prompt must include:**\n- Subject count tags (MANDATORY): `2girls`, `1boy, 1girl`, `3boys`, etc.\n- Quality tags (MANDATORY): `very aesthetic, masterpiece, best quality, highres, no text, no watermark`\n- Scene, location, lighting\n- Spatial positioning: `side by side`, `facing each other`, `close together`\n\n**Each character prompt must include:**\n- Character type (no number): `girl`, `boy`, `other`\n- Character name if known: `character_name (series_name)`\n- Physical features: hair color, eye color, body type\n- Clothing, expression, pose\n- Body framing: `upper body`, `full body`, `portrait`\n- **Action tags with prefixes when interacting (see below)**\n\n**Interaction action tag prefixes:**\n\nUse these when characters interact physically or socially:\n\n- `source#[action]` - The character actively performing/initiating the action\n- `target#[action]` - The character passively receiving the action\n- `mutual#[action]` - Both characters doing the action together simultaneously\n\n**Common interaction actions:**\n\n**Physical contact:**\n- Hugging: `source#hug` (person hugging), `target#hug` (being hugged), `mutual#hug` (both hugging each other)\n- Kissing: `source#kiss` (initiating kiss), `target#kiss` (receiving kiss), `mutual#kiss` (both kissing)\n- Headpat: `source#headpat` (giving headpat), `target#headpat` (receiving headpat)\n- Embrace: `source#embrace` (embracing), `target#embrace` (being embraced)\n- Hand holding: `mutual#handholding` (both holding hands)\n- Dancing: `mutual#dancing` (dancing together)\n- High five: `mutual#high five` (both giving high five)\n\n**Visual interaction:**\n- Looking: `source#looking at another` (actively looking), `target#being looked at` (being looked at)\n\n**Social interaction:**\n- Communication: `source#talking`, `target#listening`\n- Pointing: `source#pointing`, `target#pointed at`\n- Laughing: `mutual#laughing` (laughing together)\n- Playing: `mutual#playing` (playing together)\n\n**When to use which prefix:**\n- If one character is clearly doing something TO another  use `source#` and `target#`\n- If both characters are doing the same action together  use `mutual#` for both\n- Example: Person A hugging Person B  A gets `source#hug`, B gets `target#hug`\n- Example: Two people hugging each other equally  Both get `mutual#hug`\n\n**Why this matters:** Without pipe separators and proper action tags, the AI cannot properly understand which physical features and actions belong to which character, leading to confused or incorrect anatomy.\n\n---\n\n## Composition & Framing\n\n**Always specify framing:**\n- `portrait` - Head and shoulders\n- `upper body` - Waist up\n- `cowboy shot` - Thighs up\n- `full body` - Entire body visible\n- `from above` / `from below` / `from side` / `from behind` - Camera angle\n\n**Pose details (be specific):**\n- Arms: `arms at sides`, `arms crossed`, `arms raised`, `one arm raised`\n- Hands: `hands on hips`, `hands clasped`, `hand in hair`, `hands together`\n- Legs: `legs crossed`, `legs apart`, `one knee up`\n- Sitting: `sitting`, `seiza`, `crossed legs`, `legs to side`\n- Standing: `standing`, `contrapposto`, `casual stance`\n- Action: `walking`, `running`, `jumping`, `reaching`\n\n**More detail = Better anatomy.** For complex poses, add MORE tags, not fewer.\n\n---\n\n## Negative Prompts (Undesired Content)\n\n**Core principle:** Describe what you DON\'T want directly (use `blurry`, not `not sharp`)\n\n**Essential negative prompts:**\n\n**Quality:**\n`lowres, worst quality, bad quality, normal quality, low quality, jpeg artifacts, blurry, ugly`\n\n**Anatomy:**\n`bad anatomy, bad hands, missing fingers, extra digit, fewer digits, bad feet, malformed limbs, extra limbs, fused fingers, bad proportions`\n\n**Artifacts:**\n`text, watermark, signature, username, artist name, error, cropped, out of frame`\n\n**Style issues:**\n`monochrome` (if want color), `sketch` (if want finished), `duplicate, mutation, deformed, bad composition`\n\n**Warning:** Over-stuffing negative prompts can reduce AI creativity. Use strategically based on specific needs.\n\n---\n\n## Character Consistency\n\n**For known characters (from anime/game/novel):**\n- **CRITICAL: Always use Danbooru character tags** in format: `character_name (series_name)`\n- This ensures the AI recognizes the character and generates consistent appearance\n- Examples: `nilou (genshin impact)`, `frieren (sousou no frieren)`, `hatsune miku (vocaloid)`\n- Check Danbooru to find the exact tag format for the character\n- **IMPORTANT: When using character tags, DO NOT override their canonical features (hair color, eye color, etc.) unless intentionally creating an AU version**\n\n**For original characters:**\n- Use identical descriptions throughout: hair color, eye color, body type, clothing, distinctive features\n- Be consistent with every detail to maintain character appearance across multiple images\n- Keep a character reference sheet with exact tags to use consistently\n\n---\n\n## Example Prompts\n\n**Single character:**\n```\n\x3c!--img-prompt="1girl, bedroom, morning sunlight, sitting on bed, long red hair, purple eyes, peaceful expression, white nightgown, very aesthetic, masterpiece, best quality, highres, no text, no watermark, soft lighting, detailed background"--\x3e\n```\n\n**No humans landscape:**\n```\n\x3c!--img-prompt="no humans, ancient forest, towering trees, dappled sunlight, moss-covered ground, mysterious atmosphere, very aesthetic, masterpiece, best quality, highres, no text, no watermark, detailed, fantasy"--\x3e\n```\n\n**Two characters with mutual interaction (cuddling):**\n```\n\x3c!--img-prompt="1boy, 1girl, living room, afternoon, sitting on couch, close together, mutual#cuddling, very aesthetic, masterpiece, best quality, highres, no text, no watermark, soft lighting, warm atmosphere | girl, emilia (re:zero), long silver hair, purple eyes, white dress, leaning against him, head on shoulder, smiling, eyes closed, relaxed expression | boy, short black hair, blue eyes, casual shirt and jeans, arm around her shoulders, gentle smile, looking down at her"--\x3e\n```\n\n**Two characters with source/target interaction (embrace):**\n```\n\x3c!--img-prompt="1boy, 1girl, bedroom, evening, close-up, intimate distance, very aesthetic, masterpiece, best quality, highres, no text, no watermark, soft lighting | girl, emilia (re:zero), long silver hair, purple eyes, white dress, flushed cheeks, source#embrace, arms around his neck, looking up at him, gentle smile | boy, short dark hair, brown eyes, casual shirt, target#embrace, hands on her waist, looking down at her, affectionate expression"--\x3e\n```\n\n**Two characters - headpat interaction:**\n```\n\x3c!--img-prompt="1boy, 1girl, school hallway, afternoon, standing, very aesthetic, masterpiece, best quality, highres, no text, no watermark | boy, tall, short brown hair, school uniform, source#headpat, hand on her head, smiling, looking down at her | girl, shorter, long black hair, school uniform, target#headpat, looking up, blushing, happy expression, hands clasped in front"--\x3e\n```\n\n**Group scene - three characters:**\n```\n\x3c!--img-prompt="3girls, park, sunny day, standing together, cherry blossoms, very aesthetic, masterpiece, best quality, highres, no text, no watermark, vibrant colors, spring atmosphere | girl, long blonde hair, green eyes, sundress, holding ice cream, laughing, looking at friends | girl, short pink hair, blue eyes, casual t-shirt and shorts, peace sign, cheerful smile | girl, medium brown hair, brown eyes, cardigan and skirt, shy smile, holding camera"--\x3e\n```\n\n**Action scene - running:**\n```\n\x3c!--img-prompt="1girl, city street, late afternoon, running, dynamic pose, motion blur background, very aesthetic, masterpiece, best quality, highres, no text, no watermark, cinematic | girl, frieren (sousou no frieren), long white hair flowing, green eyes, mage outfit, determined expression, full body, from side, arms pumping"--\x3e\n```\n\n**Character portrait:**\n```\n\x3c!--img-prompt="1girl, indoor cafe, afternoon window light, portrait, close-up, very aesthetic, masterpiece, best quality, highres, no text, no watermark, bokeh background, warm lighting | girl, long black hair, brown eyes, cozy sweater, holding coffee cup, gentle smile, looking at viewer, soft expression"--\x3e\n```\n\n---\n\n## Critical Reminders\n\n- **GENERATE FREQUENTLY: Every ~250 words or major scene change**\n- **ALWAYS include official quality tags: `very aesthetic, masterpiece, best quality, highres, no text, no watermark`**\n- **ALWAYS include subject count tags: `1girl`, `2boys`, `1boy, 1girl`, etc.**\n- **For known characters: MUST use Danbooru character tags `character_name (series_name)` and DO NOT override canonical features**\n- **Tag order matters: Earlier tags = stronger influence**\n- ** CRITICAL: For 2+ characters, MUST use `|` separator - NO EXCEPTIONS**\n- ** CRITICAL: For character interactions, use appropriate action tags:**\n  - `source#[action]` for character performing action\n  - `target#[action]` for character receiving action  \n  - `mutual#[action]` for simultaneous mutual action\n- **More specific tags = better anatomy**\n- **Complex poses need MAXIMUM detail**\n- **Use emphasis system for fine control: `{tag}`, `1.5::tag::`, `-1::tag::`**\n\n---\n\n**Provide the complete story content with image prompts inserted at natural narrative moments. Each `\x3c!--img-prompt="..."--\x3e` tag must be on its own line (no extra blank lines before/after), with entire tag content on a single line.**\n'.trim(),predefined:!0}];function Ne(e,t){const n=t.find((t=>t.id===e));if(n)return n;const r=function(e){return $e.find((t=>t.id===e))}(e);return r||$e[0]}function Ce(e){return $e.some((t=>t.id===e))}function Me(){return{...k,metaPrompt:Re()}}function Oe(e){const t=Me(),n=e.extensionSettings[y];if(!n)return t;const r={...t,...n},i=Ne(r.currentPresetId,r.customPresets||[]);return r.metaPrompt=i.template,r}function De(e,t){t.extensionSettings[y]=e,t.saveSettingsDebounced()}const Le='**TASK:** Update an image generation prompt based on user feedback.\n\n**Current Prompt Tags:**\n{{{currentPrompt}}}\n\n**User\'s Requested Changes:**\n{{{userFeedback}}}\n\n**Your Task:**\n1. Modify the current tags based on the user\'s feedback\n2. Keep the comma-separated tag format (e.g., "tag1, tag2, tag3")\n3. Preserve tags not mentioned in the feedback\n4. Output ONLY the updated tags in HTML comment format\n5. Do NOT write explanations, stories, or conversational text\n\n**Required Output Format:**\n\x3c!--img-prompt="updated tags here"--\x3e\n\n**Examples:**\n\nInput tags: "1girl, red hair, blue eyes, park"\nFeedback: "change to indoor bedroom"\nOutput: \x3c!--img-prompt="1girl, red hair, blue eyes, bedroom, indoors"--\x3e\n\nInput tags: "1boy, sword, battle, outdoor"\nFeedback: "make it peaceful, remove sword"\nOutput: \x3c!--img-prompt="1boy, peaceful, outdoor, nature"--\x3e\n\n**CRITICAL:** Output ONLY the HTML comment line. No other text.\n\n**Your output:**\n',Ge=L("PromptUpdater");async function qe(e,t,n){Ge.info(`Updating prompt at position ${e.messageId}_${e.promptIndex} with feedback: "${t}"`);const r=H(e,n);if(!r)return Ge.error(`No prompt found at position ${e.messageId}_${e.promptIndex}`),null;const i=Y(r,n);if(!i)return Ge.error(`Prompt text not found for ID: ${r}`),null;if(!n.generateRaw)throw Ge.error("generateRaw not available in context"),new Error("LLM generation not available");const s=Le.replace("{{{currentPrompt}}}",i).replace("{{{userFeedback}}}",t);let o;Ge.debug("Sending prompt to LLM for update (using generateRaw)");try{o=await n.generateRaw({systemPrompt:"You are a technical assistant helping to update image generation prompts. Output ONLY the updated prompt in HTML comment format. Do NOT write stories, explanations, or continue any roleplay.",prompt:s})}catch(e){throw Ge.error("LLM generation failed:",e),e}const a=function(e){for(const t of x){const n=new RegExp(t,"i"),r=e.match(n);if(r&&r[1])return r[1]}return null}(o);if(!a)return Ge.error("Failed to extract prompt from LLM response:",o),null;Ge.info(`LLM generated updated prompt: "${a}"`);const l=z(a,n);return await async function(e,t,n,r){const i=U(r),s=F(e),o=i.promptPositionHistory[s];if(!o)throw new Error(`No history found for position: ${s}`);o.versions.push({promptId:t,feedback:n,timestamp:Date.now()}),j.info(`Added prompt version to ${s}: ${t} (${o.versions.length} versions)`);const a=i.promptIdToText[t];if(!a)throw new Error(`Prompt text not found for ID: ${t}`);const l=r.chat[e.messageId];if(!l)throw new Error(`Message not found: ${e.messageId}`);l.mes=function(e,t,n){let r=0;return e.replace(/<!--img-prompt="([^"]*)"-->/g,(e=>{const i=r;return r++,i===t?`\x3c!--img-prompt="${n}"--\x3e`:e}))}(l.mes,e.promptIndex,a),await r.saveChat()}(e,l,t,n),l}const Be=L("ManualGen");async function je(e,t,n,r){return se(e,(async()=>{try{if(et(e))return Be.warn(`Cannot generate images for message ${e}: streaming is active`),toastr.warning(q("toast.cannotGenerateMessageStreaming"),q("extensionName")),0;Be.info(`Generating images for message ${e} in ${t} mode`);const i=n.chat?.[e];if(!i)return Be.warn("Message not found:",e),toastr.error(q("toast.messageNotFound"),q("extensionName")),0;let s=i.mes;const o=S(s,r.promptDetectionPatterns);if(0===o.length)return Be.info("No prompts found in message"),toastr.info(q("toast.noPromptsFound"),q("extensionName")),0;if(Be.info(`Found ${o.length} prompts`),"replace"===t){const e=s.length;s=function(e,t){const n=S(e,t);let r=e;for(let e=n.length-1;e>=0;e--){const t=n[e],i=r.substring(t.endIndex),s=/^\s*<img\s+[^>]*>/g;let o,a=0;for(;null!==(o=s.exec(i))&&o.index===a;)a+=o[0].length,s.lastIndex=a;a>0&&(r=r.substring(0,t.endIndex)+r.substring(t.endIndex+a))}return r}(s,r.promptDetectionPatterns),Be.info(`Replace mode: removed existing images (${e} -> ${s.length} chars)`)}else Be.info("Append mode: will append new images after existing ones");const a=S(s,r.promptDetectionPatterns);toastr.info(B(a.length,"toast.generatingImages"),q("extensionName")),ne(e,a.length);const l=performance.now(),c=[];for(let t=0;t<a.length;t++){const i=a[t];Be.info(`Generating image ${t+1}/${a.length}`);const s=await pe(i.prompt,n,r.commonStyleTags,r.commonStyleTagsPosition);s&&c.push({prompt:i,imageUrl:s,originalIndex:t}),ee(e,t+1,a.length)}c.sort(((e,t)=>t.prompt.startIndex-e.prompt.startIndex));let u=0;for(const{prompt:e,imageUrl:n,originalIndex:r}of c){const i=e.fullMatch,o=s.indexOf(i);if(-1!==o){let e=o+i.length;if("append"===t){const t=s.substring(e),n=/\s*<img\s+[^>]*>/g;let r,i=0;for(;null!==(r=n.exec(t))&&(r.index===i||""===t.substring(i,r.index).trim());)i=n.lastIndex;i>0&&(e+=i)}const a=`AI generated image #${r+1}`,l=`\n<img src="${n}" title="${a}" alt="${a}">`;s=s.substring(0,e)+l+s.substring(e),u++}else Be.warn(`Could not find prompt tag in text: "${i.substring(0,80)}..."`)}const d=performance.now()-l;Be.info(`Generated ${u}/${a.length} images (${d.toFixed(0)}ms total)`),i.mes=s;const p=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(p,e),n.updateMessageBlock(e,i);const m=n.eventTypes.MESSAGE_UPDATED;return await n.eventSource.emit(m,e),await n.saveChat(),Be.debug("Chat saved after manual generation"),te(e),u===a.length?toastr.success(B(u,"toast.successGenerated"),q("extensionName")):u>0?toastr.warning(q("toast.partialGenerated",{success:u,total:a.length}),q("extensionName")):toastr.error(q("toast.failedToGenerate"),q("extensionName")),u}catch(t){return Be.error("Error during manual image generation:",t),toastr.error(q("toast.failedToGenerate"),q("extensionName")),te(e),0}}),"manual image generation")}function Fe(e,t,n){const r=new RegExp(`<img\\s+src="${t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}"[^>]*>`,"g").exec(e);if(!r)return Be.warn("Image not found in message text:",t),null;const i=r.index,s=S(e.substring(0,i),n);return 0===s.length?(Be.warn("No prompt found before image"),null):s[s.length-1].prompt}async function Ue(e,t,n,r,i){return se(e,(async()=>{try{if(et(e))return Be.warn(`Cannot regenerate image for message ${e}: streaming is active`),toastr.warning(q("toast.cannotGenerateMessageStreaming"),q("extensionName")),0;let s=r.chat?.[e];if(!s)return Be.error("Message not found:",e),toastr.error(q("toast.messageNotFound"),q("extensionName")),0;const o=Fe(s.mes||"",t,i.promptDetectionPatterns);if(!o)return toastr.error(q("toast.promptNotFoundForImage"),q("extensionName")),0;Be.info(`Regenerating image for prompt: "${o}" (mode: ${n})`),ne(e,1),toastr.info(q("toast.generatingNewImage"),q("extensionName"));const a=await pe(o,r,i.commonStyleTags,i.commonStyleTagsPosition);if(ee(e,1,1),!a)return toastr.error(q("toast.failedToGenerateImage"),q("extensionName")),te(e),0;if(s=r.chat?.[e],!s)return Be.error("Message not found after generation:",e),toastr.error(q("toast.messageDisappeared"),q("extensionName")),0;let l=s.mes||"";const c=function(e,t,n,r){const i=S(e,r).find((e=>e.prompt===t));if(!i)return null;const s=i.fullMatch,o=i.startIndex,a=e.substring(o+s.length),l=/\s*<img\s+[^>]*>/g;let c,u=0,d=0;for(;null!==(c=l.exec(a))&&(c.index===d||""===a.substring(d,c.index).trim());)if(u++,d=l.lastIndex,c[0].includes(`src="${n}"`))return u;return null}(l,o,t,i.promptDetectionPatterns);if(!c)return Be.error("Could not determine image index for regeneration"),toastr.error(q("toast.failedToDetermineIndex"),q("extensionName")),0;const u=S(l,i.promptDetectionPatterns).find((e=>e.prompt===o));if(!u)return Be.error("Prompt tag not found in text"),toastr.error(q("toast.failedToFindPromptTag"),q("extensionName")),0;const d=u.fullMatch;let p=u.startIndex+d.length;if("replace"===n){const e=l.substring(p),n=t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),r=new RegExp(`\\s*<img\\s+src="${n}"[^>]*>`,""),i=e.match(r);if(i&&void 0!==i.index){const e=p+i.index,t=e+i[0].length;l=l.substring(0,e)+l.substring(t),p=e,Be.info("Removed and will replace clicked image at same position")}else Be.warn("Could not find clicked image in text, will append instead")}else{const e=l.substring(p),t=/\s*<img\s+[^>]*>/g;let n,r=0;for(;null!==(n=t.exec(e))&&(n.index===r||""===e.substring(r,n.index).trim());)r=t.lastIndex;r>0&&(p+=r)}const m=function(e,t,n,r){const i=S(e,r).find((e=>e.prompt===t));if(!i)return 0;const s=i.fullMatch,o=i.startIndex,a=e.substring(o+s.length),l=/\s*<img\s+[^>]*>/g;let c,u=0,d=0;const p=new RegExp(`AI generated image #${n} \\(Regenerated (\\d+)\\)`);for(;null!==(c=l.exec(a))&&(c.index===d||""===a.substring(d,c.index).trim());){d=l.lastIndex;const e=c[0].match(p);if(e){const t=parseInt(e[1],10);t>u&&(u=t)}}return u}(l,o,c,i.promptDetectionPatterns),g=`AI generated image #${c} (Regenerated ${m+1})`,h=`\n<img src="${a}" title="${g}" alt="${g}">`;l=l.substring(0,p)+h+l.substring(p),s.mes=l;const f=r.eventTypes.MESSAGE_EDITED;await r.eventSource.emit(f,e),r.updateMessageBlock(e,s);const _=r.eventTypes.MESSAGE_UPDATED;return await r.eventSource.emit(_,e),await r.saveChat(),toastr.success(q("toast.imageRegenerated"),q("extensionName")),Be.info("Image regenerated successfully"),te(e),setTimeout((()=>{We(r,i)}),100),1}catch(t){return Be.error("Error during image regeneration:",t),toastr.error(q("toast.failedToGenerateImage"),q("extensionName")),te(e),0}}),"image regeneration")}async function ze(e,t,n,r){if(et(e))return void toastr.warning(q("toast.cannotManualWhileStreaming"),q("extensionName"));const i=await se(e,(async()=>await async function(e,t,n,r){const i=$("#auto_illustrator_prompt_update_dialog");if(i.length>0)return Be.debug("Dialog already open, closing it"),$(".auto-illustrator-dialog-backdrop").remove(),i.remove(),null;const s=n.chat?.[e];if(!s)return Be.error("Message not found:",e),toastr.error(q("toast.messageNotFound"),q("extensionName")),null;Be.debug("showPromptUpdateDialogImpl called",{messageId:e,imageSrc:t,messageText:s.mes.substring(0,200)});const o=function(e,t,n,r){const i=new RegExp(`<img\\s+src="${t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}"[^>]*>`,"g").exec(n);if(!i)return Be.warn("Image not found in message text:",t),null;const s=i.index,o=S(n.substring(0,s),r);if(0===o.length)return Be.warn("No prompt found before image"),null;const a=o[o.length-1].prompt,l=S(n,r).findIndex((e=>e.prompt===a));return-1===l?(Be.warn("Could not find prompt index in full message"),null):{messageId:e,promptIndex:l}}(e,t,s.mes,r.promptDetectionPatterns);if(!o)return Be.error("Could not find prompt position for image",{imageSrc:t,messageId:e}),toastr.error(q("toast.promptNotFoundForImage"),q("extensionName")),null;Be.debug("Found prompt position",o);const a=H(o,n),l=a?Y(a,n):Fe(s.mes,t,r.promptDetectionPatterns);if(!l)return toastr.error(q("toast.promptNotFoundForImage"),q("extensionName")),null;const c=l;if(Be.debug("Current prompt extracted",{currentPrompt:c,currentPromptId:a}),!a){Be.info("Initializing metadata for legacy prompt",{position:o,promptText:c});W(o,z(c,n),n)}const u=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),n=$("<div>").attr("id","auto_illustrator_prompt_update_dialog").addClass("auto-illustrator-dialog");n.append($("<h3>").text(q("dialog.updatePromptTitle"))),n.append($("<label>").text(q("dialog.currentPrompt")));const r=$("<div>").addClass("auto-illustrator-current-prompt").text(c);n.append(r),n.append($("<label>").text(q("dialog.userFeedback")));const i=$("<textarea>").addClass("auto-illustrator-feedback-textarea").attr("placeholder",q("dialog.feedbackPlaceholder")).attr("rows","4");n.append(i);const s=$("<div>").addClass("auto-illustrator-dialog-buttons"),o=$("<button>").text(q("dialog.updateWithAI")).addClass("menu_button").on("click",(()=>{const r=i.val();r&&""!==r.trim()?(t.remove(),n.remove(),e(r.trim())):toastr.warning(q("toast.feedbackRequired"),q("extensionName"))})),a=$("<button>").text(q("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e(null)}));s.append(o).append(a),n.append(s),$("body").append(t).append(n),t.on("click",(()=>{t.remove(),n.remove(),e(null)})),i.focus()}));if(!u)return Be.info("Prompt update cancelled by user"),null;try{toastr.info(q("toast.updatingPromptWithAI"),q("extensionName"));const t=await qe(o,u,n);if(!t)return Be.error("Failed to update prompt - LLM returned null"),toastr.error(q("toast.failedToUpdatePrompt"),q("extensionName")),null;const i=Y(t,n);if(!i)return Be.error("Failed to get prompt text for new prompt ID"),toastr.error(q("toast.failedToUpdatePrompt"),q("extensionName")),null;Be.info(`Prompt updated: "${c}" -> "${i}"`);const a=S(s.mes,r.promptDetectionPatterns)[o.promptIndex];if(!a)return Be.error("Could not find prompt match in message"),toastr.error(q("toast.failedToUpdatePrompt"),q("extensionName")),null;let l=s.mes;const d=a.fullMatch,p=c.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),m=d.replace(new RegExp(p,"g"),i);l=l.replace(d,m),s.mes=l;const g=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(g,e),n.updateMessageBlock(e,s);const h=n.eventTypes.MESSAGE_UPDATED;await n.eventSource.emit(h,e),await n.saveChat(),toastr.success(q("toast.promptUpdated"),q("extensionName"));const f=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),n=$("<div>").attr("id","auto_illustrator_regen_confirm_dialog").addClass("auto-illustrator-dialog");n.append($("<p>").text(q("dialog.promptUpdatedRegenerateWithMode")));const i=$("<div>").addClass("auto-illustrator-mode-group"),s=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("replace").prop("checked","replace"===r.manualGenerationMode)).append($("<span>").html(`<strong>${q("dialog.replace")}</strong> ${q("dialog.replaceRegen")}`)),o=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("append").prop("checked","append"===r.manualGenerationMode)).append($("<span>").html(`<strong>${q("dialog.append")}</strong> ${q("dialog.appendRegen")}`));i.append(o).append(s),n.append(i);const a=$("<div>").addClass("auto-illustrator-dialog-buttons"),l=$("<button>").text(q("dialog.generate")).addClass("menu_button").on("click",(()=>{const r=n.find('input[name="regen_mode"]:checked').val();t.remove(),n.remove(),e(r)})),c=$("<button>").text(q("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e(null)}));a.append(l).append(c),n.append(a),$("body").append(t).append(n),t.on("click",(()=>{t.remove(),n.remove(),e(null)}))}));return Be.info("User selected regeneration mode:",f),f}catch(e){return Be.error("Error updating prompt:",e),toastr.error(q("toast.failedToUpdatePrompt"),q("extensionName")),null}}(e,t,n,r)),"prompt update dialog");i&&(Be.info("Regenerating after prompt update",{mode:i}),await Ue(e,t,i,n,r))}async function Ve(e,t,n,r){if(et(e))return void toastr.warning(q("toast.cannotGenerateMessageStreaming"),q("extensionName"));const i=$("#auto_illustrator_regen_dialog");if(i.length>0)return Be.debug("Dialog already open, closing it"),$(".auto-illustrator-dialog-backdrop").remove(),void i.remove();const s=q("dialog.whatToDo"),o=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),n=$("<div>").attr("id","auto_illustrator_regen_dialog").addClass("auto-illustrator-dialog");n.append($("<p>").text(s));const i=$("<div>").addClass("auto-illustrator-mode-group"),o=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("replace").prop("checked","replace"===r.manualGenerationMode)).append($("<span>").html(`<strong>${q("dialog.replace")}</strong> ${q("dialog.replaceRegen")}`)),a=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","regen_mode").val("append").prop("checked","append"===r.manualGenerationMode)).append($("<span>").html(`<strong>${q("dialog.append")}</strong> ${q("dialog.appendRegen")}`));i.append(a).append(o),n.append(i);const l=$("<div>").addClass("auto-illustrator-dialog-buttons"),c=$("<button>").text(q("dialog.generate")).addClass("menu_button").on("click",(()=>{const r=n.find('input[name="regen_mode"]:checked').val();t.remove(),n.remove(),e(r)})),u=$("<button>").text(q("dialog.updatePrompt")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e("update_prompt")})),d=$("<button>").text(q("dialog.delete")).addClass("menu_button caution").on("click",(()=>{t.remove(),n.remove(),e("delete")})),p=$("<button>").text(q("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),n.remove(),e(null)}));l.append(c).append(u).append(d).append(p),n.append(l),$("body").append(t).append(n),t.on("click",(()=>{t.remove(),n.remove(),e(null)}))}));o?"delete"===o?await async function(e,t,n,r){return se(e,(async()=>{const i=n.chat?.[e];if(!i)return Be.error("Message not found:",e),toastr.error(q("toast.messageNotFound"),q("extensionName")),!1;let s=i.mes||"";const o=s.length,a=t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),l=new RegExp(`\\s*<img\\s+src="${a}"[^>]*>`,"g");if(s=s.replace(l,""),s.length===o)return Be.warn("Image not found in message text"),toastr.warning(q("toast.imageNotFound"),q("extensionName")),!1;i.mes=s;const c=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(c,e),n.updateMessageBlock(e,i);const u=n.eventTypes.MESSAGE_UPDATED;return await n.eventSource.emit(u,e),await n.saveChat(),toastr.success(q("toast.imageDeleted"),q("extensionName")),Be.info("Image deleted successfully"),setTimeout((()=>{We(n,r)}),100),!0}),"image deletion")}(e,t,n,r):"update_prompt"===o?await ze(e,t,n,r):await Ue(e,t,o,n,r):Be.info("Action cancelled by user")}function We(e,t){$('.mes_text img[title^="AI generated image"]').off("click.auto_illustrator_regen"),$('.mes_text img[title^="AI generated image"]').on("click.auto_illustrator_regen",(function(){const n=$(this),r=n.closest(".mes").attr("mesid");if(!r)return void Be.warn("Could not find message ID for clicked image");const i=parseInt(r,10);if(isNaN(i))return void Be.warn("Invalid message ID:",r);const s=n.attr("src");s?(Be.info(`Image clicked: messageId=${i}, src=${s.substring(0,50)}...`),Ve(i,s,e,t)):Be.warn("Image has no src attribute")})),Be.debug(`Added click handlers to ${$('.mes_text img[title^="AI generated image"]').length} images`)}function He(e,t,n,r){const i=n.chat?.[t];if(!i||i.is_user)return;if(!I(i.mes))return;const s=$(e);if(s.find(".auto_illustrator_manual_gen").length>0)return;const o=$("<div>").addClass("mes_button auto_illustrator_manual_gen fa-solid fa-wand-magic-sparkles").attr("title",q("button.manualGenerate")).on("click",(async()=>{if(et(t))toastr.warning(q("toast.cannotGenerateMessageStreaming"),q("extensionName"));else{o.prop("disabled",!0),o.css("opacity","0.5");try{await async function(e,t,n){if(et(e))return void toastr.warning(q("toast.cannotGenerateMessageStreaming"),q("extensionName"));const r=$("#auto_illustrator_manual_gen_dialog");if(r.length>0)return Be.debug("Dialog already open, closing it"),$(".auto-illustrator-dialog-backdrop").remove(),void r.remove();const i=t.chat?.[e];if(!i)return void Be.warn("Message not found:",e);const s=S(i.mes,n.promptDetectionPatterns);if(0===s.length)return void toastr.info(q("toast.noPromptsFound"),q("extensionName"));const o=B(s.length,"dialog.foundPrompts")+"\n\n"+q("dialog.howToGenerate"),a=await new Promise((e=>{const t=$("<div>").addClass("auto-illustrator-dialog-backdrop"),r=$("<div>").attr("id","auto_illustrator_manual_gen_dialog").addClass("auto-illustrator-dialog");r.append($("<p>").text(o));const i=$("<div>").addClass("auto-illustrator-mode-group"),s=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","generation_mode").val("replace").prop("checked","replace"===n.manualGenerationMode)).append($("<span>").html(`<strong>${q("dialog.replace")}</strong> ${q("dialog.replaceDesc")}`)),a=$("<label>").addClass("auto-illustrator-mode-option").append($("<input>").attr("type","radio").attr("name","generation_mode").val("append").prop("checked","append"===n.manualGenerationMode)).append($("<span>").html(`<strong>${q("dialog.append")}</strong> ${q("dialog.appendDesc")}`));i.append(a).append(s),r.append(i);const l=$("<div>").addClass("auto-illustrator-dialog-buttons"),c=$("<button>").text(q("dialog.generate")).addClass("menu_button").on("click",(()=>{const n=r.find('input[name="generation_mode"]:checked').val();t.remove(),r.remove(),e(n)})),u=$("<button>").text(q("dialog.cancel")).addClass("menu_button").on("click",(()=>{t.remove(),r.remove(),e(null)}));l.append(c).append(u),r.append(l),$("body").append(t).append(r),t.on("click",(()=>{t.remove(),r.remove(),e(null)}))}));a?await je(e,a,t,n):Be.info("Generation cancelled by user")}(t,n,r)}finally{o.prop("disabled",!1),o.css("opacity","1")}}})),a=s.find(".extraMesButtons");a.length>0&&a.append(o)}const Ye=L("Main");let Ke,Xe,Qe,Je=!1,Ze=null;function et(e){return Qe?.isActive(e)??!1}function tt(e){return Qe?.isActive(e)??!1}function nt(){const e=document.getElementById(T.ENABLED),t=document.getElementById(T.META_PROMPT),n=document.getElementById(T.META_PROMPT_PRESET_SELECT),r=document.getElementById(T.META_PROMPT_PRESET_DELETE),i=document.getElementById(T.PRESET_EDITOR),s=document.getElementById(T.PRESET_VIEWER),o=document.getElementById(T.PRESET_PREVIEW),a=document.getElementById(T.STREAMING_ENABLED),l=document.getElementById(T.STREAMING_POLL_INTERVAL),c=document.getElementById(T.MAX_CONCURRENT),u=document.getElementById(T.MIN_GENERATION_INTERVAL),d=document.getElementById(T.LOG_LEVEL),p=document.getElementById(T.PROMPT_PATTERNS),m=document.getElementById(T.COMMON_STYLE_TAGS),g=document.getElementById(T.COMMON_STYLE_TAGS_POSITION),h=document.getElementById(T.MANUAL_GEN_MODE);if(e&&(e.checked=Xe.enabled),a&&(a.checked=Xe.streamingEnabled),l&&(l.value=Xe.streamingPollInterval.toString()),c&&(c.value=Xe.maxConcurrentGenerations.toString()),u&&(u.value=Xe.minGenerationInterval.toString()),d&&(d.value=Xe.logLevel),p&&(p.value=Xe.promptDetectionPatterns.join("\n")),m&&(m.value=Xe.commonStyleTags),g&&(g.value=Xe.commonStyleTagsPosition),h&&(h.value=Xe.manualGenerationMode),n){const e=n.querySelector("#custom_presets_group");e&&(e.innerHTML="",Xe.customPresets.forEach((t=>{const n=document.createElement("option");n.value=t.id,n.textContent=t.name,e.appendChild(n)}))),n.value=Xe.currentPresetId}if(r){const e=Ce(Xe.currentPresetId);r.disabled=e,r.title=e?"Cannot delete predefined presets":"Delete custom preset"}o&&(o.textContent=Xe.metaPrompt),t&&(t.value=Xe.metaPrompt),i&&(i.style.display="none"),s&&(s.style.display="block"),Je=!1,rt()}function rt(){const e=document.getElementById(T.PATTERN_VALIDATION_STATUS);if(!e)return;const t=function(){const e=Xe.metaPrompt,t=Xe.promptDetectionPatterns;if(!e||!t||0===t.length)return!1;try{return v(e,t).length>0}catch(e){return Ye.warn("Error validating prompt patterns:",e),!1}}();e.className="pattern-validation-status",t?(e.classList.add("validation-success"),e.innerHTML=`\n      <span class="validation-message">${q("settings.validationSuccess")}</span>\n    `):(e.classList.add("validation-warning"),e.innerHTML=`\n      <span class="validation-message">${q("settings.validationWarning")}</span>\n      <span class="validation-hint">${q("settings.validationHint")}</span>\n    `)}function it(e,t,n,r){const i=Math.round(e/r)*r;return Math.max(t,Math.min(n,i))}function st(){const e=document.getElementById(T.ENABLED),t=document.getElementById(T.META_PROMPT),n=document.getElementById(T.STREAMING_ENABLED),r=document.getElementById(T.STREAMING_POLL_INTERVAL),i=document.getElementById(T.MAX_CONCURRENT),s=document.getElementById(T.MIN_GENERATION_INTERVAL),o=document.getElementById(T.LOG_LEVEL),a=document.getElementById(T.PROMPT_PATTERNS),l=document.getElementById(T.COMMON_STYLE_TAGS),c=document.getElementById(T.COMMON_STYLE_TAGS_POSITION),u=document.getElementById(T.MANUAL_GEN_MODE);if(Xe.enabled=e?.checked??Xe.enabled,Xe.metaPrompt=t?.value??Xe.metaPrompt,Xe.streamingEnabled=n?.checked??Xe.streamingEnabled,r){const e=parseInt(r.value),t=it(e,b.MIN,b.MAX,b.STEP);Xe.streamingPollInterval=t,r.value=t.toString(),t!==e&&toastr.warning(q("toast.valueAdjusted",{original:e,clamped:t,min:b.MIN,max:b.MAX,step:b.STEP}),q("extensionName"))}if(i){const e=parseInt(i.value),t=it(e,E.MIN,E.MAX,E.STEP);Xe.maxConcurrentGenerations=t,i.value=t.toString(),t!==e&&toastr.warning(q("toast.valueAdjustedNoStep",{original:e,clamped:t,min:E.MIN,max:E.MAX}),q("extensionName"))}if(s){const e=parseInt(s.value),t=it(e,w.MIN,w.MAX,w.STEP);Xe.minGenerationInterval=t,s.value=t.toString(),t!==e&&toastr.warning(q("toast.valueAdjusted",{original:e,clamped:t,min:w.MIN,max:w.MAX,step:w.STEP}),q("extensionName"))}Xe.logLevel=o?.value??Xe.logLevel,Xe.promptDetectionPatterns=a?a.value.split("\n").map((e=>e.trim())).filter((e=>e.length>0)):Xe.promptDetectionPatterns,Xe.commonStyleTags=l?.value??Xe.commonStyleTags,Xe.commonStyleTagsPosition=c?.value??Xe.commonStyleTagsPosition,Xe.manualGenerationMode=u?.value??Xe.manualGenerationMode,O(Xe.logLevel),ce(Xe.maxConcurrentGenerations),ue(Xe.minGenerationInterval),De(Xe,Ke),rt(),Ye.info("Settings updated:",Xe)}function ot(){Xe=Me(),De(Xe,Ke),nt(),Ye.info("Settings reset to defaults")}function at(){const e=document.getElementById(T.PROMPT_PATTERNS);e&&(e.value=x.join("\n"),st()),Ye.info("Prompt patterns reset to defaults")}function lt(){Je&&pt();const e=document.getElementById(T.META_PROMPT_PRESET_SELECT);if(!e)return;const t=e.value,n=Ne(t,Xe.customPresets);Xe.currentPresetId=t,Xe.metaPrompt=n.template,De(Xe,Ke),nt(),Ye.info("Preset changed:",{id:t,name:n.name})}function ct(){const e=document.getElementById(T.PRESET_EDITOR),t=document.getElementById(T.PRESET_VIEWER),n=document.getElementById(T.META_PROMPT),r=document.getElementById(T.META_PROMPT_PRESET_SAVE);if(e&&t&&n){if(t.style.display="none",e.style.display="block",n.removeAttribute("readonly"),n.value=Xe.metaPrompt,r){const e=Ce(Xe.currentPresetId);r.disabled=e,r.title=e?"Cannot save changes to predefined presets (use Save As)":"Save changes to this preset"}Je=!0,Ye.info("Entered preset edit mode")}}function ut(){if(Ce(Xe.currentPresetId))return void toastr.error(q("settings.cannotDeletePredefined"),q("extensionName"));const e=document.getElementById(T.META_PROMPT);if(!e)return;const t=e.value,n=Xe.customPresets.findIndex((e=>e.id===Xe.currentPresetId));if(-1===n)return void toastr.error(q("toast.presetNotFound"),q("extensionName"));Xe.customPresets[n].template=t,Xe.metaPrompt=t,De(Xe,Ke);const r=document.getElementById(T.PRESET_EDITOR),i=document.getElementById(T.PRESET_VIEWER);r&&(r.style.display="none"),i&&(i.style.display="block"),Je=!1,nt(),toastr.success(q("toast.presetSaved"),q("extensionName")),Ye.info("Preset saved:",Xe.customPresets[n].name)}function dt(){const e=document.getElementById(T.META_PROMPT);if(!e)return;const t=e.value,n=prompt(q("prompt.enterPresetName"));if(!n||""===n.trim())return;const r=n.trim();if(function(e){const t=e.toLowerCase();return $e.some((e=>e.name.toLowerCase()===t))}(r))return void toastr.error(q("toast.cannotUsePredefinedNames"),q("extensionName"));const i=Xe.customPresets.find((e=>e.name===r));if(i){if(!confirm(q("prompt.overwritePreset",{name:r})))return;i.template=t,Xe.currentPresetId=i.id,Xe.metaPrompt=t}else{const e={id:`custom-${Date.now()}`,name:r,template:t,predefined:!1};Xe.customPresets.push(e),Xe.currentPresetId=e.id,Xe.metaPrompt=t}De(Xe,Ke);const s=document.getElementById(T.PRESET_EDITOR),o=document.getElementById(T.PRESET_VIEWER);s&&(s.style.display="none"),o&&(o.style.display="block"),Je=!1,nt(),toastr.success(q("toast.presetSavedNamed",{name:r}),q("extensionName")),Ye.info("Preset saved as:",r)}function pt(){const e=document.getElementById(T.PRESET_EDITOR),t=document.getElementById(T.PRESET_VIEWER),n=document.getElementById(T.META_PROMPT);e&&t&&n&&(e.style.display="none",t.style.display="block",n.setAttribute("readonly","readonly"),n.value=Xe.metaPrompt,Je=!1,Ye.info("Cancelled preset edit"))}function mt(){if(Ce(Xe.currentPresetId))return void toastr.error(q("toast.cannotDeletePredefined"),q("extensionName"));const e=Xe.customPresets.find((e=>e.id===Xe.currentPresetId));if(!e)return void toastr.error(q("toast.presetNotFound"),q("extensionName"));if(!confirm(q("prompt.overwritePreset",{name:e.name})))return;Xe.customPresets=Xe.customPresets.filter((e=>e.id!==Xe.currentPresetId)),Xe.currentPresetId="default";const t=Ne("default",Xe.customPresets);Xe.metaPrompt=t.template,De(Xe,Ke),nt(),toastr.success(q("toast.presetDeleted",{name:e.name}),q("extensionName")),Ye.info("Preset deleted:",e.name)}function gt(){const e=Ke.chat.length-1;if(!Xe.streamingEnabled)return void Ye.debug("Streaming disabled, skipping");if(!Xe.enabled)return void Ye.debug("Extension disabled, skipping streaming");const t=Ke.chat?.[e];if(!t)return void Ye.error("Message not found:",e);if(t.is_user||t.is_system)return;if(Qe.isActive(e))return void Ye.debug("Already streaming this message, ignoring duplicate token");Ye.info(`First token received for message ${e}, starting streaming`),Ze="streaming";const n=Qe.startSession(e,Ke,Xe);Ye.info(`Streaming monitor and processor started for session ${n.sessionId}`)}function ht(){const e=Qe.getCurrentSession();e?(Ye.info("MESSAGE_RECEIVED fired, signaling barrier"),e.barrier.arrive("messageReceived")):Ye.debug("No active session, ignoring MESSAGE_RECEIVED")}async function ft(){Ze=null;const e=Qe.getCurrentSession();if(!e)return void Ye.debug("No active session, ignoring GENERATION_ENDED");Ye.info("GENERATION_ENDED, finalizing streaming session");const{sessionId:t,messageId:n,barrier:r,monitor:i,processor:s,queue:o}=e;i.finalScan(),i.stop(),await s.processRemaining();const a=s.getDeferredImages();Ye.info(`${a.length} images ready for insertion`),s.stop();const l=o.getStats();Ye.info("Final stats:",l),a.length>0?(async()=>{Ye.info("Waiting for barrier (genDone + messageReceived)...");try{await r.whenReady,Ye.info("Barrier resolved, inserting deferred images");const e=Qe.getCurrentSession();if(Ye.info(`Session check: current=${e?.sessionId}, expected=${t}`),e?.sessionId!==t)return void Ye.warn(`Session changed, skipping insertion (current: ${e?.sessionId}, expected: ${t})`);Ye.info(`Inserting ${a.length} deferred images for message ${n}`),await async function(e,t,n){return 0===e.length?0:se(t,(async()=>{oe.info(`Batch inserting ${e.length} deferred images into message ${t}`);const r=n.chat?.[t];if(!r)return oe.warn("Message not found for batch insertion:",t),0;let i=r.mes||"";const s=i.length,o=[...e].sort(((e,t)=>e.prompt.startIndex-t.prompt.startIndex));let a=0;for(let e=o.length-1;e>=0;e--){const{prompt:r,imageUrl:s}=o[e],l=de(i,r.fullMatch,s,e);if(l.success){i=l.text,a++;const e=S(i).findIndex((e=>e.startIndex===r.startIndex&&e.endIndex===r.endIndex&&e.prompt===r.prompt));if(e>=0){const r=H({messageId:t,promptIndex:e},n);r?(V(s,r,n),oe.debug(`Recorded image-prompt association: ${s} -> ${r}`)):oe.warn(`No promptId found for position ${t}_${e}`)}else oe.warn("Could not find prompt index after insertion")}}r.mes=i,oe.info(`Batch insertion complete: ${a}/${e.length} images inserted (${s} -> ${i.length} chars)`);const l=n.eventTypes.MESSAGE_EDITED;await n.eventSource.emit(l,t),n.updateMessageBlock(t,r);const c=n.eventTypes.MESSAGE_UPDATED;return await n.eventSource.emit(c,t),await n.saveChat(),oe.debug("Chat saved after inserting deferred images"),te(t),a}),"batch deferred image insertion")}(a,n,Ke),Ye.info("Deferred images inserted successfully"),Qe.endSession(),Ye.info("Session ended after successful insertion")}catch(e){Ye.error("Barrier failed or insertion error:",e),toastr.error("Failed to insert generated images",q("extensionName")),Qe.endSession(),Ye.info("Session ended after error")}})():Qe.endSession(),l.FAILED>0&&toastr.warning(q("toast.streamingFailed",{count:l.FAILED}),q("extensionName"))}function _t(){Ye.debug("Adding manual generation buttons to existing messages"),$(".mes").each(((e,t)=>{const n=$(t),r=n.attr("mesid");if(r){const e=parseInt(r,10);isNaN(e)||He(n,e,Ke,Xe)}}))}!function(){Ye.info("Initializing extension...");try{Ke=SillyTavern.getContext(),Ye.info("Got SillyTavern context")}catch(e){return void Ye.error("Failed to get SillyTavern context:",e)}!function(e){G=e.translate}(Ke),Ye.info("Initialized i18n"),Xe=Oe(Ke),Ye.info("Loaded settings:",Xe),O(Xe.logLevel),Qe=new Se,Ye.info("Initialized SessionManager"),le(Xe.maxConcurrentGenerations,Xe.minGenerationInterval),Ye.info(`Initialized concurrency limiter: max=${Xe.maxConcurrentGenerations}, minInterval=${Xe.minGenerationInterval}ms`);const e=function(e,t){return async n=>{if(ge.info("MESSAGE_RECEIVED event, messageId:",n),tt(n))return ge.info("Message being streamed, signaling MESSAGE_RECEIVED"),void ht();ge.info("No streaming active, processing immediately");const r=e.chat?.[n];if(!r)return void ge.info("No message found at index:",n);if(ge.info("Message details:",{is_user:r.is_user,is_system:r.is_system,name:r.name,mes_length:r.mes?.length}),r.is_user)return void ge.info("Skipping user message");if(ge.info("Message text preview:",r.mes.substring(0,200)),!I(r.mes,t.promptDetectionPatterns))return void ge.info("No image prompts found in message");ge.info("Image prompts detected, processing..."),await he(r.mes,n,e,t.promptDetectionPatterns,t.commonStyleTags,t.commonStyleTagsPosition),ge.info("Emitting MESSAGE_EDITED event");const i=e.eventTypes.MESSAGE_EDITED;await e.eventSource.emit(i,n),e.updateMessageBlock(n,r);const s=e.eventTypes.MESSAGE_UPDATED;await e.eventSource.emit(s,n),await e.saveChat(),ge.debug("Chat saved after processing message images")}}(Ke,Xe),t=Ke.eventTypes.MESSAGE_RECEIVED;Ke.eventSource.on(t,e),Ke.eventSource.on(t,(e=>{setTimeout((()=>{const t=$(`.mes[mesid="${e}"]`);t.length>0&&He(t,e,Ke,Xe),We(Ke,Xe)}),100)}));const n=Ke.eventTypes.MESSAGE_UPDATED;Ke.eventSource.on(n,(()=>{setTimeout((()=>{We(Ke,Xe)}),100)}));const r=Ke.eventTypes.GENERATION_STARTED;Ke.eventSource.on(r,((e,t,n)=>{n?Ye.debug("Generation started (dry run), skipping type tracking",{type:e}):(Ze=e,Ye.info("Generation started (actual)",{type:e}))}));const i=Ke.eventTypes.CHAT_COMPLETION_PROMPT_READY;Ke.eventSource.on(i,(e=>{if(e?.dryRun)return void Ye.info("Skipping prompt ready processing for dry run");if(!e?.chat)return;!function(e,t=x){fe.info("Pruning generated images from chat history");for(const n of e){if("user"===n.role||"system"===n.role)continue;const e=S(n.content,t);let r=n.content;for(let t=e.length-1;t>=0;t--){const n=e[t],i=r.substring(n.endIndex),s=/^\s*<img\s+[^>]*>/g;let o,a=0;for(;null!==(o=s.exec(i))&&o.index===a;)a+=o[0].length,s.lastIndex=a;a>0&&(r=r.substring(0,n.endIndex)+r.substring(n.endIndex+a))}n.content!==r&&(n.content=r,fe.info("Pruned generated images from assistant message"))}}(e.chat);const t=Ze||"normal";Xe.enabled&&Xe.metaPrompt&&!["quiet","impersonate"].includes(t)?(Ye.info("Injecting meta-prompt as last system message",{currentGenerationType:Ze,effectiveType:t,metaPromptLength:Xe.metaPrompt.length}),e.chat.push({role:"system",content:Xe.metaPrompt})):Ye.info("Skipping meta-prompt injection",{enabled:Xe.enabled,hasMetaPrompt:!!Xe.metaPrompt,currentGenerationType:Ze,effectiveType:t,reason:Xe.enabled?Xe.metaPrompt?`generation type is ${t}`:"no meta-prompt":"extension disabled"})}));const s=Ke.eventTypes.STREAM_TOKEN_RECEIVED,o=Ke.eventTypes.GENERATION_ENDED;Ke.eventSource.on(s,gt),Ke.eventSource.on(o,ft),Ye.info("Event handlers registered:",{MESSAGE_RECEIVED:t,MESSAGE_UPDATED:n,GENERATION_STARTED:r,CHAT_COMPLETION_PROMPT_READY:i,STREAM_TOKEN_RECEIVED:s,GENERATION_ENDED:o});const a=document.getElementById("extensions_settings2");if(a){const e=`\n    <div class="auto-illustrator-settings">\n      <div class="inline-drawer">\n        <div class="inline-drawer-toggle inline-drawer-header">\n          <b>${q("extensionName")}</b>\n          <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>\n        </div>\n        <div class="inline-drawer-content">\n          <div style="display: flex; align-items: center; justify-content: space-between;">\n            <label class="checkbox_label" for="${T.ENABLED}">\n              <input id="${T.ENABLED}" type="checkbox" />\n              <span>${q("settings.enable")}</span>\n            </label>\n            <div id="${T.RESET_BUTTON}" class="menu_button menu_button_icon">\n              <i class="fa-solid fa-undo"></i>\n              <span>${q("settings.resetDefaults")}</span>\n            </div>\n          </div>\n\n          <div class="preset-management">\n            <label>${q("settings.metaPromptPreset")}</label>\n            <div class="preset-toolbar">\n              <select id="${T.META_PROMPT_PRESET_SELECT}" class="text_pole flex_fill">\n                <optgroup label="${q("settings.predefinedPresets")}">\n                  <option value="default">Default</option>\n                  <option value="nai-4.5-full">NAI 4.5 Full</option>\n                </optgroup>\n                <optgroup label="${q("settings.customPresets")}" id="custom_presets_group">\n                  \x3c!-- populated by JavaScript --\x3e\n                </optgroup>\n              </select>\n              <button id="${T.META_PROMPT_PRESET_EDIT}" class="menu_button menu_button_icon" title="${q("settings.editPreset")}">\n                <i class="fa-solid fa-edit"></i>\n              </button>\n              <button id="${T.META_PROMPT_PRESET_DELETE}" class="menu_button menu_button_icon" title="${q("settings.deletePreset")}">\n                <i class="fa-solid fa-trash"></i>\n              </button>\n            </div>\n\n            <div id="${T.PRESET_EDITOR}" style="display:none">\n              <label for="${T.META_PROMPT}">\n                <span>${q("settings.metaPromptTemplate")}</span>\n                <small>${q("settings.editingPresetHint")}</small>\n                <textarea id="${T.META_PROMPT}" class="text_pole textarea_compact" rows="10" readonly></textarea>\n              </label>\n              <div class="preset-edit-actions">\n                <button id="${T.META_PROMPT_PRESET_SAVE}" class="menu_button">\n                  <i class="fa-solid fa-save"></i> ${q("settings.save")}\n                </button>\n                <button id="${T.META_PROMPT_PRESET_SAVE_AS}" class="menu_button">\n                  <i class="fa-solid fa-copy"></i> ${q("settings.saveAs")}\n                </button>\n                <button id="${T.META_PROMPT_PRESET_CANCEL}" class="menu_button">\n                  <i class="fa-solid fa-times"></i> ${q("settings.cancel")}\n                </button>\n              </div>\n            </div>\n\n            <div id="${T.PRESET_VIEWER}" class="preset-content-preview">\n              <label>${q("settings.presetContentPreview")}</label>\n              <pre id="${T.PRESET_PREVIEW}" class="preset-preview-text"></pre>\n            </div>\n\n            <div id="${T.PATTERN_VALIDATION_STATUS}" class="pattern-validation-status">\n              \x3c!-- Validation status will be populated by JavaScript --\x3e\n            </div>\n          </div>\n\n          <hr>\n\n          <label class="checkbox_label" for="${T.STREAMING_ENABLED}">\n            <input id="${T.STREAMING_ENABLED}" type="checkbox" />\n            <span>${q("settings.streamingEnabled")}</span>\n            <small>${q("settings.streamingEnabledDesc")}</small>\n          </label>\n\n          <label for="${T.STREAMING_POLL_INTERVAL}">\n            <span>${q("settings.streamingPollInterval")}</span>\n            <small>${q("settings.streamingPollIntervalDesc")}</small>\n            <input id="${T.STREAMING_POLL_INTERVAL}" class="text_pole" type="number" min="${b.MIN}" max="${b.MAX}" step="${b.STEP}" />\n          </label>\n\n          <label for="${T.MAX_CONCURRENT}">\n            <span>${q("settings.maxConcurrent")}</span>\n            <small>${q("settings.maxConcurrentDesc")}</small>\n            <input id="${T.MAX_CONCURRENT}" class="text_pole" type="number" min="${E.MIN}" max="${E.MAX}" step="${E.STEP}" />\n          </label>\n\n          <label for="${T.MIN_GENERATION_INTERVAL}">\n            <span>${q("settings.minGenerationInterval")}</span>\n            <small>${q("settings.minGenerationIntervalDesc")}</small>\n            <input id="${T.MIN_GENERATION_INTERVAL}" class="text_pole" type="number" min="${w.MIN}" max="${w.MAX}" step="${w.STEP}" />\n          </label>\n\n          <label for="${T.PROMPT_PATTERNS}">\n            <span>${q("settings.promptPatterns")}</span>\n            <small>${q("settings.promptPatternsDesc")}</small>\n            <div style="display: flex; gap: 0.5rem; align-items: flex-start;">\n              <textarea id="${T.PROMPT_PATTERNS}" class="text_pole textarea_compact" rows="5" style="flex: 1;"></textarea>\n              <button id="${T.PROMPT_PATTERNS_RESET}" class="menu_button menu_button_icon" title="${q("settings.promptPatternsReset")}">\n                <i class="fa-solid fa-undo"></i>\n              </button>\n            </div>\n          </label>\n\n          <label for="${T.COMMON_STYLE_TAGS}">\n            <span>${q("settings.commonStyleTags")}</span>\n            <small>${q("settings.commonStyleTagsDesc")}</small>\n            <textarea id="${T.COMMON_STYLE_TAGS}" class="text_pole textarea_compact" rows="3" placeholder="${q("settings.commonStyleTagsPlaceholder")}"></textarea>\n          </label>\n\n          <label for="${T.COMMON_STYLE_TAGS_POSITION}">\n            <span>${q("settings.commonStyleTagsPosition")}</span>\n            <select id="${T.COMMON_STYLE_TAGS_POSITION}" class="text_pole">\n              <option value="prefix">${q("settings.commonStyleTagsPrefix")}</option>\n              <option value="suffix">${q("settings.commonStyleTagsSuffix")}</option>\n            </select>\n          </label>\n\n          <label for="${T.MANUAL_GEN_MODE}">\n            <span>${q("settings.manualGenerationMode")}</span>\n            <small>${q("settings.manualGenerationModeDesc")}</small>\n            <select id="${T.MANUAL_GEN_MODE}" class="text_pole">\n              <option value="append">${q("settings.manualGenerationModeAppend")}</option>\n              <option value="replace">${q("settings.manualGenerationModeReplace")}</option>\n            </select>\n          </label>\n\n          <label for="${T.LOG_LEVEL}">\n            <span>${q("settings.logLevel")}</span>\n            <small>${q("settings.logLevelDesc")}</small>\n            <select id="${T.LOG_LEVEL}" class="text_pole">\n              <option value="trace">${q("settings.logLevel.trace")}</option>\n              <option value="debug">${q("settings.logLevel.debug")}</option>\n              <option value="info">${q("settings.logLevel.info")}</option>\n              <option value="warn">${q("settings.logLevel.warn")}</option>\n              <option value="error">${q("settings.logLevel.error")}</option>\n              <option value="silent">${q("settings.logLevel.silent")}</option>\n            </select>\n          </label>\n        </div>\n      </div>\n    </div>\n  `.trim();a.insertAdjacentHTML("beforeend",e);const t=document.getElementById(T.ENABLED),n=document.getElementById(T.META_PROMPT_PRESET_SELECT),r=document.getElementById(T.META_PROMPT_PRESET_EDIT),i=document.getElementById(T.META_PROMPT_PRESET_SAVE),s=document.getElementById(T.META_PROMPT_PRESET_SAVE_AS),o=document.getElementById(T.META_PROMPT_PRESET_DELETE),l=document.getElementById(T.META_PROMPT_PRESET_CANCEL),c=document.getElementById(T.STREAMING_ENABLED),u=document.getElementById(T.STREAMING_POLL_INTERVAL),d=document.getElementById(T.MAX_CONCURRENT),p=document.getElementById(T.MIN_GENERATION_INTERVAL),m=document.getElementById(T.LOG_LEVEL),g=document.getElementById(T.PROMPT_PATTERNS),h=document.getElementById(T.PROMPT_PATTERNS_RESET),f=document.getElementById(T.COMMON_STYLE_TAGS),_=document.getElementById(T.COMMON_STYLE_TAGS_POSITION),v=document.getElementById(T.MANUAL_GEN_MODE),y=document.getElementById(T.RESET_BUTTON);t?.addEventListener("change",st),n?.addEventListener("change",lt),r?.addEventListener("click",ct),i?.addEventListener("click",ut),s?.addEventListener("click",dt),o?.addEventListener("click",mt),l?.addEventListener("click",pt),c?.addEventListener("change",st),u?.addEventListener("change",st),d?.addEventListener("change",st),p?.addEventListener("change",st),m?.addEventListener("change",st),g?.addEventListener("change",st),h?.addEventListener("click",at),f?.addEventListener("change",st),_?.addEventListener("change",st),v?.addEventListener("change",st),y?.addEventListener("click",ot),nt()}Ye.info("Extension initialized successfully");const l=Ke.eventTypes.CHAT_CHANGED;Ke.eventSource.on(l,(()=>{Ye.info("CHAT_CHANGED - reloading settings"),Xe=Oe(Ke),O(Xe.logLevel),ce(Xe.maxConcurrentGenerations),ue(Xe.minGenerationInterval),nt(),setTimeout((()=>{_t(),We(Ke,Xe)}),100)})),_t(),We(Ke,Xe)}()})()})();
\ No newline at end of file
diff --git a/src/concurrency_limiter.test.ts b/src/concurrency_limiter.test.ts
deleted file mode 100644
index 8ee1f42..0000000
--- a/src/concurrency_limiter.test.ts
+++ /dev/null
@@ -1,353 +0,0 @@
-/**
- * Concurrency Limiter Tests
- * Tests for concurrency limiting and time-based throttling
- */
-
-import {describe, it, expect, beforeEach, vi} from 'vitest';
-import {ConcurrencyLimiter} from './concurrency_limiter';
-
-describe('ConcurrencyLimiter', () => {
-  let limiter: ConcurrencyLimiter;
-
-  beforeEach(() => {
-    vi.clearAllTimers();
-    vi.useFakeTimers();
-  });
-
-  describe('Concurrency limiting', () => {
-    it('should limit concurrent executions', async () => {
-      limiter = new ConcurrencyLimiter(2);
-      let running = 0;
-      let maxRunning = 0;
-
-      const task = async () => {
-        running++;
-        maxRunning = Math.max(maxRunning, running);
-        await new Promise(resolve => setTimeout(resolve, 100));
-        running--;
-      };
-
-      // Start 5 tasks
-      const promises = Array.from({length: 5}, () => limiter.run(task));
-
-      // Advance timers to complete all tasks
-      await vi.advanceTimersByTimeAsync(500);
-      await Promise.all(promises);
-
-      // Should never have more than 2 running at once
-      expect(maxRunning).toBe(2);
-    });
-
-    it('should execute tasks sequentially when maxConcurrent is 1', async () => {
-      limiter = new ConcurrencyLimiter(1);
-      const executionOrder: number[] = [];
-
-      const createTask = (id: number) => async () => {
-        executionOrder.push(id);
-        await new Promise(resolve => setTimeout(resolve, 50));
-      };
-
-      const promises = [
-        limiter.run(createTask(1)),
-        limiter.run(createTask(2)),
-        limiter.run(createTask(3)),
-      ];
-
-      await vi.advanceTimersByTimeAsync(200);
-      await Promise.all(promises);
-
-      expect(executionOrder).toEqual([1, 2, 3]);
-    });
-
-    it('should update max concurrent limit', async () => {
-      limiter = new ConcurrencyLimiter(1);
-      let running = 0;
-      let maxRunning = 0;
-
-      const task = async () => {
-        running++;
-        maxRunning = Math.max(maxRunning, running);
-        await new Promise(resolve => setTimeout(resolve, 100));
-        running--;
-      };
-
-      // Start 3 tasks with limit of 1
-      const promise1 = limiter.run(task);
-      const promise2 = limiter.run(task);
-      const promise3 = limiter.run(task);
-
-      // Update to allow 2 concurrent
-      limiter.setMaxConcurrent(2);
-
-      await vi.advanceTimersByTimeAsync(300);
-      await Promise.all([promise1, promise2, promise3]);
-
-      // Should allow up to 2 concurrent after update
-      expect(maxRunning).toBeLessThanOrEqual(2);
-    });
-  });
-
-  describe('Time-based throttling', () => {
-    it('should enforce minimum interval between task completions', async () => {
-      limiter = new ConcurrencyLimiter(5, 1000); // 1 second interval
-      const completionTimes: number[] = [];
-
-      const task = async () => {
-        await new Promise(resolve => setTimeout(resolve, 10));
-        completionTimes.push(Date.now());
-      };
-
-      // Start 3 tasks
-      const promise1 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(20);
-      await promise1;
-
-      const promise2 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(1020);
-      await promise2;
-
-      const promise3 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(1020);
-      await promise3;
-
-      // Verify each task waited at least 1000ms after the previous completion
-      expect(completionTimes[1] - completionTimes[0]).toBeGreaterThanOrEqual(
-        1000
-      );
-      expect(completionTimes[2] - completionTimes[1]).toBeGreaterThanOrEqual(
-        1000
-      );
-    });
-
-    it('should not delay when minInterval is 0', async () => {
-      limiter = new ConcurrencyLimiter(5, 0);
-      const startTime = Date.now();
-      const completionTimes: number[] = [];
-
-      const task = async () => {
-        await new Promise(resolve => setTimeout(resolve, 10));
-        completionTimes.push(Date.now());
-      };
-
-      // Run 3 tasks quickly
-      const promise1 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(15);
-      await promise1;
-
-      const promise2 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(15);
-      await promise2;
-
-      const promise3 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(15);
-      await promise3;
-
-      const totalTime = Date.now() - startTime;
-
-      // Should complete quickly without interval delays
-      expect(totalTime).toBeLessThan(100);
-    });
-
-    it('should wait remaining time if interval not elapsed', async () => {
-      limiter = new ConcurrencyLimiter(5, 1000);
-
-      const task = async () => {
-        await new Promise(resolve => setTimeout(resolve, 10));
-      };
-
-      // First task
-      const promise1 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(20);
-      await promise1;
-
-      const firstCompletionTime = Date.now();
-
-      // Advance only 300ms
-      await vi.advanceTimersByTimeAsync(300);
-
-      // Second task should wait remaining 700ms
-      const promise2Start = limiter.run(task);
-
-      // Should not start immediately
-      await vi.advanceTimersByTimeAsync(100);
-
-      // After 700ms total wait, task should execute
-      await vi.advanceTimersByTimeAsync(600);
-      await vi.advanceTimersByTimeAsync(20);
-      await promise2Start;
-
-      const secondCompletionTime = Date.now();
-
-      // Total time from first completion should be ~1000ms
-      expect(secondCompletionTime - firstCompletionTime).toBeGreaterThanOrEqual(
-        1000
-      );
-    });
-
-    it('should update minimum interval dynamically', async () => {
-      limiter = new ConcurrencyLimiter(5, 500);
-
-      const task = async () => {
-        await new Promise(resolve => setTimeout(resolve, 10));
-      };
-
-      // First task
-      const promise1 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(20);
-      await promise1;
-
-      // Update interval to 1000ms
-      limiter.setMinInterval(1000);
-
-      const firstCompletionTime = Date.now();
-
-      // Second task should wait 1000ms (new interval)
-      const promise2 = limiter.run(task);
-      await vi.advanceTimersByTimeAsync(1020);
-      await promise2;
-
-      const secondCompletionTime = Date.now();
-
-      expect(secondCompletionTime - firstCompletionTime).toBeGreaterThanOrEqual(
-        1000
-      );
-    });
-
-    it('should work with both concurrency and time limiting enabled', async () => {
-      // Just verify that both settings are stored and retrievable
-      limiter = new ConcurrencyLimiter(2, 500);
-      const status = limiter.getStatus();
-
-      expect(status.maxConcurrent).toBe(2);
-
-      // Verify setters work
-      limiter.setMaxConcurrent(3);
-      limiter.setMinInterval(1000);
-
-      expect(limiter.getStatus().maxConcurrent).toBe(3);
-    });
-  });
-
-  describe('Status tracking', () => {
-    it('should return correct status', () => {
-      limiter = new ConcurrencyLimiter(3, 500);
-      const status = limiter.getStatus();
-
-      expect(status.maxConcurrent).toBe(3);
-      expect(status.currentCount).toBe(0);
-      expect(status.queueLength).toBe(0);
-    });
-
-    it('should update status as tasks run', async () => {
-      limiter = new ConcurrencyLimiter(1);
-
-      const slowTask = async () => {
-        await new Promise(resolve => setTimeout(resolve, 100));
-      };
-
-      const promise1 = limiter.run(slowTask);
-      const promise2 = limiter.run(slowTask);
-
-      // After starting, should show 1 running and 1 queued
-      await vi.advanceTimersByTimeAsync(10);
-      const statusDuring = limiter.getStatus();
-      expect(statusDuring.currentCount).toBe(1);
-      expect(statusDuring.queueLength).toBe(1);
-
-      await vi.advanceTimersByTimeAsync(200);
-      await Promise.all([promise1, promise2]);
-
-      // After completion, should be empty
-      const statusAfter = limiter.getStatus();
-      expect(statusAfter.currentCount).toBe(0);
-      expect(statusAfter.queueLength).toBe(0);
-    });
-  });
-
-  describe('Combined concurrency and time limiting', () => {
-    it('should work with both concurrency and time limiting enabled', async () => {
-      limiter = new ConcurrencyLimiter(2, 500);
-      const status = limiter.getStatus();
-      expect(status.maxConcurrent).toBe(2);
-
-      limiter.setMaxConcurrent(3);
-      limiter.setMinInterval(1000);
-
-      expect(limiter.getStatus().maxConcurrent).toBe(3);
-    });
-  });
-});
-
-describe('Settings validation', () => {
-  let limiter: ConcurrencyLimiter;
-
-  afterEach(() => {
-    vi.clearAllTimers();
-  });
-
-  describe('setMaxConcurrent validation', () => {
-    it('should clamp values below minimum (1) to 1', () => {
-      limiter = new ConcurrencyLimiter(3);
-      limiter.setMaxConcurrent(0);
-      expect(limiter.getStatus().maxConcurrent).toBe(1);
-
-      limiter.setMaxConcurrent(-5);
-      expect(limiter.getStatus().maxConcurrent).toBe(1);
-    });
-
-    it('should clamp values above maximum (5) to 5', () => {
-      limiter = new ConcurrencyLimiter(3);
-      limiter.setMaxConcurrent(10);
-      expect(limiter.getStatus().maxConcurrent).toBe(5);
-
-      limiter.setMaxConcurrent(100);
-      expect(limiter.getStatus().maxConcurrent).toBe(5);
-    });
-
-    it('should accept valid values within range', () => {
-      limiter = new ConcurrencyLimiter(3);
-      for (let i = 1; i <= 5; i++) {
-        limiter.setMaxConcurrent(i);
-        expect(limiter.getStatus().maxConcurrent).toBe(i);
-      }
-    });
-  });
-
-  describe('setMinInterval validation', () => {
-    it('should clamp negative values to 0', () => {
-      limiter = new ConcurrencyLimiter(1, 500);
-      limiter.setMinInterval(-100);
-      // We test through behavior - negative interval should not cause issues
-      expect(() => limiter.setMinInterval(-100)).not.toThrow();
-    });
-
-    it('should clamp values above maximum (10000) to 10000', () => {
-      limiter = new ConcurrencyLimiter(1, 500);
-      limiter.setMinInterval(15000);
-      expect(() => limiter.setMinInterval(15000)).not.toThrow();
-    });
-
-    it('should accept valid values within range', () => {
-      limiter = new ConcurrencyLimiter(1);
-      expect(() => limiter.setMinInterval(0)).not.toThrow();
-      expect(() => limiter.setMinInterval(5000)).not.toThrow();
-      expect(() => limiter.setMinInterval(10000)).not.toThrow();
-    });
-  });
-
-  describe('Constructor validation', () => {
-    it('should clamp maxConcurrent on construction', () => {
-      limiter = new ConcurrencyLimiter(0, 0);
-      expect(limiter.getStatus().maxConcurrent).toBe(1);
-
-      limiter = new ConcurrencyLimiter(10, 0);
-      expect(limiter.getStatus().maxConcurrent).toBe(5);
-    });
-
-    it('should clamp minInterval on construction', () => {
-      // Test through behavior - out-of-range intervals should not cause issues
-      expect(() => new ConcurrencyLimiter(1, -500)).not.toThrow();
-      expect(() => new ConcurrencyLimiter(1, 15000)).not.toThrow();
-    });
-  });
-});
diff --git a/src/concurrency_limiter.ts b/src/concurrency_limiter.ts
deleted file mode 100644
index aac7508..0000000
--- a/src/concurrency_limiter.ts
+++ /dev/null
@@ -1,193 +0,0 @@
-/**
- * Concurrency Limiter Module
- * Limits the number of concurrent image generation requests
- */
-
-import {createLogger} from './logger';
-import {MAX_CONCURRENT_GENERATIONS, MIN_GENERATION_INTERVAL} from './constants';
-
-const logger = createLogger('Limiter');
-
-/**
- * A simple semaphore to limit concurrent operations and enforce minimum time intervals
- */
-export class ConcurrencyLimiter {
-  private maxConcurrent: number;
-  private minInterval: number;
-  private currentCount = 0;
-  private queue: Array<() => void> = [];
-  private lastCompletionTime: number | null = null;
-
-  constructor(maxConcurrent: number, minInterval = 0) {
-    // Validate and clamp maxConcurrent
-    this.maxConcurrent = Math.max(
-      MAX_CONCURRENT_GENERATIONS.MIN,
-      Math.min(MAX_CONCURRENT_GENERATIONS.MAX, maxConcurrent)
-    );
-
-    // Validate and clamp minInterval
-    this.minInterval = Math.max(
-      MIN_GENERATION_INTERVAL.MIN,
-      Math.min(MIN_GENERATION_INTERVAL.MAX, minInterval)
-    );
-
-    if (this.maxConcurrent !== maxConcurrent) {
-      logger.warn(
-        `maxConcurrent clamped from ${maxConcurrent} to ${this.maxConcurrent} (valid range: ${MAX_CONCURRENT_GENERATIONS.MIN}-${MAX_CONCURRENT_GENERATIONS.MAX})`
-      );
-    }
-
-    if (this.minInterval !== minInterval) {
-      logger.warn(
-        `minInterval clamped from ${minInterval}ms to ${this.minInterval}ms (valid range: ${MIN_GENERATION_INTERVAL.MIN}-${MIN_GENERATION_INTERVAL.MAX}ms)`
-      );
-    }
-
-    logger.info(
-      `ConcurrencyLimiter created: maxConcurrent=${this.maxConcurrent}, minInterval=${this.minInterval}ms`
-    );
-  }
-
-  /**
-   * Acquires a slot, waiting if necessary
-   */
-  private async acquire(): Promise<void> {
-    if (this.currentCount < this.maxConcurrent) {
-      this.currentCount++;
-      logger.debug(
-        `Acquired slot (${this.currentCount}/${this.maxConcurrent})`
-      );
-      return Promise.resolve();
-    }
-
-    // Wait in queue
-    logger.debug(
-      `Waiting for slot (${this.currentCount}/${this.maxConcurrent}, ${this.queue.length} queued)`
-    );
-    return new Promise(resolve => {
-      this.queue.push(resolve);
-    });
-  }
-
-  /**
-   * Releases a slot and processes next queued item
-   */
-  private release(): void {
-    this.currentCount--;
-    logger.debug(
-      `Released slot (${this.currentCount}/${this.maxConcurrent}, ${this.queue.length} queued)`
-    );
-
-    if (this.queue.length > 0) {
-      const next = this.queue.shift();
-      this.currentCount++;
-      if (next) {
-        logger.debug(
-          `Processing queued request (${this.currentCount}/${this.maxConcurrent})`
-        );
-        next();
-      }
-    }
-  }
-
-  /**
-   * Waits for minimum interval since last completion
-   */
-  private async waitForMinInterval(): Promise<void> {
-    if (this.minInterval === 0 || this.lastCompletionTime === null) {
-      logger.debug(
-        `No interval wait needed (minInterval: ${this.minInterval}ms, lastCompletion: ${this.lastCompletionTime})`
-      );
-      return;
-    }
-
-    const elapsed = Date.now() - this.lastCompletionTime;
-    const remaining = this.minInterval - elapsed;
-
-    if (remaining > 0) {
-      logger.info(
-        `Waiting ${remaining}ms before next generation (minInterval: ${this.minInterval}ms, elapsed: ${elapsed}ms)`
-      );
-      await new Promise(resolve => setTimeout(resolve, remaining));
-      logger.info('Wait completed, proceeding with generation');
-    } else {
-      logger.debug(
-        `No wait needed, sufficient time elapsed (${elapsed}ms >= ${this.minInterval}ms)`
-      );
-    }
-  }
-
-  /**
-   * Executes an async function with concurrency limiting and time interval enforcement
-   * @param fn - Async function to execute
-   * @returns Promise resolving to function result
-   */
-  async run<T>(fn: () => Promise<T>): Promise<T> {
-    await this.waitForMinInterval();
-    await this.acquire();
-    try {
-      const result = await fn();
-      this.lastCompletionTime = Date.now();
-      return result;
-    } finally {
-      this.release();
-    }
-  }
-
-  /**
-   * Updates the maximum concurrent limit
-   * @param maxConcurrent - New max concurrent limit
-   */
-  setMaxConcurrent(maxConcurrent: number): void {
-    const oldValue = this.maxConcurrent;
-    const clampedValue = Math.max(
-      MAX_CONCURRENT_GENERATIONS.MIN,
-      Math.min(MAX_CONCURRENT_GENERATIONS.MAX, maxConcurrent)
-    );
-
-    if (clampedValue !== maxConcurrent) {
-      logger.warn(
-        `maxConcurrent clamped from ${maxConcurrent} to ${clampedValue} (valid range: ${MAX_CONCURRENT_GENERATIONS.MIN}-${MAX_CONCURRENT_GENERATIONS.MAX})`
-      );
-    }
-
-    logger.info(`Updating max concurrent: ${oldValue}  ${clampedValue}`);
-    this.maxConcurrent = clampedValue;
-  }
-
-  /**
-   * Updates the minimum generation interval
-   * @param minInterval - New minimum interval (milliseconds)
-   */
-  setMinInterval(minInterval: number): void {
-    const oldValue = this.minInterval;
-    const clampedValue = Math.max(
-      MIN_GENERATION_INTERVAL.MIN,
-      Math.min(MIN_GENERATION_INTERVAL.MAX, minInterval)
-    );
-
-    if (clampedValue !== minInterval) {
-      logger.warn(
-        `minInterval clamped from ${minInterval}ms to ${clampedValue}ms (valid range: ${MIN_GENERATION_INTERVAL.MIN}-${MIN_GENERATION_INTERVAL.MAX}ms)`
-      );
-    }
-
-    logger.info(`Updating min interval: ${oldValue}ms  ${clampedValue}ms`);
-    this.minInterval = clampedValue;
-  }
-
-  /**
-   * Gets current status
-   */
-  getStatus(): {
-    maxConcurrent: number;
-    currentCount: number;
-    queueLength: number;
-  } {
-    return {
-      maxConcurrent: this.maxConcurrent,
-      currentCount: this.currentCount,
-      queueLength: this.queue.length,
-    };
-  }
-}
diff --git a/src/index.ts b/src/index.ts
index adcd133..f02ee75 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -6,10 +6,9 @@
 import './style.css';
 import {createMessageHandler} from './message_handler';
 import {pruneGeneratedImages} from './chat_history_pruner';
-import {ImageGenerationQueue} from './streaming_image_queue';
-import {StreamingMonitor} from './streaming_monitor';
-import {QueueProcessor} from './queue_processor';
-import type {DeferredImage} from './types';
+import {SessionManager} from './session_manager';
+import {insertDeferredImages} from './image_generator';
+import {scheduleDomOperation} from './dom_queue';
 import {
   loadSettings,
   saveSettings,
@@ -51,13 +50,8 @@ let isEditingPreset = false; // Track if user is currently editing a preset
 // Generation state
 let currentGenerationType: string | null = null; // Track generation type for filtering
 
-// Streaming state
-let pendingDeferredImages: {images: DeferredImage[]; messageId: number} | null =
-  null;
-let messageReceivedFired = false; // Track if MESSAGE_RECEIVED has fired
-let streamingQueue: ImageGenerationQueue | null = null;
-let streamingMonitor: StreamingMonitor | null = null;
-let queueProcessor: QueueProcessor | null = null;
+// Streaming state - managed by SessionManager
+let sessionManager: SessionManager;
 
 /**
  * Checks if streaming generation is currently active
@@ -66,26 +60,16 @@ let queueProcessor: QueueProcessor | null = null;
  * @returns True if streaming is in progress
  */
 export function isStreamingActive(messageId?: number): boolean {
-  const monitorActive = streamingMonitor?.isActive() ?? false;
-
-  if (messageId === undefined) {
-    // Check if any streaming is active
-    return monitorActive;
-  }
-
-  // Check if THIS specific message is being streamed
-  return monitorActive && currentStreamingMessageId === messageId;
+  return sessionManager?.isActive(messageId) ?? false;
 }
 
-let currentStreamingMessageId: number | null = null; // Track which message is being streamed
-
 /**
  * Checks if a specific message is currently being streamed
  * @param messageId - Message ID to check
  * @returns True if this message is being streamed
  */
 export function isMessageBeingStreamed(messageId: number): boolean {
-  return currentStreamingMessageId === messageId;
+  return sessionManager?.isActive(messageId) ?? false;
 }
 
 /**
@@ -723,173 +707,157 @@ function handlePresetDelete(): void {
  * This is more reliable than GENERATION_STARTED which fires before message creation
  */
 function handleFirstStreamToken(): void {
-  // Only initialize once per stream
-  if (streamingMonitor?.isActive()) {
+  const messageId = context.chat.length - 1;
+
+  if (!settings.streamingEnabled) {
+    logger.debug('Streaming disabled, skipping');
     return;
   }
 
-  if (!settings.streamingEnabled || !settings.enabled) {
+  if (!settings.enabled) {
+    logger.debug('Extension disabled, skipping streaming');
     return;
   }
 
-  // Find the last assistant message - this is the one being streamed
-  if (!context.chat || context.chat.length === 0) {
+  const message = context.chat?.[messageId];
+  if (!message) {
+    logger.error('Message not found:', messageId);
     return;
   }
 
-  const messageId = context.chat.length - 1;
-  const message = context.chat[messageId];
-
-  // Verify it's an assistant message
   if (message.is_user || message.is_system) {
     return;
   }
 
   // Note: DOM queue will automatically serialize with any manual generation operations
 
-  // Don't restart if already monitoring this message
-  // This prevents recreating the processor and losing deferred images
-  if (streamingMonitor && currentStreamingMessageId === messageId) {
-    logger.debug(
-      `Already monitoring message ${messageId}, skipping reinitialization`
-    );
+  // Check if already streaming this message
+  if (sessionManager.isActive(messageId)) {
+    logger.debug('Already streaming this message, ignoring duplicate token');
     return;
   }
 
   logger.info(
-    `First stream token received, starting streaming for message ${messageId}`
+    `First token received for message ${messageId}, starting streaming`
   );
+  currentGenerationType = 'streaming';
 
-  // Clean up any previous streaming state (different message)
-  if (streamingMonitor) {
-    streamingMonitor.stop();
-  }
-  if (queueProcessor) {
-    queueProcessor.stop();
-  }
-
-  // Initialize streaming
-  streamingQueue = new ImageGenerationQueue();
-  queueProcessor = new QueueProcessor(
-    streamingQueue,
-    context,
-    settings,
-    settings.maxConcurrentGenerations
-  );
+  // Start new session (cancels existing if any)
+  const session = sessionManager.startSession(messageId, context, settings);
 
-  streamingMonitor = new StreamingMonitor(
-    streamingQueue,
-    context,
-    settings,
-    settings.streamingPollInterval,
-    () => queueProcessor?.trigger()
+  logger.info(
+    `Streaming monitor and processor started for session ${session.sessionId}`
   );
-
-  currentStreamingMessageId = messageId;
-  messageReceivedFired = false; // Reset flag for new streaming session
-  pendingDeferredImages = null;
-
-  streamingMonitor.start(messageId);
-  // Start processor (images generated during streaming, inserted in batch after completion)
-  queueProcessor.start(messageId);
-
-  logger.info('Streaming monitor and processor started');
 }
 
 /**
  * Handles MESSAGE_RECEIVED event when in streaming mode
- * Signals that the message has been finalized and attempts to insert deferred images
+ * Signals that the message has been finalized and deferred images can be inserted
  */
 export function handleMessageReceivedForStreaming(): void {
-  logger.info('MESSAGE_RECEIVED fired for streaming, setting flag');
-  messageReceivedFired = true;
-  tryInsertDeferredImages();
-}
-
-/**
- * Attempts to insert deferred images if both conditions are met:
- * 1. All images have been generated (pendingDeferredImages exists)
- * 2. MESSAGE_RECEIVED has fired (messageReceivedFired is true)
- */
-async function tryInsertDeferredImages(): Promise<void> {
-  if (pendingDeferredImages && messageReceivedFired) {
-    const {images, messageId} = pendingDeferredImages;
-    logger.info(
-      `Both conditions met, inserting ${images.length} deferred images`
-    );
-
-    // Clear flags before insertion
-    pendingDeferredImages = null;
-    messageReceivedFired = false;
-
-    // Import and call insertDeferredImages
-    const {insertDeferredImages} = await import('./image_generator');
-    await insertDeferredImages(images, messageId, context);
+  const session = sessionManager.getCurrentSession();
+  if (!session) {
+    logger.debug('No active session, ignoring MESSAGE_RECEIVED');
+    return;
   }
+
+  logger.info('MESSAGE_RECEIVED fired, signaling barrier');
+  session.barrier.arrive('messageReceived');
 }
 
 /**
  * Handles GENERATION_ENDED event
  */
 async function handleGenerationEnded(): Promise<void> {
-  // Clear generation type to prevent stale state
   currentGenerationType = null;
-  logger.debug('Generation ended, cleared generation type');
 
-  if (!streamingMonitor || !queueProcessor || !streamingQueue) {
+  const session = sessionManager.getCurrentSession();
+  if (!session) {
+    logger.debug('No active session, ignoring GENERATION_ENDED');
     return;
   }
 
-  logger.info('GENERATION_ENDED, cleaning up streaming');
+  logger.info('GENERATION_ENDED, finalizing streaming session');
 
-  // Do one final scan to catch any prompts added at the very end
-  streamingMonitor.finalScan();
+  const {sessionId, messageId, barrier, monitor, processor, queue} = session;
 
-  // Stop monitoring (no more new prompts)
-  streamingMonitor.stop();
+  // Final scan for any remaining prompts
+  monitor.finalScan();
 
-  // Process any remaining queued prompts
-  await queueProcessor.processRemaining();
+  // Stop monitoring (no more new prompts)
+  monitor.stop();
 
-  // Get deferred images and message ID before clearing state
-  const deferredImages = queueProcessor.getDeferredImages();
-  const messageId = currentStreamingMessageId;
+  // Process remaining prompts and signal barrier
+  await processor.processRemaining();
+  // Note: processor.processRemaining() calls barrier.arrive('genDone')
 
-  // Log final statistics
-  const stats = streamingQueue.getStats();
-  logger.info('Final streaming stats:', stats);
-  logger.info(
-    `Deferred images count: ${deferredImages.length} for message ${messageId}`
-  );
+  // Get deferred images
+  const deferredImages = processor.getDeferredImages();
+  logger.info(`${deferredImages.length} images ready for insertion`);
 
   // Stop processor
-  queueProcessor.stop();
-
-  // Store deferred images
-  if (deferredImages.length > 0 && messageId !== null) {
-    pendingDeferredImages = {images: deferredImages, messageId};
-    logger.info(
-      `${deferredImages.length} images ready, checking if MESSAGE_RECEIVED fired`
-    );
+  processor.stop();
+
+  // Log stats
+  const stats = queue.getStats();
+  logger.info('Final stats:', stats);
+
+  // Wait for barrier and insert deferred images
+  if (deferredImages.length > 0) {
+    // Don't wrap in scheduleDomOperation - insertDeferredImages does that internally
+    // Wrapping would cause deadlock since DOM ops for same message are serialized
+    (async () => {
+      logger.info('Waiting for barrier (genDone + messageReceived)...');
+
+      try {
+        await barrier.whenReady;
+        logger.info('Barrier resolved, inserting deferred images');
+
+        // Check session still current (not cancelled)
+        const currentSession = sessionManager.getCurrentSession();
+        logger.info(
+          `Session check: current=${currentSession?.sessionId}, expected=${sessionId}`
+        );
+
+        if (currentSession?.sessionId !== sessionId) {
+          logger.warn(
+            `Session changed, skipping insertion (current: ${currentSession?.sessionId}, expected: ${sessionId})`
+          );
+          return;
+        }
+
+        // Insert images (this internally uses scheduleDomOperation)
+        logger.info(
+          `Inserting ${deferredImages.length} deferred images for message ${messageId}`
+        );
+        await insertDeferredImages(deferredImages, messageId, context);
+
+        logger.info('Deferred images inserted successfully');
+
+        // End session after successful insertion
+        sessionManager.endSession();
+        logger.info('Session ended after successful insertion');
+      } catch (error) {
+        logger.error('Barrier failed or insertion error:', error);
+        toastr.error('Failed to insert generated images', t('extensionName'));
+
+        // End session even on error
+        sessionManager.endSession();
+        logger.info('Session ended after error');
+      }
+    })();
+  } else {
+    // No deferred images, end session immediately
+    sessionManager.endSession();
   }
 
-  // Clear state
-  streamingQueue = null;
-  streamingMonitor = null;
-  queueProcessor = null;
-  currentStreamingMessageId = null;
-
-  // Show notification if there were issues
-  const failedCount = stats.FAILED;
-  if (failedCount > 0) {
+  // Show notification if failures
+  if (stats.FAILED > 0) {
     toastr.warning(
-      t('toast.streamingFailed', {count: failedCount}),
+      t('toast.streamingFailed', {count: stats.FAILED}),
       t('extensionName')
     );
   }
-
-  // Try to insert if MESSAGE_RECEIVED already fired
-  await tryInsertDeferredImages();
 }
 
 /**
@@ -918,6 +886,10 @@ function initialize(): void {
   // Apply log level from settings
   setLogLevel(settings.logLevel);
 
+  // Initialize SessionManager
+  sessionManager = new SessionManager();
+  logger.info('Initialized SessionManager');
+
   // Initialize concurrency limiter with settings
   initializeConcurrencyLimiter(
     settings.maxConcurrentGenerations,
diff --git a/src/manual_generation.ts b/src/manual_generation.ts
index 574ce4c..e245e81 100644
--- a/src/manual_generation.ts
+++ b/src/manual_generation.ts
@@ -134,182 +134,190 @@ export async function generateImagesForMessage(
           return 0;
         }
 
-    logger.info(`Generating images for message ${messageId} in ${mode} mode`);
-
-    const message = context.chat?.[messageId];
-    if (!message) {
-      logger.warn('Message not found:', messageId);
-      toastr.error(t('toast.messageNotFound'), t('extensionName'));
-      return 0;
-    }
-
-    let text = message.mes;
+        logger.info(
+          `Generating images for message ${messageId} in ${mode} mode`
+        );
 
-    // Extract prompts before any modifications to check if there are any
-    const initialPrompts = extractImagePrompts(
-      text,
-      settings.promptDetectionPatterns
-    );
-    if (initialPrompts.length === 0) {
-      logger.info('No prompts found in message');
-      toastr.info(t('toast.noPromptsFound'), t('extensionName'));
-      return 0;
-    }
+        const message = context.chat?.[messageId];
+        if (!message) {
+          logger.warn('Message not found:', messageId);
+          toastr.error(t('toast.messageNotFound'), t('extensionName'));
+          return 0;
+        }
 
-    logger.info(`Found ${initialPrompts.length} prompts`);
+        let text = message.mes;
 
-    // In replace mode, remove existing images first
-    if (mode === 'replace') {
-      const originalLength = text.length;
-      text = removeExistingImages(text, settings.promptDetectionPatterns);
-      logger.info(
-        `Replace mode: removed existing images (${originalLength} -> ${text.length} chars)`
-      );
-    } else {
-      logger.info('Append mode: will append new images after existing ones');
-    }
+        // Extract prompts before any modifications to check if there are any
+        const initialPrompts = extractImagePrompts(
+          text,
+          settings.promptDetectionPatterns
+        );
+        if (initialPrompts.length === 0) {
+          logger.info('No prompts found in message');
+          toastr.info(t('toast.noPromptsFound'), t('extensionName'));
+          return 0;
+        }
 
-    // Re-extract prompts AFTER text modifications to get correct positions and fullMatch
-    const promptsToGenerate = extractImagePrompts(
-      text,
-      settings.promptDetectionPatterns
-    );
+        logger.info(`Found ${initialPrompts.length} prompts`);
 
-    // Show start notification
-    toastr.info(
-      tCount(promptsToGenerate.length, 'toast.generatingImages'),
-      t('extensionName')
-    );
+        // In replace mode, remove existing images first
+        if (mode === 'replace') {
+          const originalLength = text.length;
+          text = removeExistingImages(text, settings.promptDetectionPatterns);
+          logger.info(
+            `Replace mode: removed existing images (${originalLength} -> ${text.length} chars)`
+          );
+        } else {
+          logger.info(
+            'Append mode: will append new images after existing ones'
+          );
+        }
 
-    // Insert progress widget
-    tryInsertProgressWidgetWithRetry(messageId, promptsToGenerate.length);
+        // Re-extract prompts AFTER text modifications to get correct positions and fullMatch
+        const promptsToGenerate = extractImagePrompts(
+          text,
+          settings.promptDetectionPatterns
+        );
 
-    // Generate images sequentially
-    const startTime = performance.now();
+        // Show start notification
+        toastr.info(
+          tCount(promptsToGenerate.length, 'toast.generatingImages'),
+          t('extensionName')
+        );
 
-    // Step 1: Generate all images first
-    const generatedImages: Array<{
-      prompt: ImagePromptMatch;
-      imageUrl: string;
-      originalIndex: number;
-    }> = [];
+        // Insert progress widget
+        tryInsertProgressWidgetWithRetry(messageId, promptsToGenerate.length);
 
-    for (let i = 0; i < promptsToGenerate.length; i++) {
-      const prompt = promptsToGenerate[i];
-      logger.info(`Generating image ${i + 1}/${promptsToGenerate.length}`);
+        // Generate images sequentially
+        const startTime = performance.now();
 
-      const imageUrl = await generateImage(
-        prompt.prompt,
-        context,
-        settings.commonStyleTags,
-        settings.commonStyleTagsPosition
-      );
+        // Step 1: Generate all images first
+        const generatedImages: Array<{
+          prompt: ImagePromptMatch;
+          imageUrl: string;
+          originalIndex: number;
+        }> = [];
 
-      if (imageUrl) {
-        generatedImages.push({prompt, imageUrl, originalIndex: i});
-      }
+        for (let i = 0; i < promptsToGenerate.length; i++) {
+          const prompt = promptsToGenerate[i];
+          logger.info(`Generating image ${i + 1}/${promptsToGenerate.length}`);
 
-      // Update progress widget after each image (success or failure)
-      updateProgressWidget(messageId, i + 1, promptsToGenerate.length);
-    }
+          const imageUrl = await generateImage(
+            prompt.prompt,
+            context,
+            settings.commonStyleTags,
+            settings.commonStyleTagsPosition
+          );
 
-    // Step 2: Sort by prompt position (end to start) and insert in reverse order
-    // This ensures that inserting later prompts doesn't shift earlier positions
-    generatedImages.sort((a, b) => b.prompt.startIndex - a.prompt.startIndex);
+          if (imageUrl) {
+            generatedImages.push({prompt, imageUrl, originalIndex: i});
+          }
 
-    let successCount = 0;
-    for (const {prompt, imageUrl, originalIndex} of generatedImages) {
-      const promptTag = prompt.fullMatch;
-      const tagIndex = text.indexOf(promptTag);
+          // Update progress widget after each image (success or failure)
+          updateProgressWidget(messageId, i + 1, promptsToGenerate.length);
+        }
 
-      if (tagIndex === -1) {
-        logger.warn(
-          `Could not find prompt tag in text: "${promptTag.substring(0, 80)}..."`
+        // Step 2: Sort by prompt position (end to start) and insert in reverse order
+        // This ensures that inserting later prompts doesn't shift earlier positions
+        generatedImages.sort(
+          (a, b) => b.prompt.startIndex - a.prompt.startIndex
         );
-        continue;
-      }
 
-      {
-        let insertPos = tagIndex + promptTag.length;
+        let successCount = 0;
+        for (const {prompt, imageUrl, originalIndex} of generatedImages) {
+          const promptTag = prompt.fullMatch;
+          const tagIndex = text.indexOf(promptTag);
 
-        // In append mode, find the position after the last existing image
-        if (mode === 'append') {
-          const afterPrompt = text.substring(insertPos);
-          // Match all consecutive img tags after the prompt (including whitespace between them)
-          const imgTagRegex = /\s*<img\s+[^>]*>/g;
-          let lastMatchEnd = 0;
-          let match;
+          if (tagIndex === -1) {
+            logger.warn(
+              `Could not find prompt tag in text: "${promptTag.substring(0, 80)}..."`
+            );
+            continue;
+          }
 
-          // Keep matching img tags until we find a non-img-tag or end of string
-          while ((match = imgTagRegex.exec(afterPrompt)) !== null) {
-            // Check if this match is contiguous with previous matches (only whitespace between)
-            if (
-              match.index === lastMatchEnd ||
-              afterPrompt.substring(lastMatchEnd, match.index).trim() === ''
-            ) {
-              lastMatchEnd = imgTagRegex.lastIndex;
-            } else {
-              // Found non-whitespace content, stop here
-              break;
+          {
+            let insertPos = tagIndex + promptTag.length;
+
+            // In append mode, find the position after the last existing image
+            if (mode === 'append') {
+              const afterPrompt = text.substring(insertPos);
+              // Match all consecutive img tags after the prompt (including whitespace between them)
+              const imgTagRegex = /\s*<img\s+[^>]*>/g;
+              let lastMatchEnd = 0;
+              let match;
+
+              // Keep matching img tags until we find a non-img-tag or end of string
+              while ((match = imgTagRegex.exec(afterPrompt)) !== null) {
+                // Check if this match is contiguous with previous matches (only whitespace between)
+                if (
+                  match.index === lastMatchEnd ||
+                  afterPrompt.substring(lastMatchEnd, match.index).trim() === ''
+                ) {
+                  lastMatchEnd = imgTagRegex.lastIndex;
+                } else {
+                  // Found non-whitespace content, stop here
+                  break;
+                }
+              }
+
+              if (lastMatchEnd > 0) {
+                // Found existing images, insert after them
+                insertPos += lastMatchEnd;
+              }
             }
-          }
 
-          if (lastMatchEnd > 0) {
-            // Found existing images, insert after them
-            insertPos += lastMatchEnd;
+            // Create image tag with index
+            const imageTitle = `AI generated image #${originalIndex + 1}`;
+            const imageTag = `\n<img src="${imageUrl}" title="${imageTitle}" alt="${imageTitle}">`;
+            text =
+              text.substring(0, insertPos) +
+              imageTag +
+              text.substring(insertPos);
+            successCount++;
           }
         }
 
-        // Create image tag with index
-        const imageTitle = `AI generated image #${originalIndex + 1}`;
-        const imageTag = `\n<img src="${imageUrl}" title="${imageTitle}" alt="${imageTitle}">`;
-        text =
-          text.substring(0, insertPos) + imageTag + text.substring(insertPos);
-        successCount++;
-      }
-    }
+        const duration = performance.now() - startTime;
+        logger.info(
+          `Generated ${successCount}/${promptsToGenerate.length} images (${duration.toFixed(0)}ms total)`
+        );
 
-    const duration = performance.now() - startTime;
-    logger.info(
-      `Generated ${successCount}/${promptsToGenerate.length} images (${duration.toFixed(0)}ms total)`
-    );
+        // Update message
+        message.mes = text;
 
-    // Update message
-    message.mes = text;
+        // Emit proper event sequence for DOM update
+        const MESSAGE_EDITED = context.eventTypes.MESSAGE_EDITED;
+        await context.eventSource.emit(MESSAGE_EDITED, messageId);
 
-    // Emit proper event sequence for DOM update
-    const MESSAGE_EDITED = context.eventTypes.MESSAGE_EDITED;
-    await context.eventSource.emit(MESSAGE_EDITED, messageId);
+        context.updateMessageBlock(messageId, message);
 
-    context.updateMessageBlock(messageId, message);
+        const MESSAGE_UPDATED = context.eventTypes.MESSAGE_UPDATED;
+        await context.eventSource.emit(MESSAGE_UPDATED, messageId);
 
-    const MESSAGE_UPDATED = context.eventTypes.MESSAGE_UPDATED;
-    await context.eventSource.emit(MESSAGE_UPDATED, messageId);
+        // Save chat
+        await context.saveChat();
+        logger.debug('Chat saved after manual generation');
 
-    // Save chat
-    await context.saveChat();
-    logger.debug('Chat saved after manual generation');
-
-    // Remove progress widget
-    removeProgressWidget(messageId);
+        // Remove progress widget
+        removeProgressWidget(messageId);
 
-    // Show completion notification
-    if (successCount === promptsToGenerate.length) {
-      toastr.success(
-        tCount(successCount, 'toast.successGenerated'),
-        t('extensionName')
-      );
-    } else if (successCount > 0) {
-      toastr.warning(
-        t('toast.partialGenerated', {
-          success: successCount,
-          total: promptsToGenerate.length,
-        }),
-        t('extensionName')
-      );
-    } else {
-      toastr.error(t('toast.failedToGenerate'), t('extensionName'));
-    }
+        // Show completion notification
+        if (successCount === promptsToGenerate.length) {
+          toastr.success(
+            tCount(successCount, 'toast.successGenerated'),
+            t('extensionName')
+          );
+        } else if (successCount > 0) {
+          toastr.warning(
+            t('toast.partialGenerated', {
+              success: successCount,
+              total: promptsToGenerate.length,
+            }),
+            t('extensionName')
+          );
+        } else {
+          toastr.error(t('toast.failedToGenerate'), t('extensionName'));
+        }
 
         return successCount;
       } catch (error) {
@@ -705,179 +713,185 @@ export async function regenerateImage(
           return 0;
         }
 
-    // Initial message check
-    let message = context.chat?.[messageId];
-    if (!message) {
-      logger.error('Message not found:', messageId);
-      toastr.error(t('toast.messageNotFound'), t('extensionName'));
-      return 0;
-    }
-
-    // Find the prompt for this image (using current message state)
-    const promptText = findPromptForImage(
-      message.mes || '',
-      imageSrc,
-      settings.promptDetectionPatterns
-    );
-    if (!promptText) {
-      toastr.error(t('toast.promptNotFoundForImage'), t('extensionName'));
-      return 0;
-    }
-
-    logger.info(
-      `Regenerating image for prompt: "${promptText}" (mode: ${mode})`
-    );
+        // Initial message check
+        let message = context.chat?.[messageId];
+        if (!message) {
+          logger.error('Message not found:', messageId);
+          toastr.error(t('toast.messageNotFound'), t('extensionName'));
+          return 0;
+        }
 
-    // Insert progress widget
-    tryInsertProgressWidgetWithRetry(messageId, 1);
+        // Find the prompt for this image (using current message state)
+        const promptText = findPromptForImage(
+          message.mes || '',
+          imageSrc,
+          settings.promptDetectionPatterns
+        );
+        if (!promptText) {
+          toastr.error(t('toast.promptNotFoundForImage'), t('extensionName'));
+          return 0;
+        }
 
-    // Generate new image (this respects concurrency limit and may wait in queue)
-    toastr.info(t('toast.generatingNewImage'), t('extensionName'));
-    const imageUrl = await generateImage(
-      promptText,
-      context,
-      settings.commonStyleTags,
-      settings.commonStyleTagsPosition
-    );
+        logger.info(
+          `Regenerating image for prompt: "${promptText}" (mode: ${mode})`
+        );
 
-    // Update progress widget
-    updateProgressWidget(messageId, 1, 1);
+        // Insert progress widget
+        tryInsertProgressWidgetWithRetry(messageId, 1);
 
-    if (!imageUrl) {
-      toastr.error(t('toast.failedToGenerateImage'), t('extensionName'));
-      removeProgressWidget(messageId);
-      return 0;
-    }
+        // Generate new image (this respects concurrency limit and may wait in queue)
+        toastr.info(t('toast.generatingNewImage'), t('extensionName'));
+        const imageUrl = await generateImage(
+          promptText,
+          context,
+          settings.commonStyleTags,
+          settings.commonStyleTagsPosition
+        );
 
-    // IMPORTANT: Re-read message AFTER generation completes
-    // This ensures we have the latest state if other regenerations happened while we were queued
-    message = context.chat?.[messageId];
-    if (!message) {
-      logger.error('Message not found after generation:', messageId);
-      toastr.error(t('toast.messageDisappeared'), t('extensionName'));
-      return 0;
-    }
+        // Update progress widget
+        updateProgressWidget(messageId, 1, 1);
 
-    let text = message.mes || '';
+        if (!imageUrl) {
+          toastr.error(t('toast.failedToGenerateImage'), t('extensionName'));
+          removeProgressWidget(messageId);
+          return 0;
+        }
 
-    // Determine which image index we're regenerating BEFORE modifying the text
-    const imageIndex = findImageIndexInPrompt(
-      text,
-      promptText,
-      imageSrc,
-      settings.promptDetectionPatterns
-    );
-    if (!imageIndex) {
-      logger.error('Could not determine image index for regeneration');
-      toastr.error(t('toast.failedToDetermineIndex'), t('extensionName'));
-      return 0;
-    }
+        // IMPORTANT: Re-read message AFTER generation completes
+        // This ensures we have the latest state if other regenerations happened while we were queued
+        message = context.chat?.[messageId];
+        if (!message) {
+          logger.error('Message not found after generation:', messageId);
+          toastr.error(t('toast.messageDisappeared'), t('extensionName'));
+          return 0;
+        }
 
-    // Find the prompt tag using multi-pattern detection
-    const prompts = extractImagePrompts(text, settings.promptDetectionPatterns);
-    const matchingPrompt = prompts.find(p => p.prompt === promptText);
+        let text = message.mes || '';
 
-    if (!matchingPrompt) {
-      logger.error('Prompt tag not found in text');
-      toastr.error(t('toast.failedToFindPromptTag'), t('extensionName'));
-      return 0;
-    }
+        // Determine which image index we're regenerating BEFORE modifying the text
+        const imageIndex = findImageIndexInPrompt(
+          text,
+          promptText,
+          imageSrc,
+          settings.promptDetectionPatterns
+        );
+        if (!imageIndex) {
+          logger.error('Could not determine image index for regeneration');
+          toastr.error(t('toast.failedToDetermineIndex'), t('extensionName'));
+          return 0;
+        }
 
-    const promptTag = matchingPrompt.fullMatch;
-    const promptIndex = matchingPrompt.startIndex;
-    let insertPos = promptIndex + promptTag.length;
+        // Find the prompt tag using multi-pattern detection
+        const prompts = extractImagePrompts(
+          text,
+          settings.promptDetectionPatterns
+        );
+        const matchingPrompt = prompts.find(p => p.prompt === promptText);
 
-    // In replace mode, find and remove the specific clicked image, remember its position
-    if (mode === 'replace') {
-      const afterPrompt = text.substring(insertPos);
-      const escapedSrc = imageSrc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+        if (!matchingPrompt) {
+          logger.error('Prompt tag not found in text');
+          toastr.error(t('toast.failedToFindPromptTag'), t('extensionName'));
+          return 0;
+        }
 
-      // Find the specific image we clicked
-      const imgPattern = new RegExp(
-        `\\s*<img\\s+src="${escapedSrc}"[^>]*>`,
-        ''
-      );
-      const imgMatch = afterPrompt.match(imgPattern);
+        const promptTag = matchingPrompt.fullMatch;
+        const promptIndex = matchingPrompt.startIndex;
+        let insertPos = promptIndex + promptTag.length;
 
-      if (imgMatch && imgMatch.index !== undefined) {
-        // Found the clicked image - remove it
-        const imgStart = insertPos + imgMatch.index;
-        const imgEnd = imgStart + imgMatch[0].length;
+        // In replace mode, find and remove the specific clicked image, remember its position
+        if (mode === 'replace') {
+          const afterPrompt = text.substring(insertPos);
+          const escapedSrc = imageSrc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 
-        // Remove the image
-        text = text.substring(0, imgStart) + text.substring(imgEnd);
+          // Find the specific image we clicked
+          const imgPattern = new RegExp(
+            `\\s*<img\\s+src="${escapedSrc}"[^>]*>`,
+            ''
+          );
+          const imgMatch = afterPrompt.match(imgPattern);
+
+          if (imgMatch && imgMatch.index !== undefined) {
+            // Found the clicked image - remove it
+            const imgStart = insertPos + imgMatch.index;
+            const imgEnd = imgStart + imgMatch[0].length;
+
+            // Remove the image
+            text = text.substring(0, imgStart) + text.substring(imgEnd);
+
+            // Insert new image at the same position where old one was
+            insertPos = imgStart;
+
+            logger.info(
+              'Removed and will replace clicked image at same position'
+            );
+          } else {
+            logger.warn(
+              'Could not find clicked image in text, will append instead'
+            );
+          }
+        } else {
+          // In append mode, find position after all existing images
+          const afterPrompt = text.substring(insertPos);
+          const imgTagRegex = /\s*<img\s+[^>]*>/g;
+          let lastMatchEnd = 0;
+          let match;
 
-        // Insert new image at the same position where old one was
-        insertPos = imgStart;
+          while ((match = imgTagRegex.exec(afterPrompt)) !== null) {
+            if (
+              match.index === lastMatchEnd ||
+              afterPrompt.substring(lastMatchEnd, match.index).trim() === ''
+            ) {
+              lastMatchEnd = imgTagRegex.lastIndex;
+            } else {
+              break;
+            }
+          }
 
-        logger.info('Removed and will replace clicked image at same position');
-      } else {
-        logger.warn(
-          'Could not find clicked image in text, will append instead'
-        );
-      }
-    } else {
-      // In append mode, find position after all existing images
-      const afterPrompt = text.substring(insertPos);
-      const imgTagRegex = /\s*<img\s+[^>]*>/g;
-      let lastMatchEnd = 0;
-      let match;
-
-      while ((match = imgTagRegex.exec(afterPrompt)) !== null) {
-        if (
-          match.index === lastMatchEnd ||
-          afterPrompt.substring(lastMatchEnd, match.index).trim() === ''
-        ) {
-          lastMatchEnd = imgTagRegex.lastIndex;
-        } else {
-          break;
+          if (lastMatchEnd > 0) {
+            insertPos += lastMatchEnd;
+          }
         }
-      }
-
-      if (lastMatchEnd > 0) {
-        insertPos += lastMatchEnd;
-      }
-    }
 
-    // Count existing regenerations for this image index
-    const regenCount = countRegeneratedImages(
-      text,
-      promptText,
-      imageIndex,
-      settings.promptDetectionPatterns
-    );
-    const nextRegenNumber = regenCount + 1;
+        // Count existing regenerations for this image index
+        const regenCount = countRegeneratedImages(
+          text,
+          promptText,
+          imageIndex,
+          settings.promptDetectionPatterns
+        );
+        const nextRegenNumber = regenCount + 1;
 
-    // Create image tag with meaningful name (without prompt text to avoid display issues)
-    const imageTitle = `AI generated image #${imageIndex} (Regenerated ${nextRegenNumber})`;
-    const imageTag = `\n<img src="${imageUrl}" title="${imageTitle}" alt="${imageTitle}">`;
-    text = text.substring(0, insertPos) + imageTag + text.substring(insertPos);
+        // Create image tag with meaningful name (without prompt text to avoid display issues)
+        const imageTitle = `AI generated image #${imageIndex} (Regenerated ${nextRegenNumber})`;
+        const imageTag = `\n<img src="${imageUrl}" title="${imageTitle}" alt="${imageTitle}">`;
+        text =
+          text.substring(0, insertPos) + imageTag + text.substring(insertPos);
 
-    // Update message
-    message.mes = text;
+        // Update message
+        message.mes = text;
 
-    // Emit proper event sequence for DOM update
-    const MESSAGE_EDITED = context.eventTypes.MESSAGE_EDITED;
-    await context.eventSource.emit(MESSAGE_EDITED, messageId);
+        // Emit proper event sequence for DOM update
+        const MESSAGE_EDITED = context.eventTypes.MESSAGE_EDITED;
+        await context.eventSource.emit(MESSAGE_EDITED, messageId);
 
-    context.updateMessageBlock(messageId, message);
+        context.updateMessageBlock(messageId, message);
 
-    const MESSAGE_UPDATED = context.eventTypes.MESSAGE_UPDATED;
-    await context.eventSource.emit(MESSAGE_UPDATED, messageId);
+        const MESSAGE_UPDATED = context.eventTypes.MESSAGE_UPDATED;
+        await context.eventSource.emit(MESSAGE_UPDATED, messageId);
 
-    // Save chat
-    await context.saveChat();
+        // Save chat
+        await context.saveChat();
 
-    toastr.success(t('toast.imageRegenerated'), t('extensionName'));
-    logger.info('Image regenerated successfully');
+        toastr.success(t('toast.imageRegenerated'), t('extensionName'));
+        logger.info('Image regenerated successfully');
 
-    // Remove progress widget
-    removeProgressWidget(messageId);
+        // Remove progress widget
+        removeProgressWidget(messageId);
 
-    // Re-attach click handlers to all images (including the new one)
-    setTimeout(() => {
-      addImageClickHandlers(context, settings);
-    }, 100);
+        // Re-attach click handlers to all images (including the new one)
+        setTimeout(() => {
+          addImageClickHandlers(context, settings);
+        }, 100);
 
         return 1;
       } catch (error) {
@@ -1276,45 +1290,48 @@ async function deleteImage(
         return false;
       }
 
-  let text = message.mes || '';
-  const originalLength = text.length;
+      let text = message.mes || '';
+      const originalLength = text.length;
 
-  // Escape special characters in the image src for regex
-  const escapedSrc = imageSrc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+      // Escape special characters in the image src for regex
+      const escapedSrc = imageSrc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
 
-  // Find and remove the specific image tag
-  const imgPattern = new RegExp(`\\s*<img\\s+src="${escapedSrc}"[^>]*>`, 'g');
-  text = text.replace(imgPattern, '');
+      // Find and remove the specific image tag
+      const imgPattern = new RegExp(
+        `\\s*<img\\s+src="${escapedSrc}"[^>]*>`,
+        'g'
+      );
+      text = text.replace(imgPattern, '');
 
-  // Check if anything was removed
-  if (text.length === originalLength) {
-    logger.warn('Image not found in message text');
-    toastr.warning(t('toast.imageNotFound'), t('extensionName'));
-    return false;
-  }
+      // Check if anything was removed
+      if (text.length === originalLength) {
+        logger.warn('Image not found in message text');
+        toastr.warning(t('toast.imageNotFound'), t('extensionName'));
+        return false;
+      }
 
-  // Update message
-  message.mes = text;
+      // Update message
+      message.mes = text;
 
-  // Emit proper event sequence for DOM update
-  const MESSAGE_EDITED = context.eventTypes.MESSAGE_EDITED;
-  await context.eventSource.emit(MESSAGE_EDITED, messageId);
+      // Emit proper event sequence for DOM update
+      const MESSAGE_EDITED = context.eventTypes.MESSAGE_EDITED;
+      await context.eventSource.emit(MESSAGE_EDITED, messageId);
 
-  context.updateMessageBlock(messageId, message);
+      context.updateMessageBlock(messageId, message);
 
-  const MESSAGE_UPDATED = context.eventTypes.MESSAGE_UPDATED;
-  await context.eventSource.emit(MESSAGE_UPDATED, messageId);
+      const MESSAGE_UPDATED = context.eventTypes.MESSAGE_UPDATED;
+      await context.eventSource.emit(MESSAGE_UPDATED, messageId);
 
-  // Save chat
-  await context.saveChat();
+      // Save chat
+      await context.saveChat();
 
-  toastr.success(t('toast.imageDeleted'), t('extensionName'));
-  logger.info('Image deleted successfully');
+      toastr.success(t('toast.imageDeleted'), t('extensionName'));
+      logger.info('Image deleted successfully');
 
-  // Re-attach click handlers to remaining images
-  setTimeout(() => {
-    addImageClickHandlers(context, settings);
-  }, 100);
+      // Re-attach click handlers to remaining images
+      setTimeout(() => {
+        addImageClickHandlers(context, settings);
+      }, 100);
 
       return true;
     },
diff --git a/src/queue_processor.ts b/src/queue_processor.ts
index f24058c..6bfa177 100644
--- a/src/queue_processor.ts
+++ b/src/queue_processor.ts
@@ -6,6 +6,7 @@
 import {ImageGenerationQueue} from './streaming_image_queue';
 import {generateImage} from './image_generator';
 import type {QueuedPrompt, DeferredImage} from './types';
+import type {Barrier} from './barrier';
 import {createLogger} from './logger';
 import {
   tryInsertProgressWidgetWithRetry,
@@ -29,6 +30,7 @@ export class QueueProcessor {
   private activeGenerations = 0;
   private processPromise: Promise<void> | null = null;
   private deferredImages: DeferredImage[] = [];
+  private barrier: Barrier | null = null;
 
   /**
    * Creates a new queue processor
@@ -53,8 +55,9 @@ export class QueueProcessor {
    * Starts processing the queue with deferred insertions
    * Images are generated during processing but inserted in batch after completion
    * @param messageId - Message being generated
+   * @param barrier - Optional barrier for coordinating with streaming events
    */
-  start(messageId: number): void {
+  start(messageId: number, barrier?: Barrier): void {
     if (this.isRunning) {
       logger.warn('Already running, stopping previous processor');
       this.stop();
@@ -64,9 +67,10 @@ export class QueueProcessor {
     this.isRunning = true;
     this.activeGenerations = 0;
     this.deferredImages = [];
+    this.barrier = barrier ?? null;
 
     logger.info(
-      `Starting processor for message ${messageId} (max concurrent: ${this.maxConcurrent})`
+      `Starting processor for message ${messageId} (max concurrent: ${this.maxConcurrent}) ${barrier ? 'with barrier' : 'without barrier'}`
     );
 
     // Initialize progress widget for this message
@@ -220,6 +224,13 @@ export class QueueProcessor {
   async processRemaining(): Promise<void> {
     logger.info('Processing remaining prompts...');
 
+    // Signal barrier FIRST before waiting, since we're done queueing new work
+    // This prevents barrier timeout while waiting for active generations
+    if (this.barrier && 'arrive' in this.barrier) {
+      logger.info('Signaling genDone to barrier (before waiting for completions)');
+      this.barrier.arrive('genDone');
+    }
+
     // Wait for any active generations to complete first
     // This prevents concurrent execution beyond maxConcurrent limit
     if (this.activeGenerations > 0) {
@@ -235,17 +246,14 @@ export class QueueProcessor {
     const pending = this.queue.getPromptsByState('QUEUED');
     logger.info(`${pending.length} prompts remaining`);
 
-    if (pending.length === 0) {
-      return;
-    }
-
-    // Process remaining prompts sequentially to respect maxConcurrent
-    // This prevents 429 "Too Many Requests" errors from NovelAI
-    for (const prompt of pending) {
-      await this.generateImageForPrompt(prompt);
+    if (pending.length > 0) {
+      // Process remaining prompts sequentially to respect maxConcurrent
+      // This prevents 429 "Too Many Requests" errors from NovelAI
+      for (const prompt of pending) {
+        await this.generateImageForPrompt(prompt);
+      }
+      logger.info('Finished processing remaining prompts');
     }
-
-    logger.info('Finished processing remaining prompts');
   }
 
   /**
diff --git a/src/session_manager.ts b/src/session_manager.ts
index 8b3a4fe..7e3402c 100644
--- a/src/session_manager.ts
+++ b/src/session_manager.ts
@@ -88,7 +88,7 @@ export class SessionManager {
 
     // Start monitor and processor
     monitor.start(messageId);
-    processor.start(messageId);
+    processor.start(messageId, barrier);
 
     return session;
   }
